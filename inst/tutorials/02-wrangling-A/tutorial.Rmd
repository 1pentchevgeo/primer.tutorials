---
title: "Wrangling-A"
tutorial:
  id: "wrangling-A"
output:
  learnr::tutorial:
      progressive: true
      allow_skip: true
runtime: shiny_prerendered
description: "Chapter 2 Tutorial -- Part A"
---

<!-- Things to fix in this tutorial. -->

<!-- It is a bad idea to create a column called "type" since that is the name of an R function. -->


<!-- Each group (at least for things like characters and factors) should be introduced with a few sentences, ideally with references to the appropriate section of the book. -->

<!-- We need a section devoted to read_*. We need to create, by hand, a bunch of files which are messy in various ways. We store those files in this repo. We then ask questions which require reading in those files and fixing the problems. Not sure if the files should be read in from the package itself or from the web. -->

```{r setup, include=FALSE}
library(tidyverse)
library(lubridate)
library(stringr)
library(learnr)
library(skimr)
library(ranger)
library(primer.tutorials)
knitr::opts_chunk$set(echo = FALSE, message = FALSE)
options(tutorial.exercise.timelimit = 60, tutorial.storage="local") 


# Needed for later sections of the tutorial 

library(fivethirtyeight)
library(nycflights13)
library(ggthemes)
```



## Name 

``` {r name, echo=FALSE}
question_text(
  "Student Name:",
  answer(NULL, correct = TRUE),
  incorrect = "Ok",
  try_again_button = "Modify your answer",
  allow_retry = TRUE
)
```

## Email

``` {r email, echo=FALSE}
question_text(
  "Email:",
  answer(NULL, correct = TRUE),
  incorrect = "Ok",
  try_again_button = "Modify your answer",
  allow_retry = TRUE
)
```


## Characters 
###

The first few exercises focus on various functions that can be used to manipulate strings. 

### Exercise 1

Type `state.name` into the code chunk below. `state.name` is a character vector that comes installed with R and contains the names of all US states and the District of Columbia.

```{r exercise-2-1, exercise=TRUE}

```

```{r exercise-2-1-hint, eval=FALSE}
# Type `state.name` and press Run Code
```


### Exercise 2

Use `str_detect()` on `state.name` to create a vector which will be TRUE for states which contain the pattern "ana" and FALSE otherwise.

```{r exercise-2-2, exercise=TRUE}

```

```{r exercise-2-2-hint, eval=FALSE}
str_detect(..., pattern = ...)
```


### Exercise 3

Use `str_subset()` on `state.name` to create a vector of the names of the states that contain the pattern "ana".

```{r exercise-2-3, exercise=TRUE}

```

```{r exercise-2-3-hint, eval=FALSE}
str_subset(..., pattern = ...)
```

### Exercise 4

Use `str_split()` on `state.name` in order to help identify states which involve two or more words in their names. Set `simplify` argument to TRUE. The result will be a character matrix with 51 rows and three columns.


```{r exercise-2-4, exercise=TRUE}

```

```{r exercise-2-4-hint-1, eval=FALSE}
# A " " is the simple version of a pattern which identifies words spaces.
````

```{r exercise-2-4-hint-2, eval=FALSE}
str_split(..., pattern = ..., simplify = TRUE)
```


### Exercise 5

Try again to identify states whose names consist of two or more words, this time using `str_split_fixed()`.  Set the `n` argument to 2, which should split elements into two parts. Observe what happens to `District of Columbia`.

```{r exercise-2-5, exercise=TRUE}

```

```{r exercise-2-5-hint, eval=FALSE}
str_split_fixed(..., pattern = ..., n = ...)
```


### Exercise 6

Using `str_sub`, create a character vector that contains only the first three letters of each state.

```{r exercise-2-6, exercise=TRUE}

```

```{r exercise-2-6-hint, eval=FALSE}
str_sub(state.name, 1, 3)
```


### Exercise 7

Collapse `state.name` using `str_c()`. Separate them with a comma that is followed by a whitespace. This should create a single character object with all the states.

```{r exercise-2-7, exercise=TRUE}

```

```{r exercise-2-7-hint, eval=FALSE}
str_c(..., collapse = ", ")
```


### Exercise 8

Use `str_c` to collapse states into the form `state1 & state2`. Combine the first 1-25 states with states 26-50. Note that we are excluding the 51st state.

```{r exercise-2-8, exercise=TRUE}

```

```{r exercise-2-8-hint, eval=FALSE}
str_c(..., ..., sep = ...)
```

```{r exercise-2-8-hint-2, eval=FALSE}
# One approach is to use brackets ([]) to subscript out the elements of `states`
# which you want to them combine.
```

### Exercise 9

Use `str_replace()` to replace the pattern `North` with `N.`. For example, transform North Carolina into N. Carolina.

```{r exercise-2-9, exercise=TRUE}

```

```{r exercise-2-9-hint, eval=FALSE}
str_replace(..., pattern = ..., replacement = ...)
```

### Exercise 10

Next, let's see how the above functions can be combined with regular expressions. Use `str_subset()` on `state.name` to create a vector of states that have two a's with a single intervening character in their name:

```{r exercise-2-10, exercise=TRUE}

```

```{r exercise-2-10-hint-1, eval=FALSE}
# Consider using the regex "."
```

```{r exercise-2-10-hint-2, eval=FALSE}
str_subset(..., pattern = ...)
```

### Exercise 11

Use `str_subset()` to identify the same pattern as in the previous question, including now only those states where the pattern occurs at the end of their name.

```{r exercise-2-11, exercise=TRUE}

```

```{r exercise-2-11-hint-1, eval=FALSE}
# Consider using the pattern "a.a$"
```

```{r exercise-2-11-hint-2, eval=FALSE}
str_subset(..., pattern = ...)
```

### Exercise 12

Use `str_subset()` to find `state.name` that contain the letter "a" and then one or more characters and another a.

```{r exercise-2-12, exercise=TRUE}

```

```{r exercise-2-12-hint-1, eval=FALSE}
# Consider using the pattern "a.+a"
```

```{r exercise-2-12-hint-2, eval=FALSE}
str_subset(..., pattern = ...)
```

### Exercise 13

Does capitalization matter? Repeat the previous question but replace the first letter with a capital "A". 

```{r exercise-2-13, exercise=TRUE}

```

```{r exercise-2-13-hint, eval=FALSE}
str_subset(..., pattern = ...)
```

### Exercise 14

Let's use `bind_rows()` to bind `state.name` with the data set `state.abb`. This way we will have a tibble that hows the state name and its abbreviation. Save your values to an object named `state_data`.

```{r brs, exercise = TRUE}

```

```{r brs-hint, eval = FALSE}
state_data <- bind_rows(...,...)
```


### Exercise 14

Start a pipe with `state_data` data set. Add a column `state_length` that takes the `str_length()` of each `state`.

```{r exercise-2-15, exercise=TRUE}

```

```{r exercise-2-15-hint, eval=FALSE}
state_data %>% 
  mutate(... = str_length(...))
```

### Exercise 15

Add `arrange()` to the previous pipe so that the state with the shortest name is first.

```{r exercise-2-16, exercise=TRUE}

```

```{r exercise-2-16-hint, eval=FALSE}
state_data %>% 
  mutate(... = str_length(...)) %>%
  arrange(...)
```



## Factors 
###

### Exercise 1

Let's `glimpse()` the `mpg` data set.

```{r factors-1, exercise=TRUE}

```


### Exercise 2 

Make the `class` column in the `mpg` data frame a factor instead of a character `chr` variable. Do this by using the `mutate()` and `as.factor()` functions. Reassign this changed dataframe as `mpg_fct`. 


```{r factors-2, exercise = TRUE}

```

```{r factors-2-hint, eval=FALSE}
... <- mpg %>%
  mutate(... = as.factor(...))
```

### Exercise 3

Now use the `group_by()` function to group by the `class` variable. Reassign this to `mpg_fct`.

```{r factors-3-setup}
mpg_fct <- mpg %>%
  mutate(class = as.factor(class))
```

```{r factors-3, exercise = TRUE}

```

### Exercise 4

Create a `mean_cty` variable using the `mutate()` and `mean()` functions on the `cty` column for the `mpg_fct` data frame. Reassign this mutated data frame as `mpg_fct`.

```{r factors-4-setup}
mpg_fct <- mpg %>%
  mutate(class = as.factor(class)) %>%
  group_by(class)
```

```{r factors-4, exercise = TRUE}

```

### Exercise 5

Create a ggplot with the independent variable as `class`, the dependent variable as `mean_cty`, and the `geom_point()` function. Names this plot `mpg_plot`.

```{r factors-5-setup}
mpg_fct <- mpg %>%
  mutate(class = as.factor(class)) %>%
  group_by(class) %>%
  summarize(mean_cty = mean(cty))
```

```{r factors-5, exercise = TRUE}

```

```{r factors-5-hint-1, eval=FALSE}
# The independent variable should always be on the x-axis and the dependent 
# variable on the y-axis
```

```{r factors-5-hint-2, eval=FALSE}
mpg_plot <- ggplot(data = ..., mapping = aes(x = ..., y = ...)) +
  ...
```

### Exercise 6

Flip the coordinates of the`mpg_plot` graphic. Reassign the flipped graphic as `mpg_plot`.

```{r factors-6-setup}
mpg_fct <- mpg %>%
  mutate(class = as.factor(class)) %>%
  group_by(class) %>%
  summarize(mean_cty = mean(cty), .groups = "drop_last")

mpg_plot <- ggplot(data = mpg_fct, mapping = aes(x = class,
                                                            y = mean_cty)) +
  geom_point()
```

```{r factors-6, exercise = TRUE}

```

```{r factors-6-hint, eval = FALSE}
# Look at the coord_flip() function
```



## Lists
###


### Exercise 1

Let's create a list. Call this list `mylist` and let it have three items `a`, `b`, and `c`. Then, let `a` be a vector containing 1, 2, and 3. Let `b` be a vector containing 4, 5, and 6, and let `c` be a vector containing 7, 8, and 9


```{r lists-1, exercise=TRUE}

```

```{r lists-1-hint, eval=FALSE}
Consider using the c() function to create the individual vectors for a, b, and c. You could also use the : operator 
```

### Exercise 2

Now, call `str()` on `mylist`. 

```{r lists-2-setup}
mylist <- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))
```

```{r lists-2, exercise=TRUE}

```

### Exercise 3

Now extract a single component `a` from `mylist`

```{r lists-4-setup}
mylist <- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))
```

```{r lists-4, exercise = TRUE}

```

```{r lists-4-hint-1, eval=FALSE}
# Consider using [[]]
```

```{r lists-4-hint-2, eval=FALSE}
# Within the brackets, you can either put the index of a or "a"
```

### Exercise 4

Now, extract the number 5 from `mylist`.

```{r lists-5-setup}
mylist <- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))
```

```{r lists-5, exercise=TRUE}

```


## Date-Times 
###

### Exercise 1

Run the `today()` and `now()` functions.

```{r dttm-1, exercise=TRUE}

```

### Exercise 2

Use functions such as `ymd()` or `mdy()` to convert the strings below into the proper date-time format. 

```{r dttm-2, exercise=TRUE}
date_1 <- "February 29, 2020"

date_2 <- "29 February 2020"

date_3 <- "2020-2-29"

date_4 <- "2/29/2020 16:00:00 UTC"

```

### Exercise 3

Use the `make_datetime()` function to create a date-time for the first moment of the year 2000. 

```{r dttm-3, exercise=TRUE}

```

```{r dttm-3-hint, eval=FALSE}
# The ideal output should be "2000-01-01 UTC"
```


## Binding Rows
###


### Exercise 1

Run `band_instruments` in this code chunk:

```{r exercise-combining-1, exercise=TRUE}

```

```{r exercise-combining-1-hint, eval=FALSE}

```

### Exercise 2

Run `band_instruments2` in the code chunk: 

```{r exercise-combining-2, exercise=TRUE}

```

```{r exercise-combining-2-hint, eval=FALSE}

```

Think about what will happen when we try to bind the rows of these two tibbles together.


### Exercise 3

Use `bind_rows()` to bind `band_instruments` and `band_instruments2`.

```{r question-combining-3, exercise=TRUE}

```

```{r question-combining-3-hint, eval=FALSE}

```


### Exercise 4 

Run `band_members` in the following code chunk:

```{r question-combining-4, exercise=TRUE}

```

Consider the discrepancy between the columns of `band_instruments2` and `band_members`. Predict, in your head, what will happen when binding the rows of the two tibbles.


### Exercise 5

Bind the two dataframes `band_instruments2` and `band_members`:

```{r question-combining-5, exercise=TRUE}


```

```{r question-combining-5-hint, eval=FALSE}
bind_rows(band_instruments2, ...)
```



## Joins
###


### Exercise 1

Now use the extraction operator `$` on the `plays` columns of both `band_instruments` and `band_instruments2`.

```{r question-combining-11, exercise=TRUE}

```

```{r question-combining-11-hint, eval=FALSE}
band_instruments$...

band_instruments2$...
```

### Exercise 2

`full_join()` the `band_instruments` and `band_instruments2` dataframes by the `plays` columns. Visually confirm your answer to the question above.

```{r question-combining-12, exercise=TRUE}

```

```{r question-combining-12-hint, eval=FALSE}
full_join(..., ..., by = ...)
```


### Exercise 3

`inner_join()` the `band_instruments` and `band_instruments2` dataframes by the `plays` columns. Visually confirm your answer to the question above.

```{r question-combining-13, exercise=TRUE}

```

```{r question-combining-13-hint, eval=FALSE}
inner_join(..., ..., by = ...)
```



## Tidying Data
###

### Exercise 1 

Run `table1` and `table2` in the code chunk below. 

```{r tidy-1, exercise=TRUE}

```

```{r q2, echo = FALSE}
question("Do the two data data sets above contain the variables **country**, 
         **year**, **cases**, and **population**?",
         answer("Yes", correct = TRUE, message = "If you look closely, you 
                will see that this is the same data set as before, but organized 
                in a new way."),
         answer("No", message = "Don't be mislead by the two new column names: 
                a variable and a column name are not necessarily the same thing."),
         allow_retry = FALSE)
```

These data sets reveal something important: _you can reorganize the same set of variables, values, and observations in many different ways._

It's not hard to do. If you run the code chunks below, you can see the same data displayed in three more ways. 

```{r tidy-2, exercise = TRUE}
table3
```

```{r tidy-3, exercise = TRUE}
table4a; table4b
```

```{r tidy-4, exercise = TRUE}
table5
```

Among our tables above, only `table1` is tidy.

The tidy data format works so well for R because it aligns the structure of your data with the mechanics of R, so let's try to tidy a tibble. 


### Exercise 2

Run `relig_income` in the code chunk below. 

```{r tidy-5, exercise = TRUE}

```

### Exercise 3

You can use the `pivot_longer()` to convert wide data to long data. Let's use the `pivot_longer` to tidy the data, pivoting all of the columns.  Pivot all column except for the `cols` to everything but the `religion` column. Set `names_to` to "income" and`values_to` to "count". 

and setting the new name to "year" and the new values to "cases".

```{r tidy-7, exercise=TRUE}

```

```{r tidy-7-hint-1, eval=FALSE}
Consider using - to select the columns you want to pivot
```

```{r tidy-7-hint-2, eval=FALSE}
relig_income %>% 
  pivot_longer(-religion,
  names_to = ...,
  values_to = ...)
```

### Exercise 4

Let's now look at the `us_rent_income` data set. Call the data set below. 

```{r tidy-ee, exercise=TRUE}

```

```{r tidy-ee-hint, eval=FALSE}

```

### Exercise 5

You can "spread" the keys in a key column across their own set of columns with the `pivot_wider()`. Set `names_from` to `variable` and set `values_from`  to `c(estimate, moe))`.



```{r tidy-12, exercise=TRUE}

```

```{r tidy-12-hint, eval=FALSE}
... %>% 
  pivot_wider(names_from = ..., values_from = ..., names_prefix = ...)
```

<!-- ### Exercise 6 -->

<!-- Let's apply `pivot_wider()` to a real world inquiry. The ratio of girls to boys in `babynames` is not constant across time. To explore this phenomenaon we can directly plot a ratio of boys to girls over time. To make such a plot, you would need to compute the ratio of boys to girls for each year from 1880 to 2015 -->
<!-- Call `babynames` first to see the data set. -->

<!-- ```{r tidy-13, exercise=TRUE} -->

<!-- ``` -->


<!-- ### Exercise 8  -->

<!-- First, create a variable called `babynames_wider`. And `group_by()` the `year` and `sex` variables. -->

<!-- ```{r tidy-14, exercise=TRUE} -->

<!-- ``` -->


<!-- ### Exercise 9 -->

<!-- Now take `babynames_wider` and `summarize()` the take the `sum()` of the `n` column. Call this summarized column `total`. Be sure to reassign this to `babynames_wider`.  -->

<!-- ```{r tidy-15-setup} -->
<!-- babynames_wider <- babynames %>% -->
<!--   group_by(year, sex) -->
<!-- ``` -->

<!-- ```{r tidy-15, exercise=TRUE} -->

<!-- ``` -->


<!-- ### Exercise 10 -->

<!-- But how can we plot this data? Our current iteration of `babynames` places the total number of boys and girls for each year in the same column, which makes it hard to use both totals in the same calculation. Use `pivot_wider()` to pivot the `sex` and `total` columns. Choos which should be the key/name and which should be the value. Be sure to reassign this to `babynames_wider`.  -->

<!-- ```{r tidy-16-setup} -->
<!--  babynames_wider <- babynames %>% -->
<!--   group_by(year, sex) %>% -->
<!--   summarize(total = sum(n), .groups = "drop_last") -->
<!-- ``` -->

<!-- ```{r tidy-16, exercise=TRUE} -->

<!-- ``` -->

<!-- ```{r tidy-16-hint, eval=FALSE} -->
<!-- babynames_wider <- babynames_wider %>% -->
<!--   pivot_wider() -->
<!-- ``` -->

<!-- ### Exercise 11 -->

<!-- Now, mutate a column `ratio` that divides `M/F`. -->

<!-- ```{r tidy-17-setup} -->
<!--  babynames_wider <- babynames %>% -->
<!--   group_by(year, sex) %>% -->
<!--   summarize(total = sum(n), .groups = "drop_last") %>% -->
<!--   pivot_wider(names_from = sex, values_from = total) -->
<!-- ``` -->

<!-- ```{r tidy-17, exercise=TRUE} -->

<!-- ``` -->

<!-- ### Exercise 12 -->

<!-- Now create a `ggplot` line plot that takes `year` on the x-axis and `ratio` on the y-axis.  -->

<!-- ```{r tidy-18-setup} -->
<!-- babynames_wider <- babynames %>% -->
<!--   group_by(year, sex) %>% -->
<!--   summarize(total = sum(n), .groups = "drop_last") %>% -->
<!--   pivot_wider(names_from = sex, values_from = total) %>% -->
<!--   mutate(ratio = M / F) -->
<!-- ``` -->

<!-- ```{r tidy-18, exercise=TRUE} -->

<!-- ``` -->




## Submit

```{r context="setup"}
submission_ui
```

```{r context="server"}
submission_server()
```

