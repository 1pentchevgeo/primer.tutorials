---
title: "Visualization B"
tutorial:
  id: "visualization-b"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: "Chapter 1 Tutorial Part B"
---

<!-- DK: This should be 75+ questions. Students need to do a bunch of select (and filter and group_by) statements before they are good at each of these commands. Maybe have a section for each main Tidyverse command and then 10 questions which require using those commands. Later sections require the use of multiple commands in a chain. Make the sections mirror the chapter sub-sections. Last question section is the danger of grouping and then forgetting you have grouped. group_by followed by slice does not get the top 10 in the data set. Instead it gets the top 10 in each group. Not the same. Remember class example. [done? introduced summarize() briefly on analogy with mutate(). gave slice example with group_by() at the end of that section.] --> 

<!-- NL: A. Add wisdom: wisdom about ==, wisdom about pipe keyboard shortcut, B. Include |, select-, na.rm, starts_with(), quantile, pull, c() and with it perhaps a progression of questions that make the existence of mean() outside of summarize() more clear C. ex. 12, 13, 14 workflow as is needs to be more specific, change intended workflow? Yes!  [done. will introduce quantile, na.rm, and c() in visualization B]--> 




```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(primer.data)
library(learnr)

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
```


## Information
###

```{r information}
quiz(caption = "",
  question_text(
    "Name:",
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL),
  question_text(
    "Email:",
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL))
```



## `filter()`
###

Let's practice how to use `filter()` tibbles to include only the rows with attributes we want to see.  

### Exercise 1

Use `glimpse()` to look at the data set `cces`.

```{r tv-1, exercise = TRUE}

```

### Exercise 2

Start your code with `cces`. Use the pipe operator `%>%` to add the function `filter()`. Within `filter()` use the argument to select the rows where `state` is equal to "Massachusetts". To set something equal to a value in `filter` use two equal signs, `==`.

```{r tv-2, exercise = TRUE}

```

```{r tv-2-hint, eval = FALSE}
cces %>% 
  filter(state == "...")
```

`==` is used because it is **checking** whether the value is equal, while `=` is used to set something equal to something else. 

The pipe operator is used very often but is inconvenient to type. The keyboard shortcut "`ctrl` (Mac: `command`) +`shift` + `M`" makes the pipe operator. Get used to using this shortcut. 

### Exercise 3

Great. Copy/paste your code from above. Let's now extend our code within `filter()` to include data where `state` is "Massachusetts" AND where `ideology` is "Liberal". Use the "and operator" `&` to separate the conditions. 

```{r tv-3, exercise = TRUE}

```

```{r tv-3-hint, eval = FALSE}
cces %>% 
  filter(state == "..." &
        ideology == "...")
```

### Exercise 4

Start a new pipe with `cces`. `filter()` the data for rows where both `gender` is "Male" and `age` is greater than or equal to 40. Instead of using `&` to separate the two conditions, use a comma. 

```{r tv-4, exercise = TRUE}

```

```{r tv-4-hint, eval = FALSE}
cces %>% 
  filter(gender == "...",
           age >= 40)
```

### 

Using a comma to separate arguments in `filter()` is equivalent to using `&`. The command above returns a tibble of males who are also older than 40. 

You do not need to write `40` in quotation marks because it is an integer variable, not a character variable. The same goes for all numeric variable types (dbl, numeric). You can see a variable's type under the column in brackets. 

### Exercise 5

Start a new pipe with `cces.` `filter()`  the data for rows where `gender` is "Male" OR `age` is greater than or equal to 40. Use the "or operator" `|` to separate the conditions. 

```{r tv-5, exercise = TRUE}

```

```{r tv-5-hint, eval = FALSE}
cces %>% 
  filter(gender == "..." |
           age >= ...)
```

###

This tibble has more than twice as many rows as the previous command. In addition to all the rows in the preceeding tibble, it also includes men who are younger than 40 and women over the age of 40. 

### Exercise 6

Copy/paste your code from above. Let's organize the tibble by values of `age` in ascending order. Extend your code with `%>%` and use the function `arrange()`. 

```{r tv-6, exercise = TRUE }

```

```{r tv-6-hint, eval = FALSE}
cces %>% 
  arrange(age)
```

###

Everyone in the first few rows should be 18. Everyone will also be male because of the way we have filtered the data. 

We do not use quotes for the argument of `arrange()`, because it is a column that exists in our data frame. This is the case for most functions which take an existing column as an argument. 

### Exercise 7

Copy/paste your code from above. Now let's organize the tibble by values of `age` in descending order. Extend your code with `%>% ` and use `arrange(desc())`.


```{r tv-7, exercise = TRUE}

```

```{r tv-7-hint-2, eval = FALSE}
cces %>% 
  arrange(desc(age))
```

### Exercise 8

Start a new pipe with `cces`. Instead of just those who live in Massachusetts and have liberal ideology, let's filter the data to those who live in either Massachusetts, New Hampshire, or Vermont and have liberal ideology. Let's start with the states. While we could type `state == "..."` separated by `|` three times, this is cumbersome. Instead we can use a vector with the three state names `c("Massachusetts", "New Hampshire", "Vermont")` and the `%in%` operator in place of the `==`. 

```{r tv-8, exercise = TRUE}

```

```{r tv-8-hint, eval = FALSE}
cces %>% 
  filter(state %in% c("...", "...", "..."))
```

###

Using the `==` will return a tibble but NOT the tibble with the results you are looking for. When filtering for any of several terms in a vector, always use  `%in%`.

We use the `!=` to reverse the results of the `==`, i.e. to include everything except what is in the condition. We cannot do the same by adding an exclamation directly in front of the `%in%` operator. Instead, we would type  `filter(!(state %in% c("Massachusetts", "New Hampshire", "Vermont)))`. Enclosing any condition within `!()` would have the same effect. 

### Exercise 9

Copy/paste your code from above. Add a new condition with a comma, and filter the data to just those who reside in the states and are of liberal ideology. 

```{r tv-9, exercise = TRUE}


```

```{r tv-9-hint, eval = FALSE}
cces %>% 
  filter(state %in% c("...", "...", "..."),
         ideology == "Liberal")
```

### Exercise 10

Copy/paste the code above. Let's filter our data to just the 200 youngest liberals who live in these three states. First, continue your pipe with `%>%` and use `arrange()` to arrange by age from youngest to oldest. 

```{r tv-10, exercise = TRUE}

```

```{r tv-10-hint, eval = FALSE}
cces %>% 
  filter(state %in% c("...", "...", "..."),
         ideology == "...") %>% 
  
```

### Exercise 11

Because of the way we have arranged the data, the 200 rows with the lowest age value would be the first 200. Copy/paste your code from above. Continue your pipe with `%>%` and use `slice()` to make a tibble of only the first two hundred rows. 

```{r tv-11, exercise = TRUE}


```

```{r tv-11-hint-1, eval = FALSE}
Within `slice()` use the argument 1:200
```

###

`slice(200)` instead of `slice(1:200)` will return a tibble which contains only the 200th row. 

Remember that the `:` operator represents a consecutive series, in this case of integers from 1 to 200. 

###

Good work. 

## `select()`
###

Let's practice how to use `select()` tibbles to include only the columns which we want to see.  

### Exercise 1

Use `glimpse()` to look at the data set `shaming`.

```{r select-1, exercise = TRUE}

```

### Exercise 2

Let's make a tibble with just the columns `sex` and `age`. Use the function `select()` which takes the column names as arguments, separated by a comma. 

```{r select-2, exercise = TRUE}

```

```{r select-2-hint, eval = FALSE}
shaming %>% 
  select(sex, age)
```

### 

`select()` will produce the columns of the new tibble in the order specified within the function. 

As we have seen in other functions, names of existing columns does not use quatation marks 

### Exercise 3

Start a new pipe with `shaming`. The `tidyverse` uses several tools to make selecting columns easier. Use `select()` and `:` to make a tibble with the columns `primary_00`, `general_00`, `primary_02`, `general_02`, `primary_04`, `general_04`.  

```{r select-3, exercise = TRUE}

```

```{r select-3-hint-1, eval = FALSE}
As with integers, : defines a consectuive series with the first and last terms of the series. 
```

```{r select-3-hint-w, eval = FALSE}
shaming %>% 
  select(primary_00:general_04)
```

### 

Notice that when selecting, unlike when filtering, R will try to suggest column names as you type. 

### Exercise 4

The `tidyverse` uses several tools to make selecting groups of columns easier. Start a new pipe with `shaming`. Use `select()` and within it the `starts_with()` helper fuction to select all the columns that begin with the string `"primary"`.


```{r select-4, exercise = TRUE}

```

```{r select-4-hint-1, eval = FALSE}
shaming %>% 
  select(start_with("...")
```

### 

We put `"primary"` in quotes because it is a string we are searching for, not the full name of an existing column.

### Exercise 5

Start a new pipe with `shaming`. Use `select()` and the helper function `contains()` to select all columns that contain an underscore `"_"`.

```{r select-5, exercise = TRUE}

```

```{r select-5-hint, eval = FALSE}
shaming %>% 
  select(contains("..."))
```

###

There is a select_help function similar to `contains()` named `matches()`, which can take regular expressions with metacharacters as you have seen in Terminal with `grep()`. 

### Exercise 6

Start a new pipe with `shaming`. First filter the data for rows in which the value of `primary_06` is equal to `"Yes"`.

```{r select-6, exercise = TRUE}

```

```{r select-6-hint, eval = FALSE}
shaming %>% 
  filter(primary_06 == "...")
```

###

Remember that filter uses the `==` operator. 

### Exercise 7

Copy/paste your code. Now continue your pipe and select the `age` and `sex` columns. 

```{r select-7, exercise = TRUE}

```

```{r select-7-hint, eval = FALSE}
shaming %>% 
  filter(...)
  select(..., ...)
```

### Exercise 8

Copy/paste your code. Now continue your pipe with the function `pull()` which takes the `age` column as its argument. `pull()` selects a variable and outputs its contents as a vector not in a data frame

```{r select8, exercise = TRUE}

```

```{r select-8-hint, eval = FALSE}
... %>% 
  pull(age)
```

### Exercise 9

Copy/paste your code. In front of `shaming` use the `<-` operator to assign the whole pipe to an object called voter_ages.

```{r select-9, exercise = TRUE}

```

```{r select-9-hint, eval = FALSE}
... %>% 
  pull(age)
```

This saves the output of all the code in the pipe, a vector of voter ages, to an object named `voter_ages`. 

### Exercise 10

Copy/paste your code. Do not continue your pipe with the pipe operator. Instead use the `mean()` function to find the mean of the vector `voter_ages`. 

```{r select-10, exercise = TRUE}

```

```{r select-10-hint, eval = FALSE}
mean(voter_ages)
```

## `mutate()`
###

### Exercise 1

Run `?shaming` to open the help page for the data set `shaming`. Read the description and peruse the column names. 

```{r mutate-1, exercise = TRUE}

```

###

When not in a tutorial, the help page appears in the lower right corner of RStudio. 

### Exercise 2 

We can also use `select()` to select columns that we want to exclude from our data. Every column that follows a `-` sign in will be excluded. Start your pipe with Use `select()` and `-` to exclude the columns `race`, `liberal`, `age`, `income`, `line`,  and `station`. 

```{r mutate-2, exercise = TRUE}

```

### Exercise 3

The function `mutate` allows us to create new columns or change old ones by manipulating data in existing columns. Start a pipe with `trains`. Use `mutate()` to make a new column called `age_scaled`, set this equal to the `age` column divided by 10. 

```{r mutate-3, exercise = TRUE}

```

```{r mutate-3-hint, eval = FALSE}
... %>% 
  mutate(age_scaled = ... / ...)
```

### 

This new column does not affect the original data set `trains` unless you assign the new tibble to an object with the `<-` operator. If you were to assign it to the object `trains`, it would override the original object for your current R session. 


### Exercise 4

Copy/paste your code. Continue your pipe and use `mutate()` to create a new column called `att_change` which is equal to `att_end` - `att_start`. 

```{r mutate-4, exercise = TRUE}

```

```{r mutate-4-hint, eval = FALSE}
... %>% 
  mutate(att_change = ... - ...)
```

### Exercise 5

Copy/paste your code. Let's create a new column that has the value `TRUE` when `party` is "Democrat" and `FALSE` when it is not. Continue your pipe and use `mutate()` to create a new column called `democrat`. Set `democrat` equal to an `if_else()` function. The first argument is the condition that determines your outputs, `party == "Democrat"`. The second and third arguments represents the output when the condition is true and false, respectively. Set these equal to `TRUE` and `FALSE`. 

```{r mutate-5, exercise = TRUE}

```

```{r mutate-5-hint, eval = FALSE}
... %>% 
  mutate(democrat = if_else(party == "Democrat", TRUE, FALSE))
```

###

`TRUE` and `FALSE` should not be included in quotes. They are boolean type variables and can be used conveniently in many situations where character variables cannot.

### Exercise 6

Copy/paste your code. Continue your pipe and use `mutate()` to create a new column `big_hisp_perc` which returns `TRUE` when `hisp_perc` is greater than or equal to .04 and false when it is not. This will return `NA` because there is a missing value in the `hisp_perc` column.

```{r mutate-6, exercise = TRUE}

```

```{r mutate-6-hint, eval = FALSE}
... %>% 
  mutate(big_hisp_perc = if_else(hisp_perc > .04, TRUE, FALSE))
```

###

Do not forget to close both opening parentheses. 

### Exercise 7

Copy/paste your code. To use mutate to edit an existing column, make the "new column" the same name as the old one. Let's make a new  `treatment` column to have value `"T"` if `treatment` is equal to `"Treated"` and `"C"` when it is not. 

```{r mutate-7, exercise = TRUE}

```

```{r mutate-7-hint, eval = FALSE}
... %>% 
  mutate(treatment = if_else(treatment == "Treated", "T", "C"))
```

### Exercise 8

Copy/paste your code. The function `mutate()` is similar to `summarize()` but creates its new column in a summary table. Within the function `summarize()`, create a column named `mean_change` and set it to the `mean()` of `att_change` and a column named `max_change` and set it equal to the `max()` of the same column. Separate the two column you are creating with a comma.

```{r mutate-8, exercise = TRUE}

```

```{r mutate-8-hint, eval = FALSE}
... %>% 
  summarize(mean_change = mean(...), 
            max_change = max(...))
```

### Exercise 9

More commonly, `summarize()` is used to generate summary statistics not for the whole data but `groups` of data. Copy/paste your pipe before the last `summarize()` command. First, continue your pipe and use the function `group_by()` to group the data by the columns `democrat` and `big_hisp_perc`. 

```{r mutate-9, exercise = TRUE}

```

```{r mutate-9-hint, eval = FALSE}
... %>% 
  group_by(democrat, big_hisp_perc)
```

### Exercise 10

Now use summarize to generate the same columns, a `mean_change` which has the mean of column `att_change` and a `max_change` with has the maximum of the same column. The tibble you ouput now has four rows, one for each combination of our two groups. 

```{r mutate-10, exercise = TRUE}

```

```{r mutate-10-hint, eval = FALSE}
... %>% 
  group_by(democrat, ...) %>% 
  summarize(mean_change = mean(...), 
            max_change = max(...))
```

### Exercise 11 

Notice that the tibble has 5 instead of the expected 4 rows. This is because there was a missing value in `hisp_perc` and so it could not be assigned to either `TRUE` or `FALSE` when you created `big_his_perc`. Copy/paste your code.  Use the function `drop_na()` with the column `big_hisp_perc` as its argument to remove this row from the data. 

```{r mutate-11, exercise = TRUE}

```

```{r mutate-11-hint, eval = FALSE}
... %>% 
  group_by(democrat, ...) %>% 
  summarize(mean_change = mean(...), 
            max_change = max(...))
```

###

`drop_na()` without an argument removes all rows containing values NA in any column from a tibble. 

It is best practice to consider NA values before you do an operation, not after as we have done here. Many functions, including `mean()`, return errors if you ask them to evaluate a mix of `NA` and non-NA values. In this case, however, the single NA was not being evaluated. 

### Exercise 12 

Copy/paste your code. Use `arrange()` to arrange your summary table by `mean_change` in ascending order.

```{r mutate-12, exercise = TRUE}

```

```{r mutate-12-hint, eval = FALSE}
... %>% 
  arrange(mean_change)

```

###

### Exercise 13

Copy/paste your code before the current `summarize()` command, i.e. your code from Exercise 9 which ends with the `group_by()` command. Run `drop_na()` to get rid of the missing row in `hisp_perc`. Arrange this tibble by `att_change` in descending order. 

```{r mutate-13, exercise = TRUE}

```

```{r mutate-13-hint, eval = FALSE}
... %>% 
  arrange(att_change)

```

### Exercise 14

Copy/paste your code. Use the `slice()` function to make a tibble with the first 5 rows. The tibble we get when we run this, however, has 20 rows. This is because the data was grouped, and so `slice()` made a tibble of the rows containing the 5 highest `att_change` for each group. 

```{r mutate-14, exercise = TRUE}

```

```{r mutate-14-hint, eval = FALSE}
... %>% 
  slice(1:5)
```

### Exercise 15

Copy/paste your code before the `slice()` function. To ungroup the table, continue your pipe and use the function `ungroup()`. Now try to slice the first 5 rows. 

```{r mutate-15, exercise = TRUE}

```

```{r mutate-15-hint, eval = FALSE}
... %>% 
  ungroup() %>% 
  slice(1:5)
```

Good work. 

## Submit

```{r context = "setup"}
submission_ui
```

```{r context = "server"}
submission_server()
```





