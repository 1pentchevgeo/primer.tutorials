---
title: "One Parameter"
tutorial:
  id: "one-parameter"
output:
  learnr::tutorial:
      progressive: true
      allow_skip: true
runtime: shiny_prerendered
description: "Chapter 6 tutorial"
---

<!-- Things to Fix: -->

<!-- DONE: Virtual shovel culminates in making "Distributions of 1,000 red" -->

<!-- DONE: Different sample sizes culminates in Figure 6.7, maybe simpler. Not 100 shovel size. Maybe just 5, 10, 50, 100, 500. -->

<!-- Standard error just needs a question or two --- maybe a written sentence or two --- about what a standard error is. Like ch 4 tutorial questions at start. -->

<!-- Posterior distribution is for the proportion red beads or whatever. Located at "To visualize this in a 3D plot" -->

<!-- Need one more section which using the posterior to, for example, create the posterior of number red which will be drawn with a shovel of size 20. Use a posterior to create a new postrerior. Turtles all the way down. -->

<!-- Add a use the posterior section to answer a question. Add a standard error. Change standard deviation section to standard error section. -->

 <!-- Read the chapter and see how we have removed the infer package. The sampling is done "by hand" now. Change the exercises below to do the same. This means that functions like use_shovel may not be needed. But prop_red might still be? Key: Make it like the chapter. Maybe we don't need extra functions at all? -->

<!-- DK: Add use of posterior to make a forecast exercise. Note that we might end up simplifying how this is done in the chapter. -->

<!-- 0) Find all the DK comments and address them -->
<!-- 1) Each section finishes with a nice plot. The student is show the plot in the last step and told to, approximately, replicate it. Of course, this will just involve adding a couple of items to whatever was the version in the second to last question. -->

<!-- DK: Should we do something with sta_glm? Probably not. -->


```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(skimr)
library(infer)

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

# Key Data

set.seed(10)
urn <- tibble(color = c(rep("red", 400), rep("white", 600))) %>%
  sample_frac() %>% 
  mutate(ID = 1:1000) %>% 
  select(ID, color)

set.seed(9)
virtual_samples <- tibble(ID = 1:1000) %>% 
  mutate(shovel = map(ID, ~ sample_n(urn, size = 50))) %>% 
  mutate(numb_red = map_int(shovel, ~ sum(.$color == "red"))) %>% 
  mutate(numb_beads = map_int(shovel, ~ length(.$color))) %>% 
  mutate(prop_red = numb_red / numb_beads)

prop_red <- function(x, shovel_size, reps){
  tibble(ID = 1:reps) %>% 
    mutate(shovel = map(ID, ~ sample_n(x, size = shovel_size))) %>% 
    mutate(numb_red = map_int(shovel, ~ sum(.$color == "red"))) %>% 
    mutate(numb_beads = map_int(shovel, ~ length(.$color))) %>% 
    mutate(prop_red = numb_red / numb_beads)
}



```

## Information
###

```{r information}
quiz(caption = "",
  question_text(
    "Name:",
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL),
  question_text(
    "Email:",
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL))
```


## Virtual sampling
###

Let's create the following plot that shows sampling variation for 1000 samples from an urn that contains red and white beads.

```{r virts_p}
set.seed(9)
virtual_samples <- tibble(ID = 1:1000) %>% 
  mutate(shovel = map(ID, ~ sample_n(urn, size = 50))) %>% 
  mutate(numb_red = map_int(shovel, ~ sum(.$color == "red"))) %>% 
  mutate(numb_beads = map_int(shovel, ~ length(.$color))) %>% 
  mutate(prop_red = numb_red / numb_beads)

virtual_samples %>% 
  ggplot(aes(x = prop_red)) +
    geom_histogram(binwidth = 0.01, 
                   boundary = 0.4, 
                   color = "white") +
    labs(x = expression(hat(p)), 
         y = "Count",
         title = "Distribution of 1,000 proportions red") 

```

### Exercise 1

Type `urn` below to inspect the urn we will be using in this section.

```{r shovel1, exercise = TRUE}
set.seed(10)
urn <- tibble(color = c(rep("red", 400), rep("white", 600))) %>%
  sample_frac() %>% 
  mutate(ID = 1:1000) %>% 
  select(ID, color)
```

### Exercise 2

To simulate the process of real-world sampling, letâ€™s take a sample of 50 beads from our virtual urn. To do so, start a pipe by creating a `tibble()` that has one variable `ID` that takes on the values 1 to 1000.

```{r shovel2, exercise = TRUE}

```

```{r shovel2-hint, eval = FALSE}
tibble(ID = ...)
```

### Exercise 3

Great. Now pipe your results to the function `mutate()` to create the variable `shovel`, which is set to the function `map()`. The first argument to `map()` should be `ID`. The second argument should use `sample_n()` to take a sample of 50 beads from `urn`.

```{r shovel3, exercise = TRUE}

```

```{r shovel3-hint, eval = FALSE}
tibble(ID = 1:1000) %>% 
  mutate(shovel = map(..., ~ sample_n(urn, size = ...)))
```

### Exercise 4

Continue your pipe with `mutate()` to create the variable `numb_red`, which tells us the number of red beads present. Set `numb_red` to the function `map_int()`. The first argument to `map_int()` should be `shovel`. The second argument should take the `sum()` of where the column `color` of `shovel` is equal to red.

```{r shovel4, exercise = TRUE}

```

```{r shovel4-hint, eval = FALSE}
... %>% 
  mutate(... = map_int(..., ~ sum(.$color == "red")))
```

### Exercise 5

Great. Now use `mutate()` to create the variable `numb_beads`, which is set to the function `map_int()`. The first argument to `map_int()` should be `shovel`. The second argument should take the `length()` of the column `color` of `shovel`.
 

```{r shovel5, exercise = TRUE}

```

```{r shovel5-hint-1, eval = FALSE}
... %>% 
  mutate(numb_beads = map_int(..., ~ length(...)))
```

```{r shovel5-hint-2, eval = FALSE}
... %>% 
  mutate(numb_beads = map_int(..., ~ length(.$color)))
```

### Exercise 6

Use `mutate()` one last time to create the variable `prop_red`, our estimate of the proportion of red beads in the urn. Set `prop_red` to `numb_red` divided by `numb_beads`.

```{r shovel6, exercise = TRUE}

```

```{r shovel6-hint, eval = FALSE}
... %>% 
   mutate(prop_red = ... / ...)
```

### Exercise 7

Copy/paste your code from above. Assign your code to an object named `virtual_samples`.

```{r shovel7, exercise = TRUE}

```

```{r shovel7-hint, eval = FALSE}
Use the assignment operator to do so.
```

### Exercise 8

Awesome. Now start a pipe with `virtual_samples`. Use `ggplot()`to map `prop_red` to the x-axis. Also, add the layer `geom_histogram()` to create a histogram of our data.

```{r shovel8, exercise = TRUE}

```


```{r shovel8-hint-1, eval = FALSE}
ggplot(aes(...)) + 
  geom_histogram()
```

### Exercise 9

Within `geom_histrogram()` set `binwidth` to .01, boundary to .4, and `color` to "white".

```{r shovel9, exercise = TRUE}

```

```{r shovel9-hint, eval = FALSE}
... +
  geom_histrogram(..., ..., ...)
```

### Exercise 10

To finish, use `labs()` to give your graph the appropriate title and axis labels. See **hint** for guidance to create the symbol $\hat{p}$.


```{r shovel10, exercise = TRUE}

```

Reminder: This is what your plot should look like. 

```{r}
set.seed(9)
virtual_samples <- tibble(ID = 1:1000) %>% 
  mutate(shovel = map(ID, ~ sample_n(urn, size = 50))) %>% 
  mutate(numb_red = map_int(shovel, ~ sum(.$color == "red"))) %>% 
  mutate(numb_beads = map_int(shovel, ~ length(.$color))) %>% 
  mutate(prop_red = numb_red / numb_beads)

virtual_samples %>% 
  ggplot(aes(x = prop_red)) +
    geom_histogram(binwidth = 0.01, 
                   boundary = 0.4, 
                   color = "white") +
    labs(x = expression(hat(p)), 
         y = "Count",
         title = "Distribution of 1,000 proportions red") 
```

```{r shovel10-hint, eval = FALSE}
Within labs(), set x to expression(hat(p))
```

## Different shovel sizes
###

Let's create the following plot that displays different standard deviations of red bead proportions for 100 different shovels.

```{r}
prop_red <- function(x, shovel_size, reps){
  tibble(ID = 1:reps) %>% 
    mutate(shovel = map(ID, ~ sample_n(x, size = shovel_size))) %>% 
    mutate(numb_red = map_int(shovel, ~ sum(.$color == "red"))) %>% 
    mutate(numb_beads = map_int(shovel, ~ length(.$color))) %>% 
    mutate(prop_red = numb_red / numb_beads)
}

shovels_100 <- tibble(shovel_size = 1:100) %>%
  mutate(prop_red_results = map(shovel_size,
                                ~ prop_red(x = urn, 
                                           shovel_size = .x, 
                                           reps = 1000))) %>% 
  mutate(prop_red_sd = map_dbl(prop_red_results, 
                               ~ pull(., prop_red) %>% sd()))

shovels_100 %>%
 ggplot(aes(x = shovel_size, y = prop_red_sd)) +
 geom_point() +
 stat_function(aes(x = 1:100, colour = "red"), 
               fun = function(.x) 1/(2 * sqrt(.x)), 
               show.legend = FALSE) +
 labs(x = "Shovel size",
      y = "Standard deviation of the proportion red")
```

### Exercise 1

Let's create a function that calculates the proportion of red beads. We start with hard code. Recall our code for  `virtual_samples` in the previous section. Place the code within { } of `function()`. Name the function `prop_red()`.

```{r map1, exercise = TRUE}
tibble(ID = 1:1000) %>% 
  mutate(shovel = map(ID, ~ sample_n(urn, size = 50))) %>% 
  mutate(numb_red = map_int(shovel, ~ sum(.$color == "red"))) %>% 
  mutate(numb_beads = map_int(shovel, ~ length(.$color))) %>% 
  mutate(prop_red = numb_red / numb_beads)
```

```{r map1-hint, eval = FALSE}
prop_red <- function(){
  
  ...
  
}

```

### Exercise 2

Copy/paste your code from above. Add the parameter `reps` within `function()`. Also replace the value 1000 within `tibble()` with `reps`.

```{r map2, exercise = TRUE}

```

```{r map2-hint-1, eval = FALSE}
prop_red <- function(...){
  tibble(ID = 1:reps) %>% 
    ...
}
```

### Exercise 3

Copy/paste your code from above. Add the parameter `x` within `function()`. Also replace the argument `urn` with `x` within `sample_n()`.

```{r map3, exercise = TRUE}

```

```{r map3-hint, eval = FALSE}
prop_red <- function(reps, ...){
  tibble(ID = 1:reps) %>% 
  mutate(shovel = map(ID, ~ sample_n(x, size = 50))) %>% 
    ...
}
```

### Exercise 4

Copy/paste your code from above. Add the parameter `shovel_size` within `function()`. Also set `size` to `shovel_size` within 

```{r map4, exercise = TRUE}

```

```{r map4-hint-1, eval = FALSE}
prop_red <- function(reps, x, ...){
  tibble(ID = 1:reps) %>% 
  mutate(shovel = map(ID, ~ sample_n(x, size = ...))) %>% 
    ...
}
```

<!-- ### Exercise 5 -->

<!-- Now, let's test our new function `prop_red` by drawing from our urn with a size of 30 and 2 repetitions. -->

<!-- ```{r map5, exercise = TRUE} -->

<!-- ``` -->

<!-- ```{r map5-hint, eval = FALSE} -->
<!-- prop_red(x = urn, size = ..., reps = ...) -->
<!-- ``` -->


### Exercise 5

Great. Let's now create a `tibble()` with one variable `shovel_size`, which takes on the values 1 to 100. 

```{r map5, exercise = TRUE}

```

```{r map5-hint, eval = FALSE}
tibble(shovel_size = ...)
```

### Exercise 6

Pipe your results to `mutate()` to create the variable `prop_red_results`, which is set to the function `map()`.The first argument to `map()` should be `shovel_size`. The second argument should be our function `prop_red()` where `x` is set to `urn`, `shovel_size` set to `.x` and `reps` set to 1000.
 

```{r map6, exercise = TRUE}

```

```{r map6-hint, eval = FALSE}
... %>% 
  mutate(prop_red_results = map(...,
                                ~ prop_red(..., ..., ...)))
```

### Exercise 7

Use `mutate()` once more to create the variable `prop_red_sd` which is set to the function `map_dbl()`. The first argument to `map_dbl()` should be `prop_red_results`. The second argument should be `pull()`. The first argument to `pull()` should be `.`. The second argument should be `prop_red`.

```{r map7, exercise = TRUE}

```

```{r map7-hint, eval = FALSE}
... %>% 
mutate(... = map_dbl(..., 
                      ~ pull(., prop_red) %>% 
```

### Exercise 8

Use `mutate()` once more to create the variable `prop_red_sd` which is set to the function `map_dbl()`. The first argument to `map_dbl()` should be `prop_red_results`. The second argument should be `pull()`. The first argument to `pull()` should be `.`. The second argument should be `prop_red`.

```{r map8, exercise = TRUE}

```

```{r map8-hint, eval = FALSE}

```

### Exercise 9

Let's find the standard deviation of proportions red for all shovel sizes between 1 and 100. Pipe the results of `pull()` to the function `sd()`. **Note**: You are still inside `map_dbl()`.

```{r map9, exercise = TRUE}

```

```{r map9-hint, eval = FALSE}
mutate(prop_red_sd = map_dbl(prop_red_results, 
                               ~ pull(., prop_red) %>% ...))
```

### Exercise 10

Copy/paste your code from above. Assign your code to an object named `shovels_100`. 

```{r map10, exercise = TRUE}

```

```{r map10-hint, eval = FALSE}

```

### Exercise 11

Start a pipe with `shovels_100`. Use `ggplot()` to map `shovel_size` to the x-axis and `prop_red_sd` to the y-axis. Also add the layer `geom_point()`.

```{r map11, exercise = TRUE}

```

```{r map11-hint, eval = FALSE}
... %>% 
  ggplot(aes(x = ..., y = ...)) +
 geom_point() 
```

### Exercise 12

Add the layer `stat_function()`. Map the values 1 to 100 to the x-axis. Also set `color` to "red".

```{r map12, exercise = TRUE}

```

```{r map12-hint, eval = FALSE}
... + 
  stat_function(aes(x = ..., ...))
```

### Exercise 13

Also set `fun` to `function(.x) 1/(2 * sqrt(.x))` within `stat_function()`.Also set `show.legend` to FALSE.

```{r map13, exercise = TRUE}

```

```{r map13-hint, eval = FALSE}
... + 
  stat_function(aes(x = 1:100, colour = "red"), 
               fun = ..., 
               show.legend = ...) 
```

### Exercise 14

Great. Now use `labs()` to label the x-axis "Shovel size" and the y-axis 
"Standard deviation of the proportion red". 

```{r map14, exercise = TRUE}

```

Reminder: This is what your plot should look like.

```{r}
prop_red <- function(x, shovel_size, reps){
  tibble(ID = 1:reps) %>% 
    mutate(shovel = map(ID, ~ sample_n(x, size = shovel_size))) %>% 
    mutate(numb_red = map_int(shovel, ~ sum(.$color == "red"))) %>% 
    mutate(numb_beads = map_int(shovel, ~ length(.$color))) %>% 
    mutate(prop_red = numb_red / numb_beads)
}

shovels_100 <- tibble(shovel_size = 1:100) %>%
  mutate(prop_red_results = map(shovel_size,
                                ~ prop_red(x = urn, 
                                           shovel_size = .x, 
                                           reps = 1000))) %>% 
  mutate(prop_red_sd = map_dbl(prop_red_results, 
                               ~ pull(., prop_red) %>% sd()))

shovels_100 %>%
 ggplot(aes(x = shovel_size, y = prop_red_sd)) +
 geom_point() +
 stat_function(aes(x = 1:100, colour = "red"), 
               fun = function(.x) 1/(2 * sqrt(.x)), 
               show.legend = FALSE) +
 labs(x = "Shovel size",
      y = "Standard deviation of the proportion red")
```

```{r map14-hint, eval = FALSE}

```


## Posterior Distribution
###


Let's create the following plot  <!-- BG: need further explanation here -->

```{r }
set.seed(10)

urn_size <- 1000
paddle_size <- 50
reps <- 100

joint_dist <- 
  tibble(red_in_urn = seq(from = 0, to = urn_size, by = 1)) %>% 
    mutate(p = red_in_urn / urn_size) %>% 
    mutate(red_in_paddle = map(p, ~ rbinom(n = reps, 
                                               size = paddle_size, 
                                               prob = .))) %>%
    unnest(red_in_paddle) 

joint_dist %>% 
  filter(red_in_paddle == 17) %>% 
  ggplot(aes(x = p)) +
    geom_histogram(aes(y = after_stat(count/sum(count))),
                   bins = 50) + 
    labs(title = "Posterior Probability Distribution",
         subtitle = "Proportion of red beads in urn is centered around 0.34",
         x = "Proportion p of Red Beads in Urn",
         y = "Probability") + 
    scale_x_continuous(labels = scales::number_format()) +
    scale_y_continuous(labels = scales::percent_format()) +
    theme_classic()


```


<!-- ## Posterior distribution -->


<!-- ### -->

<!-- <!-- MF: This is where I stopped. Will finish before our next meeting. --> -->


<!-- Finally, let's return to our question from the original section: _how can we predict the number of beads in the urn based on the results of a sample_? In the first section, we discovered that the number of red beads in the urn was probably somewhere between 700 and 1,100, but we could not come up with a better estimate. In this section, we will both improve our estimate and better simulate real-world sampling by estimating the number of beads in the urn from the result of a single sample. -->

<!-- Suppose that in a single 45-bead sample from our urn, 28 of the 45 beads are red. Let's use this information to predict the number of beads in the urn. -->

<!-- ### Exercise 1  -->

<!-- We're going to start by analyzing a single model: 800 of the 1,500 beads being red. Using `tibble()`, create a tibble with a single column, `color`. `color` should be equal to the combination (`c()`) of "red" 800 times and "white" 700 times.  -->

<!-- ```{r posterior1, exercise = TRUE} -->

<!-- ``` -->


<!-- ```{r posterior1-hint-2, eval = FALSE} -->
<!-- tibble(color = c(rep(...), rep(...))) -->
<!-- ``` -->

<!-- ### Exercise 2 -->

<!-- Let's now take some samples from our table using `rep_sample_n()`. The first parameter of your `rep_sample_n()` statement should be equal to the tibble that you made in the previous exercise (remember to copy and paste!). Also set the `size` to 45, the `reps` to 1,000 (any reasonably large number works here), and `replace` to "TRUE." -->

<!-- ```{r posterior2, exercise = TRUE} -->

<!-- ``` -->

<!-- ```{r posterior2-hint, eval = FALSE} -->
<!-- tibble(...) %>%  -->
<!--   rep_sample_n(size = ..., reps = ..., replace = ...) -->
<!-- ``` -->

<!-- ### Exercise 3 -->

<!-- Pipe what you have into `group_by()` to group the tibble by the `replicate` variable. -->

<!-- ```{r posterior3, exercise = TRUE} -->

<!-- ``` -->

<!-- ### Exercise 4 -->

<!-- Use `summarize()`to create the variable `red_in_sample`, which should be equal to the `sum()` of the number of rows in each group with `color` equal to "red." -->

<!-- ```{r posterior4, exercise = TRUE} -->

<!-- ``` -->

<!-- ```{r posterior4-hint} -->
<!-- sample_given_urn <- function(...) { -->
<!--   tibble(color = c(rep("red", ...), rep("white", ...))) %>%  -->
<!--     rep_sample_n(size = 45, reps = 1000, replace = TRUE) %>% -->
<!--     group_by(replicate) %>% -->
<!--     summarize(red_in_sample = sum(color == ...), .groups = ...) -->
<!-- } -->
<!-- ``` -->

<!-- ### Exercise 5 -->

<!-- We now have code that makes 1,000 random samples from our 800-red-bead urn, but we want to generalize it to urns with other amounts of red beads. To do so, wrap the code above in a function named `sample_given_urn`.  that has one parameter, `red_in_urn`. Replace the 800 in the first `rep()` statement with `red_in_urn` and the 700 in the second `rep()` statement with `red_in_urn` subtracted from 1,500.  -->

<!-- ```{r posterior5, exercise = TRUE} -->

<!-- ``` -->

<!-- ```{r posterior5-hint, eval = FALSE} -->
<!-- sample_given_urn <- function(...) { -->
<!--   tibble(color = c(rep("red", ...), rep("white", ...))) %>%  -->
<!--     rep_sample_n(size = 45, reps = 1000, replace = TRUE) %>% -->
<!--     group_by(replicate) %>% -->
<!--     summarize(red_in_sample = sum(color == "red"), .groups = "drop") -->
<!-- } -->
<!-- ``` -->

<!-- ### Exercise 6 -->

<!-- To get a sense of how our function works, call `sample_given_urn()` below the function definition to calculate 1,000 random samples from an urn with 650 red beads. -->

<!-- ```{r posterior6, exercise = TRUE, exercise.lines = 7} -->
<!-- sample_given_urn <- function(red_in_urn){ -->
<!--   tibble(color = c(rep("red", red_in_urn),  -->
<!--                    rep("white", 1500 - red_in_urn))) %>%  -->
<!--     rep_sample_n(size = 45, reps = 1000, replace = TRUE) %>% -->
<!--     group_by(replicate) %>% -->
<!--     summarize(red_in_sample = sum(color == "red"), .groups = "drop") -->
<!-- } -->
<!-- ``` -->

<!-- ### Exercise 7 -->

<!-- Now, below the function definition, call `tibble()` to create a new tibble with one column, `nums`, equal to the vector containing every multiple of 25 `from` 650 `to` 1,150. -->


<!-- ```{r posterior7, exercise = TRUE, exercise.lines = 7} -->
<!-- sample_given_urn <- function(red_in_urn){ -->
<!--   tibble(color = c(rep("red", red_in_urn),  -->
<!--                    rep("white", 1500 - red_in_urn))) %>%  -->
<!--     rep_sample_n(size = 45, reps = 1000, replace = TRUE) %>% -->
<!--     group_by(replicate) %>% -->
<!--     summarize(red_in_sample = sum(color == "red"), .groups = "drop") -->
<!-- } -->
<!-- ``` -->

<!-- ```{r posterior7-hint, eval = FALSE} -->
<!-- tibble(nums = seq(...)) -->
<!-- ``` -->

<!-- ### Exercise 8 -->

<!-- Pipe your tibble into a `mutate()` statement to create the new variable `sample_results`. `sample_results` should be equal to the result of a `map()` statement whose first parameter is `nums` and whose second parameter is `sample_given_urn(nums)`. Don't worry about the error for the time being. -->

<!-- ```{r posterior8, exercise = TRUE} -->

<!-- ``` -->

<!-- ### Exercise 9 -->

<!-- To fix the error from our `map()` statement, remember the two rules of using `map()`: replace `nums` with `.x` in `sample_given_urn()`, and precede `sample_given_urn()` with the `~` symbol. -->

<!-- ```{r posterior9, exercise = TRUE} -->

<!-- ``` -->

<!-- ### Exercise 10 -->

<!-- Nice job! Unfortunately, we are now left with a list column. Just as we did in the previous sections, pipe the tibble into `unnest()` to convert the list column into a standard tibble. Set the `cols` argument of `unnest()` equal to `sample_results`. -->

<!-- ```{r posterior10, exercise = TRUE} -->

<!-- ``` -->

<!-- ### Exercise 11 -->

<!-- Continuing your pipe, group the tibble by `nums`. Then use `summarize()` to create the variable `num_samples`, which should be equal to the `sum()` of the number of rows in each group with `red_in_sample` equal to 28. -->

<!-- ```{r posterior11, exercise = TRUE, exercise.lines = 11} -->
<!-- sample_given_urn <- function(red_in_urn){ -->
<!--   tibble(color = c(rep("red", red_in_urn),  -->
<!--                    rep("white", 1500 - red_in_urn))) %>%  -->
<!--     rep_sample_n(size = 45, reps = 1000, replace = TRUE) %>% -->
<!--     group_by(replicate) %>% -->
<!--     summarize(red_in_sample = sum(color == "red"), .groups = "drop") -->
<!-- } -->

<!-- tibble(nums = seq(from = 650, to = 1150, by = 25)) %>% -->
<!--   mutate(sample_results = map(nums, ~ sample_given_urn(.x))) %>% -->
<!--   unnest(cols = sample_results) -->
<!-- ``` -->



<!-- ### Exercise 12 -->

<!-- Pipe the tibble into `ggplot()` to create a bar graph that maps `nums` to the x-axis and `num_samples` to the y-axis. -->

<!-- ```{r posterior13, exercise = TRUE} -->

<!-- ``` -->

<!-- ```{r posterior13-hint, eval = FALSE} -->
<!-- Remember to use geom_col(). -->
<!-- ``` -->

<!-- ### Exercise 13 -->

<!-- Normalize the distribution by changing the y-axis mapping from `num_samples` to `num_samples` divided by the `sum()` of all `num_samples`. In addition, because the probabilities are so small, multiply `num_samples` by 100 before you divide by the `sum()` so we get percents instead of decimal probabilities. -->

<!-- ```{r posterior14, exercise = TRUE} -->

<!-- ``` -->

<!-- ```{r posterior14-hint, eval = FALSE} -->
<!-- ggplot(mapping = aes(x = nums, y = ... * ... / sum(...))) -->
<!-- ``` -->


<!-- ### Exercise 14 -->

<!-- Fantastic job! From this graph, we can see that the most likely outcome for the number of red beads in the urn is between 900 and 975. Notably, though, there is a *ton* of variance in the outcome: the probability that the number of red beads is between 900 and 950 is only about 30%. The major lesson here is that a single small sample is not very predictive---you need either many samples or a very large sample size to be confident in your estimate. -->

<!-- To finish off this tutorial, you probably want to know how many red beads are actually in the urn. Below the `ggplot()`, pipe `urn` into a `count()` statement that takes `color` as its argument. -->

<!-- ```{r posterior17, exercise = TRUE, exercise.lines = 20} -->
<!-- sample_given_urn <- function(red_in_urn){ -->
<!--   tibble(color = c(rep("red", red_in_urn),  -->
<!--                    rep("white", 1500 - red_in_urn))) %>%  -->
<!--     rep_sample_n(size = 45, reps = 1000, replace = TRUE) %>% -->
<!--     group_by(replicate) %>% -->
<!--     summarize(red_in_sample = sum(color == "red"), .groups = "drop") -->
<!-- } -->

<!-- tibble(nums = seq(from = 650, to = 1150, by = 25)) %>% -->
<!--   mutate(sample_results = map(nums, ~ sample_given_urn(.x))) %>% -->
<!--   unnest(cols = sample_results) %>% -->
<!--   group_by(nums) %>% -->
<!--   summarize(num_samples = sum(red_in_sample == 28), .groups = "drop") %>% -->
<!--   ggplot(mapping = aes(x = nums, y = 100 * num_samples / sum(num_samples))) + -->
<!--     geom_col() + -->
<!--     scale_x_continuous(breaks = seq(from = 650, to = 1150, by = 50)) + -->
<!--     labs(title = "Posterior Probability Distribution of Red Beads in Urn", -->
<!--          subtitle = "Based on a 45-bead sample with 28 red beads", -->
<!--          x = "Number of red beads", -->
<!--          y = "Probability (percent)") -->
<!-- ``` -->

<!-- ```{r posterior17-hint, eval = FALSE} -->
<!-- urn %>% -->
<!--   count(...) -->
<!-- ``` -->


## Submit

```{r context = "setup"}
submission_ui
```

```{r context = "server"}
submission_server()
```

