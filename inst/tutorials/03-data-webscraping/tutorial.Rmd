---
title: "Data Webscraping"
tutorial:
  id: "data-webscraping"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: "Chapter 3: Data -- Webscraping"
---

```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(rvest)
library(png)
library(grid)

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 600, 
        tutorial.storage = "local") 
```


## Information
###

```{r information}
quiz(caption = "",
  question_text(
    "Name:",
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL),
  question_text(
    "Email:",
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL))
```

## HTML

```{r setup-html-section, echo=FALSE}
raw_html1 <- "<html>Hello World</html>"
raw_html2 <- "<html>
<table>
  <tr>
    <td>
      Hello World
    </td>
  </tr>
</table>
</html>"
```

HTML, or "HyperText Markup Language" is a markup language that is used to display webpages on browsers. You might have seen html files as a result of knitting Rmd files.

###

### Exercise 1

In this tutorial, you will use the `rvest` package to read the HTML of websites and extract data. First, import the `rvest` package.

You may need to install the `rvest` package in RStudio's console if the code box below outputs an error. If so, use `install.packages("rvest")` in console.

```{r html1, exercise=TRUE}

```

``` {r html1-hint-1, eval=FALSE}
library(...)
```

###

`rvest` is part of the `tidyverse`, a collection of packages, but it is not part of the core `tidyverse` package so you have to load it in separately. https://rvest.tidyverse.org/ is its official website.

### Exercise 2

HTML uses many nested layers of different tags to organize structure.

For example:

An html file like this:
```{.html}
<html>
Hello World
</html>
```

creates the following:
<br>

<html style="background-color:gray">
Hello World
</html>

<br>

Tags are represented like `<...></...>`, similar to parentheses. You will see different kinds of tags and what they can do. This example uses the html tag `<html>`, which is the main tag that includes the entire webpage.

###

You will be parsing the following html structure:
```{.html}
<html>
<p>
Hello World
</p>
</html>
```

Assign the provided html code into the variable `raw_html1`.

```{r html2, exercise=TRUE}
"<html><p>Hello World</p></html>"

```

```{r html2-hint-1, eval=FALSE}
raw_html1 <- "<html>Hello World</html>"

```

###

You can now use the `raw_html1` variable

### Exercise 3

Using the function `minimal_html()`, load in `raw_html1`. This function takes the raw html text and creates an object to easily access information.

Later, you will read html directly from websites.


```{r html3, exercise=TRUE}

```

```{r html3-hint-1, eval=FALSE}
minimal_html(...)
```

```{r html3-hint-2, eval=FALSE}
minimal_html(raw_html1)
```


###

`rvest` reads html data and constructs a nested list-like object to represent the usual nested structure of html.

The output is similar to the output of a list.

### Exercise 4

Copy/paste your code from above and extend it using ` %>% `. Use the function `html_element()` to select the first `<p>` tag inside the structure.

`html_element()` takes a string that shows the type of a tag.
For example, `<p>` can be found with `"p"`.

```{r html4, exercise=TRUE}

```

```{r html4-hint-1, eval=FALSE}
minimal_html(...) %>% html_element(...)
```

```{r html4-hint-2, eval=FALSE}
minimal_html(...) %>% html_element("p")
```

###

You can see it returned an `{html_node}` object that is the tag `<p>`

### Exercise 5

Copy/paste your pipe from above and extend it. Use the function `html_text2()`, which prints the text inside a tag.

```{r html5, exercise=TRUE}

```

```{r html5-hint-1, eval=FALSE}
minimal_html(...) %>% html_element("p") %>% html_text2()
```

###

The output should be "Hello World". Now you can access the inside of a tag.

### Exercise 6

Usually, html tag structures are nested like the following:

```{.html}
<html>
<table>
  <tr>
    <td>
      Hello World
    </td>
  </tr>
</table>
</html>
```

###

You will parse the above html

Assign the provided html to a variable named `raw_html2`

```{r html6, exercise=TRUE}
"<html>
<table>
  <tr>
    <td>
      Hello World
    </td>
  </tr>
</table>
</html>"
```

```{r html6-hint-1, eval=FALSE}
raw_html2 <- "..."
```

###

Now you have access to `raw_html2`

### Exercise 7

Start a pipe using the function `minimal_html()`.

```{r html7, exercise=TRUE}

```

```{r html7-hint-1, eval=FALSE}
minimal_html(...)
```

###

Now you can search for elements inside the html.

### Exercise 8

Copy/paste your code from above and extend it with ` %>% `. Using `html_element()`, find the first `<table>` tag.

Remember that `html_element()` takes the type of tag you want to search for as an argument.

So to search for `<table>`, you can use `"table"` as an argument.

```{r html8, exercise=TRUE}

```

```{r html8-hint-1, eval=FALSE}
minimal_html(...) %>% html_element(...)
```

```{r html8-hint-2, eval=FALSE}
minimal_html(...) %>% html_element("table")
```

###

The output like last time returns an `{html_node}` object that has the `<table>` tag.

The lines after the `<table>` show the elements inside `<table>`.

### Exercise 9

Copy/paste your pipe from above and extend it. Use the function `html_element()` again to search for `<td>` tag inside the `<table>` tag.

```{r html9, exercise=TRUE}

```

```{r html9-hint-1, eval=FALSE}
minimal_html(...) %>% html_element(...) %>% html_element(...)
```

```{r html9-hint-2, eval=FALSE}
minimal_html(...) %>% html_element("table") %>% html_element("td")
```

###

By extending your pipe from the resulting `<table>` tag, you are limiting your searches and functions to only inside the `<table>` tag. You can see from the results that you have selected the `<td>` tag that is inside the `<table>` tag.

### Exercise 10

Copy/paste your pipe from above and extend it. Use the `html_text2()` function to view the text inside the `<td>` tag.

```{r html10, exercise=TRUE}

```

```{r html10-hint-1, eval=FALSE}
minimal_html(...) %>% html_element(...) %>% html_element(...) %>% html_text2()
```

###

Now you can navigate deep into the nested structure of html.

### Exercises 11-Last

using `html_elements()` and indexing





###

Well done, this is the basic structure of HTML. It is really just tags inside tags inside tags, and now you can navigate through this structure with indexing.

## CSS Selectors

CSS, or Cascading Style Sheets is a language that defines the style of webpages (colors, boxes, spacing, etc).

```{.css, eval=FALSE, echo=TRUE}
p .class_name {
color: red
}
```

CSS uses different attributes of tags to find which tags should be formatted in which way.

You can utilize this system to find the tags that you want.

###
### Exercise 1

A tag's attributes are shown like such:
``` {.html}

<a href="link/to/somewhere" id="abcd1234" class="hello hi">
link to somewhere
</a>

```

In the above example, the `<a>` anchor tag has 3 different attributes:
`href` which contains the destination link
`id` which contains a unique id
`class` which contains the classes that this tag is a part of.

###

The code for the anchor tag is provided below.

Start a pipe with `minimal_html()` and extend it with the function `html_element()`. You have been using `html_element()` to find tags with the type of tag (a, p, table, etc), but you can also select an element with CSS attributes.

Select the anchor tag using its `id` attribute, `"abcd1234"`, and then print the text with `html_text2()`.

You specify that you are filtering by `id` in `html_element()` by using `"#id_name"`.

```{r css1, exercise=TRUE}
anchor <- '<a href="link/to/somewhere" id="abcd1234" class="hello hi">link to somewhere</a>'

```

```{r css1-hint-1, eval=FALSE}
... %>% html_element("#...") %>% html_text2()
```

```{r css1-hint-2, eval=FALSE}
... %>% html_element("#abcd1234") %>% html_text2()
```

###

Since `id` is a unique identifier, every page should only have one tag that uses that `id`, which is helpful to select specific elements.

### Exercise 2

Copy/paste your pipe from above. You will edit the inside of the `html_element()` function.

Select the `<a>` tag using its class attribute, `"hello"`, and then print the text with `html_text2()`. You specify that you are filtering by `class` in `html_element()` by using `".class_name"`.

Run the equivalent for `<a>` tag's other class attribute, `"hi"`.

```{r css2, exercise=TRUE}

```

```{r css2-hint-1, eval=FALSE}
... %>% html_element(".class_name") %>% html_text2()
```

```{r css2-hint-2, eval=FALSE}
... %>% html_element(".hello") %>% html_text2()

# or

... %>% html_element(".hi") %>% html_text2()
```

###

Classes are not unique to one tag, so usually there are multiple tags with the same class.

Therefore, if you want to find an element by class, using `html_elements()` is better because it returns all results.

### Exercise 3

You can also filter by id, class, and type of tag at the same time by chaining them together.

Consider the following lines:
```{r, eval=FALSE, echo=TRUE}


minimal_html(some_html) %>% html_element("p#id_name")

minimal_html(some_html) %>% html_element("p.class_name")

minimal_html(some_html) %>% html_element("p#id_name.class_name")


```

The codes achieve the following effects:

Line 1: selects the first `<p>` tag with `"id_name"` as its `id`

Line 2: selects the first `<p>` tag with `"class_name"` as one of its `class`

Line 3: selects the first `<p>` tag with both `"id_name"` as its `id` AND `"class_name"` as one of its `class`

###

Copy/paste your pipe from above. You will edit the inside of `html_element()`.

Select the anchor tag by specifying its tag type and `id`. Do the same except with tag type and one of its `class`. If you want, also try with both `id` and a `class`.

Afterwards, use `html_text2()` to print out the text.

```{r css3, exercise=TRUE}

```

```{r css3-hint-1, eval=FALSE}
... %>% html_element("a#id_name") %>% html_text2()

... %>% html_element("a.class_name") %>% html_text2()

... %>% html_element("a#id_name.class_name") %>% html_text2()
```

###

The more specific your query is, the more precise it is with selecting your desired element.

### Exercise 4

Up until now, you have been extracting only the inner text of tags. However, there are times when the data you want is in the tag's attribute.

Consider again the following tag:
``` {.html}

<a href="link/to/somewhere" id="abcd1234" class="hello hi">
link to somewhere
</a>

```

The `href` attribute can be helpful if you are collecting urls.

###

Copy/paste your pipe from above and remove `html_text2()` from the end.

You will use the function `html_attr()` instead. This function takes as an argument the name of the attribute that you want to select in quotes.

```{r css4, exercise=TRUE}

```

```{r css4-hint-1, eval=FALSE}
... %>% ... %>% html_attr("...")
```

```{r css4-hint-2, eval=FALSE}
... %>% ... %>% html_attr("href")
```

###

Now you can also extract data from the attributes of tags. You can try `"class"` or `"id"` since both are also attributes.

### Exercise 5

Consider again `raw_html`:
```{.html}
<html>
  <head>
    <title>
      Hello World!
    </title>
  </head>
  <body>
    <p id="p1">
    This is a paragraph.
    </p>
  <br>
    <a id="someKindOfLink" href="https://www.rdocumentation.org/packages/rvest/versions/0.3.6">
    This is an anchor, or hyperlink.
    </a>
    <br>Below is a table:
    <table id="tableOfStuff">
      <tr>
        <td class="coolData">row1data1</td>
        <td class="coolData">row1data2</td>
        <td class="uncoolData">row1data3</td>
        <td>row1data4</td>
      </tr>
      <tr>
        <td><p>row2data1</p></td>
        <td class="uncoolData">row2data2</td>
        <td>row2data3</td>
        <td>row2data4</td>
      </tr>
    </table>
  </body>
</html>
```

To practice, let's say you want to find the `href` of the `<a>` tag using its `id` attribute

###

`raw_html` is provided below.

Start a new pipe using `minimal_html()`. Print out the `href` of the `<a>` tag using the functions we learned.

```{r css5, exercise=TRUE}
raw_html <- '<html><head><title>Hello World!</title></head><body><p id="p1">This is a paragraph.</p><br><a id="someKindOfLink" href="https://www.rdocumentation.org/packages/rvest/versions/0.3.6">This is an anchor, or hyperlink.</a><br>Below is a table:<table><tr><td class="coolData">row1data1</td><td class="coolData">row1data2</td><td class="uncoolData">row1data3</td><td>row1data4</td></tr><tr><td><p>row2data1</p></td><td class="uncoolData">row2data2</td><td>row2data3</td><td>row2data4</td></tr></table></body></html>'

```

```{r css5-hint-1, eval=FALSE}
... %>% html_element("...") %>% html_attr("...")
```

###

Though there is only one `<a>` tag in this case, it is best to specify with `class` and/or `id` attributes which tag you are selecting because the html of larger websites are very complicated and layered.

### Exercise 6










<!-- This should be a 60 to 90 minutes worth of exercises devoted to webscraping, with a big focus on the rvest package. Also need to teach some CSS and Selector Gadget. Resources: -->

<!-- If students would just read this paper closely and try out the associated commands -->

<!-- https://github.com/mdogucu/web-scrape -->

<!-- then a tutorial would not be necessary. But they won't! And, even if most of them would, teachers still need a way of knowing that they did. Hence, tutorials. Can we write something that, in essence, forces students to type out everything in that article and understand what it is doing? That is the goal! -->

<!-- https://github.com/rstudio-education/dsbox/tree/master/inst/tutorials/05-moneyinpolitics -->
<!-- https://minecr.shinyapps.io/dsbox-05-moneyinpolitics/ -->


<!-- There is no need to reinvest the wheel. All this code is CC0, so we can just copy/paste it, including the links to images which appear on the web. But how do we ensure that students do things? What questions do we ask? -->

<!-- https://rvest.tidyverse.org/ -->
<!-- https://github.com/tidyverse/rvest/blob/master/vignettes/rvest.Rmd -->
<!-- https://github.com/tidyverse/rvest/blob/master/vignettes/articles/selectorgadget.Rmd -->

<!-- Maybe the tutorial starts the same way as this chapter, with a concrete example of what we are trying to do. Note that we just used this prose in our chapter. Again, it is all CC0. -->

<!-- https://rafalab.github.io/dsbook/web-scraping.html -->

<!-- Reminders: -->

<!-- 1) You can put a raw html (or any other kind of file) in inst/www and then be certain is available on Github. You may want to submit a PR which does that, and then, when I accept it, you can write code which accesses it directly. Example url: -->

<!-- https://raw.githubusercontent.com/PPBDS/primer.tutorials/master/inst/www/delim_1.txt -->

<!-- 2) This tutorial is just about raw webscraping, not about working with APIs or JSON. Other tutorials handle that. -->

<!-- 3) Key structure is to, first, begin with sections which highlights the key issues and key commands. Then, have 5 or so concrete examples, each of which works with an html file which we have a permanent copy of. (But how do we show how that file looks in a browser? I am confused about that.) Nothing wrong with all the examples being from Wikipedia and referencing specific versions, even if they are old. -->

<!-- 4) Plan is to write this tutorial and then, afterwards, update the Chapter to be consistent with it. -->

<!-- 5) Use html_text2(). Background: https://www.tidyverse.org/blog/2021/03/rvest-1-0-0/ -->


 

## Submit

```{r context = "setup"}
submission_ui
```

```{r context = "server"}
submission_server()
```
