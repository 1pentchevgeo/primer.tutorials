---
title: Distributions
tutorial:
  id: distributions
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: Practice working with and understanding distributions.
---

```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(primer.data)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
```

```{r copy-code-chunk, child = "../../child_documents/copy_button.Rmd"}
```

```{r info-section, child = "../../child_documents/info_section.Rmd"}
```

<!-- Add Introduction and Summary. See the new Template for discussion. -->

<!-- Re-read first page or two of Instructions. -->

<!-- Read Chapter 7 closely! Think about what it means. Your job in Chapter 5, and in this tutorial, is to ensure that students, when they get to chapter 7, understand it thoughly. In particular, questions 3 and 4 are solved by create, in each row, a draw from a joint distribution, and then manipulating that draw each time. And then (magically!), the results of that manipulation are also a posterior! Would a guided tour of rvar variable types in this chapter help to set the stage for that? Should we use rvar types in later chapters? -->

<!-- Define a distribution. A mathematical object with two components: a list of possible outcomes and a corresponding frequency for each outcome. In a normalized distribution, the sum of the frequencies is 1.  -->
<!-- Note that this is a sloppy definition because it does not apply to continuous distributions. Need to mention this and then wave our hands. -->

<!-- Define a random variable is "a variable whose values depend on outcomes of a random phenomenon." Example: Result of one coin flip. -->

<!-- Consider the posterior package: https://mc-stan.org/posterior/index.html. Need a new random variable object type: https://mc-stan.org/posterior/articles/rvar.html -->


<!-- Add to chapter 5 a tutorial whose sole focus is distributions. First part of this is going slowly through the process by which counts can be turned into percentages. Do this in, at least, five ways. First, with geom_bar() which (I think) does the counting for us. Second, with geom_col(), in which we need to create the counts ourselves. Third with geom_histogram(). Fourth then maybe create a histogram by hand, using cut() and then counting up the elements in each range. -->

<!-- Put the Appendix-distribution questions somewhere here. -->

<!-- Maybe have a section explaining how the distribution of the error term is what motivates the selection of the appropriate family argument in stan_glm(). -->

<!-- Need a section titled "Random variables". Purpose is to connect the concept/use of random variables to the concept/use of a distribution.  -->

## Introduction

###

Now first recall that a distribution is a mathematical object with two components: a list of possible outcomes and a corresponding frequency for each outcome or simply *the collection of data on a single variable*. 

Normalized distribution is essentially turning the frequency into percent, and which sum up equal to 1.


This tutorial has three missions:
1. Review key concepts and commands which frequently use in creating distributions.
2. Identify how statistics alter with different distributions.
3. 

Random variable :
Ways to map the outcomes of random processes to quantifiable numbers.




## Monte Hall
###

<!-- https://en.wikipedia.org/wiki/Monty_Hall_problem -->

<!-- Make a tibble. First time with just 5 rows so that you can see what is happening each time. Only at the end, do you make the tibble be 4,000 rows and then use summarize to calculate your answer or, maybe better, show a graph.  -->

<!-- First column is the random location of the goat. "1", "2" or "3". Second column is your random guess. Third column is which door Monte opens. (He can't open your door, nor can he open the door with the goat.) Then, two more columns: one with what happens if you switch (possible values "Goat" or "Car"), one with what happens if you don't switch. (Same possible values.)  -->


                          

```{r, echo = FALSE}
monte_p <- expand_grid(sim = 1:10000, door = 1:3) %>%
  
    # my_vec <- c(TRUE, rep(FALSE, n_doors - 1))
  
    # Very handy to do stuff for each simulation separately. Don't forget to
    # ungroup() when you want to act on on the whole tibble at once.
  
    group_by(sim) %>%
  
    # sample() returns the whole vector, which is what we want since, in any
    # individual sim, the car is behind one of the three doors and exactly one
    # door is guessed initially.
  
    mutate(car = sample(c(FALSE, FALSE, TRUE))) %>%  
    mutate(guess = sample(c(FALSE, FALSE, TRUE))) %>% 

    
    # Convenient to always put the guessed door in the first row of each sim
    # group. Then have the actual location of the car as low in the sim group as
    # you can. This sort only matters in cases where the you did not guess the
    # car location. In those cases, you are always placing the car location as
    # the lowest row within the sim group.
  
    # sample_frac() to rearrnage the rows randomly, maybe.
  
    arrange(sim, -guess, car) %>% 
    mutate(row_n = row_number(sim)) %>%
    mutate(switch_to = row_n == 3) %>% 
    mutate(stay_win = if_else(guess & car, TRUE, FALSE)) %>% 
    mutate(switch_win = if_else(switch_to & car, TRUE, FALSE))  %>%  
  
    # Now, within each sim, we need to see if switch or stay won. They won if
    # there is at least one TRUE value for the stay_win (or switch_win) variable
    # calculated in the previous steps. So, we just need a max.

    summarise(stayWin = max(stay_win),
              switchWin = max(switch_win)) %>% 
    
    # For each sim, we now now if staying was a winning strategy and/or if
    # switching was a winning strategy. (With more than three doors, it will
    # often be the case that neither staying nor switching wins, like when you
    # switch from one empty door to the other.)
  
    ungroup() %>% 
  
   summarise(stayWin, switchWin) %>%
      
    
    pivot_longer(cols = everything(), 
               names_to = "decision", 
               values_to = "result") %>%
  ggplot(aes(x = result, fill = decision)) +
    geom_bar(aes(y = after_stat(count/sum(count))), position = 'dodge')+
  scale_x_continuous(breaks = c(0 , 1),
                   labels = c("Lose", "Win"))+
  scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
  scale_fill_discrete(labels = c("Stay", "Switch")) +
  labs(title = "Joint distribution of Monty Hall Problem",
       subtitle = "One will have better change of winning if switching door",
       x = "Results",
       y = "Probability",
       fill = "Decision")
  


  # Use to calculate the exact percentage.
# summarize(stay_odds = mean(stayWin),
    #           switch_odds = mean(switchWin)) %>%    
monte_p    
```

                          

### Exercise 1

Use `expand_grid()`,create the first variable `sim` and set it equal to the consecutive integer from 1 to 10, create the second variable door, and set it equal to 1,2 and 3.
```{r monte-hall-1, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-1-hint, eval = FALSE}

expand_grid(sim = 1:10000, door = 1:3)
```

###

The reason we create this `sim` value is because later we can switch around the size value, making observation when we increase the simulation size. 

### Exercise 2

Use `group_by()` include the variable `sim`.
```{r monte-hall-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-2-hint, eval = FALSE}
 group_by(sim)
```

###
This is an important step as we are dealing with this group several times later.

### Exercise 3

Use `mutate()` create a new variable `car` and set it equal to `sample()` which includes 3 values `FALSE`,`FALSE`,`TRUE`wrap around by `c()`
```{r monte-hall-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-3-hint, eval = FALSE}

mutate(car = sample(c(FALSE, FALSE, TRUE)))
```

###
Note that if you just run the `sample()` part several time, it will create the same three value but in different order. Also note that we have the `sim` repeat 3 times for every `car` value.

### Exercise 4


Use `mutate()` create a new variable `guess` and set it equal to `sample()` which includes 3 values `FALSE`,`FALSE`,`TRUE`wrap around by `c()`
```{r monte-hall-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-4-hint, eval = FALSE}
mutate(guess = sample(c(FALSE, FALSE, TRUE))) %>% 
```

###

The reason we don't have an single `sim` correspond to an list in `car` is because we include the `group_by()` statement before.

### Exercise 5

Use `arrange()` which has three arguments, the first is `sim`, the second is `-guess`, and third is `car`.

```{r monte-hall-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-5-hint, eval = FALSE}
 arrange(sim, -guess, car)
```

###
This is one of the core step we first arrange `sim` by ascending order, putting the 1s and 2s together and at the top, then we put `guess` in descending order, means a `TRUE` value is always on the first row of every `sim`, then we put car in ascending order, means that we have the TRUE for car at the bottom of each `sim` if possible.

### Exercise 6

Use `mutate()` create a variable `now_n` and set it equal to `row_number(sim)`.
```{r monte-hall-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-6-hint, eval = FALSE}
mutate(row_n = row_number(sim)) %>%
```

###
`row_number(sim)` creates the order within each `sim`, for the three rows of each `sim`, generate the rank from top to bottom.

### Exercise 7

Use `mutate()` create a new variable `switch_to` and set it equal to the logical if `row_n` is equal to `3`.
```{r monte-hall-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-7-hint, eval = FALSE}
mutate(switch_to = row_n == 3)
```

###
What this step does is if the contestant decided to switch door, he/she/they is going to switch the third door in order for each `sim`. This is true because for the first scenario when the contestant guess is not the same as the car door, we arrange the `guess` door to be the first row for each `sim`, and `car` door for the last row for each `sim`. For this case Monty can only choose the second door in order for each `sim`, when contestant is going to switch they only can switch to the third door. For second scenario when contestant choose the door with the car, then the other two doors is completely identical, it doesn't really matter which door the contestant choose.

### Exercise 8

Use `mutate()` create a variable `stay_win`, and set it equal to `if_else()` which has three arguments, the first being `guess & car`, the second being `TRUE`, and the third is `FALSE`.
```{r monte-hall-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-8-hint, eval = FALSE}
mutate(stay_win = if_else(guess & car, TRUE, FALSE))
```

###
The `if_else()` statement here means if `guess` and `car` are both `TRUE`, then return `TRUE`, if at least one of `guess` or `car` then returns `FALSE`.

### Exercise 9

Use `mutate()` create a variable `switch_win`, and set it equal to `if_else()` which has three arguments, the first being `switch_to & car`, the second being `TRUE`, and the third is `FALSE`.
```{r monte-hall-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-9-hint, eval = FALSE}
mutate(switch_win = if_else(switch_to & car, TRUE, FALSE))
```

###
The `if_else()` statement here means if `switch_to` and `car` are both `TRUE`, then return `TRUE`, if at least one of `switch_to` or `car` then returns `FALSE`.

### Exercise 10

Use `summarise()`include two arguments, the first argument create a new variable `stayWin` and set it equal to `max()` of `stay_win`, the second argument create a new variable `switchWin` and set it equal to `max()` of `switch_win`.
```{r monte-hall-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-10-hint, eval = FALSE}
summarise(stayWin = max(stay_win),
              switchWin = max(switch_win))
```

###
Now, within each `sim`, we need to see if switch or stay won. They won if there is at least one TRUE value for the` stay_win` (or `switch_win`) variable calculated in the previous steps. So, we just need a max.

### Exercise 11

Now let's `ungroup()`
```{r monte-hall-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-11-hint, eval = FALSE}
ungroup() 
```


### Exercise 12

Use `summarise()` one last time, include arguments, `stayWin` and `switchWin`.
```{r monte-hall-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-12-hint, eval = FALSE}
summarise(stayWin, switchWin)
```

###

Get rid of `sim`, only keeping the two columns we need to graph.

### Exercise 13

Add the function `pivot_longer()`. Set `cols` to `everything()`, `names_to` to "decision", and `values_to` to  "result".
```{r monte-hall-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-13-hint, eval = FALSE}
pivot_longer(cols = everything(), 
               names_to = "decision", 
               values_to = "result")
```

###

This step combine the two columns while giving names for it to fill later.

### Exercise 14

Continue your pipe with `ggplot()` to map `x` to `result` and `fill` to `decision` Add the layer `geom_bar()`. Within `geom_bar()`, . Inside `aes()`,set `y` equal to  `after_stat()` with the argument `count/sum(count)` to put percents on the y-axis, then outside of `aes()`, add another argument set `position` equal to 'dodge'.
```{r monte-hall-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-14-hint, eval = FALSE}
ggplot(aes(x = result, fill = decision)) +
    geom_bar(aes(y = after_stat(count/sum(count))), position = 'dodge')
```


### Exercise 15

Now use `scale_x_continuous()` so the x-axis has `breaks` at 0 and 1. Set the `labels` for the breaks as "Lose" and "Win", respectively. 
```{r monte-hall-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-15-hint, eval = FALSE}
scale_x_continuous(breaks = c(0 , 1),
                   labels = c("Lose", "Win"))
```


### Exercise 16

Now use `scale_y_continuous()` to put the y-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.
```{r monte-hall-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-16-hint, eval = FALSE}
... + 
  scale_y_continuous(labels = scales::percent_format(...))
```

### Exercise 17

Use `scale_fill_discrete()` , set `labels` to as "Stay" and "Switch".
```{r monte-hall-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-17-hint, eval = FALSE}
scale_fill_discrete(labels = c("Stay", "Switch"))
```

### Exercise 18

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels.
```{r monte-hall-18, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-18-hint, eval = FALSE}
... +
  labs(title = "...")

```

Reminder: Your plot should look like the the one below.

```{r}
monte_p
```














<!-- ## Two daughter puzzle -->
<!-- ### -->

<!-- Consider all the families in town with two children. All children are either boys or girls, each of which occur randomly with 50/50 odds. Pick a family with at least one girl at random. What are the chances that the other child is a girl? -->


<!-- ## Four children problem -->

<!-- All children are either boys or girls, each of which occur randomly with 50/50 odds. Consider families with 4 children. What combination of of genders (2 of each, 3 of 1 and 1 of the other, or all four the same) is most likely. -->




## Summary
###


```{r download-answers, child = "../../child_documents/download_answers.Rmd"}
```
