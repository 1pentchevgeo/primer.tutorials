---
title: Distributions
tutorial:
  id: distributions
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: Practice working with and understanding distributions.
---

```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(primer.data)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
```

```{r copy-code-chunk, child = "../../child_documents/copy_button.Rmd"}
```

```{r info-section, child = "../../child_documents/info_section.Rmd"}
```

<!-- Add Introduction and Summary. See the new Template for discussion. -->

<!-- Re-read first page or two of Instructions. -->

<!-- Read Chapter 7 closely! Think about what it means. Your job in Chapter 5, and in this tutorial, is to ensure that students, when they get to chapter 7, understand it thoughly. In particular, questions 3 and 4 are solved by create, in each row, a draw from a joint distribution, and then manipulating that draw each time. And then (magically!), the results of that manipulation are also a posterior! Would a guided tour of rvar variable types in this chapter help to set the stage for that? Should we use rvar types in later chapters? -->

<!-- Define a distribution. A mathematical object with two components: a list of possible outcomes and a corresponding frequency for each outcome. In a normalized distribution, the sum of the frequencies is 1.  -->
<!-- Note that this is a sloppy definition because it does not apply to continuous distributions. Need to mention this and then wave our hands. -->

<!-- Define a random variable is "a variable whose values depend on outcomes of a random phenomenon." Example: Result of one coin flip. -->

<!-- Consider the posterior package: https://mc-stan.org/posterior/index.html. Need a new random variable object type: https://mc-stan.org/posterior/articles/rvar.html -->


<!-- Add to chapter 5 a tutorial whose sole focus is distributions. First part of this is going slowly through the process by which counts can be turned into percentages. Do this in, at least, five ways. First, with geom_bar() which (I think) does the counting for us. Second, with geom_col(), in which we need to create the counts ourselves. Third with geom_histogram(). Fourth then maybe create a histogram by hand, using cut() and then counting up the elements in each range. -->

<!-- Put the Appendix-distribution questions somewhere here. -->

<!-- Maybe have a section explaining how the distribution of the error term is what motivates the selection of the appropriate family argument in stan_glm(). -->

<!-- Need a section titled "Random variables". Purpose is to connect the concept/use of random variables to the concept/use of a distribution.  -->

## Introduction

###

Now first recall that a distribution is a mathematical object with two components: a list of possible outcomes and a corresponding frequency for each outcome or simply *the collection of data on a single variable*. 

Normalized distribution is essentially turning the frequency into percent, and which sum up equal to 1.


This tutorial has three missions:
1. Review key concepts and commands which frequently use in creating distributions.
2. Identify how statistics alter with different distributions.
3. 

Random variable :
Ways to map the outcomes of random processes to quantifiable numbers.




## Monte Hall
###

<!-- https://en.wikipedia.org/wiki/Monty_Hall_problem -->

<!-- Make a tibble. First time with just 5 rows so that you can see what is happening each time. Only at the end, do you make the tibble be 4,000 rows and then use summarize to calculate your answer or, maybe better, show a graph.  -->

<!-- First column is the random location of the goat. "1", "2" or "3". Second column is your random guess. Third column is which door Monte opens. (He can't open your door, nor can he open the door with the goat.) Then, two more columns: one with what happens if you switch (possible values "Goat" or "Car"), one with what happens if you don't switch. (Same possible values.)  -->

<!-- Create monte_p object. -->

<!-- Teach at beginning some simple vector manipulation like: -->

<!-- c(1, 2, 3)[! c(1,2,3) %in% 2] -->

<!-- Also teach them about doubles for versus integer and 3 versus 3L. -->

<!-- First show them door_with_car == 1 & door_chosen == 2 ~ 3 -->

<!-- Second, show them two lines: -->

<!--                   door_with_car == 1 & door_chosen == 2 ~ 3, -->
<!--                   door_with_car == 2 & door_chosen == 1 ~ 3, -->

<!-- Third, combine the two lines with: -->

<!-- all(c(door_with_car, door_choosen) %in% c(2, 1)) ~ 3 -->

<!-- Fouth, add other two cases like this: -->

<!-- all(c(door_with_car, door_choosen) %in% c(1, 3)) ~ 2 -->
<!-- all(c(door_with_car, door_choosen) %in% c(2, 13) ~ 1 -->

<!-- Fifth, show -->

<!-- door_with_car == 1 & door_chosen == 1 ~ sample(c(2, 3), size = 1)) -->

<!-- Six, show all three. And that completes the problem!  -->

<!-- Seventh (maybe), show how them something like: -->

<!-- door_with_car == door_chosen ~ sample(c(1, 2, 3)[! c(1,2,3) %in% door_choosen], size = 1)) -->

Replace "if_else(switch,
                          case_when(" with just case_when().


```{r}

monte_p <- tibble(ID = 1:10000) %>%
  mutate(door_with_car =
           map_int(ID, ~ sample(1:3,  size = 1, replace = FALSE))) %>%
  mutate(door_chosen =
           map_int(ID, ~ sample(1:3,  size = 1, replace = FALSE))) %>%
  mutate(door_open = case_when(
            door_with_car == 2 & door_chosen == 2 ~ sample(c(1,3), size =1),
            door_with_car == 3 & door_chosen == 3 ~ sample(c(1,2), size =1),
            door_with_car == 1 & door_chosen == 1 ~ sample(c(2,3), size =1),
            door_with_car == 1 & door_chosen == 2 | door_with_car == 2 & door_chosen == 1 ~ 3,
            door_with_car == 1 & door_chosen == 3 | door_with_car == 3 & door_chosen == 1 ~ 2,
            door_with_car == 2 & door_chosen == 3 | door_with_car == 3 & door_chosen == 2 ~ 1)) %>%
  mutate(change_doors = map_lgl(ID, ~ sample(c(TRUE, FALSE), 1))) %>% 
  
  
  # mutate(doors_match = if_else(door_with_car == door_chosen,
  #                      TRUE, FALSE)) %>%

  # Add column door_final. If no switch, door_final is door_chosen. If switch,
  # slightly more complex. Only need to know door_chosen and door_open. You go
  # to the door that is not one of those two.

  # All the results which you are going to use with case_when() need to be of
  # the same type. Since one of the results is door_chosen (for cases when the
  # player does not switch) and since door_chosen is an integer, all the other
  # possible answers for case_when need to be integers. Adding an "L" to the end
  # of a number is the standard computer science way to say, "Make this an
  # integer.

  # mutate(door_final = if_else(change_doors,
  #          case_when(all(c(door_chosen, door_open) %in% c(1L, 2L)) ~ 3L,
  #                    all(c(door_chosen, door_open) %in% c(1, 3L)) ~ 2L,
  #                    all(c(door_chosen, door_open) %in% c(2, 3)) ~ 1L),
  #                    door_chosen)) %>%



mutate(door_final = if_else(change_doors,
           case_when(
             door_chosen == 1 & door_open == 2 | door_chosen == 2 & door_open == 1 ~ 3L,
             door_chosen == 1 & door_open == 3 | door_chosen == 3 & door_open == 1 ~ 2L,
             door_chosen == 2 & door_open == 3 | door_chosen == 3 & door_open == 2 ~ 1L),
                     door_chosen)) %>%
  
  mutate(result = case_when(
            door_final == door_with_car ~ "Win",
            door_final != door_with_car ~ "Lose")) %>% 

  ggplot(aes(x = change_doors, fill = result))+
 geom_bar(aes(y = after_stat(count/sum(count))), position = 'dodge')+
  scale_x_discrete(breaks = c(TRUE , FALSE),
                   labels = c("Switch", "Stay"))+
  scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1))+
  labs(title = "Joint distribution of Monty Hall Problem",
       subtitle = "One will have better change of winning if switching door",
       x = "Decision",
       y = "Probability",
       fill = "Result")

monte_p

```


### Exercise 1

Start a pipe with`tibble()` which have the variable ID and set it equal to the consecutive integer from 1 and 10000.
```{r monte-hall-1, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-1-hint, eval = FALSE}
tibble(ID = 1:10000)
```

###

### Exercise 2

Use `mutate()`, create a variable name `door_with_car`, and set it equal `map_int()`, which include the first variable `ID`, and then formula `sample()`which include three arguments, the first is `1:3` , then set `size` equal to `1`, then set `replace` equal to `FALSE`.
```{r monte-hall-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-2-hint, eval = FALSE}
mutate(door_with_car =
           map_int(ID, ~ sample(1:3,  size = 1, replace = FALSE)))
```

###

### Exercise 3

Use `mutate()`, create a variable name `door_chosen`, and set it equal `map_int()`, which include the first variable `ID`, and then formula `sample()`which include three arguments, the first is `1:3` , then set `size` equal to `1`, then set `replace` equal to `FALSE`.
```{r monte-hall-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-3-hint, eval = FALSE}
mutate(door_chosen =
           map_int(ID, ~ sample(1:3,  size = 1, replace = FALSE)))
```

###

### Exercise 4

Use `mutate()` create a new variable `door_open`, and set it equal to `case_when()`, and set it equal to `door_with_car == 2 & door_chosen == 2 ~ sample(c(1,3), size =1)`.

```{r monte-hall-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-4-hint, eval = FALSE}
mutate(door_open = case_when(
            door_with_car == 2 & door_chosen == 2 ~ sample(c(1,3), size =1)))
```

###

This argument means when `door_with_car` is equal to 2, and `door_chosen` equal to 2, this would returns `sample(c(1,3), size =1)` which means picking the value 1 or 3 at random.

### Exercise 5

Within `case_when()`, include another argument similar to the argument in previous exercise, instead this time set `door_with_car` equal to 3, and `door_chosen` also equal to 3, and change `c(1,3)` within `sample()` to `c(1,2)`
```{r monte-hall-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-5-hint, eval = FALSE}
mutate(door_open = case_when(
            door_with_car == 2 & door_chosen == 2 ~ sample(c(1,3), size =1)
            door_with_car == 3 & door_chosen == 3 ~ sample(c(1,2), size =1)))
```

###

### Exercise 6

Within `case_when()`, include another argument similar to the argument in previous exercise, instead this time set `door_with_car` equal to 1, and `door_chosen` also equal to 1, and change `c(1,2)` within `sample()` to `c(2,3)`
```{r monte-hall-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-6-hint, eval = FALSE}
mutate(door_open = case_when(
            door_with_car == 2 & door_chosen == 2 ~ sample(c(1,3), size =1),
            door_with_car == 3 & door_chosen == 3 ~ sample(c(1,2), size =1),
            door_with_car == 1 & door_chosen == 1 ~ sample(c(2,3), size =1)))
```

###

### Exercise 7


```{r monte-hall-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-7-hint, eval = FALSE}

```

###

### Exercise 8


```{r monte-hall-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-8-hint, eval = FALSE}

```

###

### Exercise 9


```{r monte-hall-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-9-hint, eval = FALSE}

```

###

### Exercise 10


```{r monte-hall-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-10-hint, eval = FALSE}

```

###

### Exercise 11


```{r monte-hall-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-11-hint, eval = FALSE}

```

###

### Exercise 12


```{r monte-hall-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-12-hint, eval = FALSE}

```

###

### Exercise 13


```{r monte-hall-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-13-hint, eval = FALSE}

```

###

### Exercise 14


```{r monte-hall-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-14-hint, eval = FALSE}

```

###

### Exercise 15


```{r monte-hall-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-15-hint, eval = FALSE}

```

###

### Exercise 16


```{r monte-hall-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r monte-hall-16-hint, eval = FALSE}

```

###




<!-- ## Two daughter puzzle -->
<!-- ### -->

<!-- Consider all the families in town with two children. All children are either boys or girls, each of which occur randomly with 50/50 odds. Pick a family with at least one girl at random. What are the chances that the other child is a girl? -->


<!-- ## Four children problem -->

<!-- All children are either boys or girls, each of which occur randomly with 50/50 odds. Consider families with 4 children. What combination of of genders (2 of each, 3 of 1 and 1 of the other, or all four the same) is most likely. -->




## Summary
###


```{r download-answers, child = "../../child_documents/download_answers.Rmd"}
```
