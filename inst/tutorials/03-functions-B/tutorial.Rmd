---
title: "Functions B"
tutorial:
  id: "functions-b"
output:
  learnr::tutorial:
      progressive: true
      allow_skip: true
runtime: shiny_prerendered
description: "Chapter 3 Tutorial Part B"
---


```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(skimr)
library(primer.data)

no_NA_sampler <- function(n, var, tbl){
  tbl %>% 
    drop_na() %>%
    sample_n(size = n) %>% 
    pull({{var}})
}

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

```

## Information
###

```{r information}
quiz(caption = "",
  question_text(
    "Name:",
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL),
  question_text(
    "Email:",
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL))
```


## no_NA_sampler()
###

In this section, we will make a custom function called `no_NA_sampler()`.

### Exercise 1

Recall the `nhanes` dataset. Use `$` to extract the `weight` column. 

```{r no-1, exercise = TRUE}

```


```{r no-1-hint-1, eval = FALSE}
nhanes$...
```

```{r no-1-hint-2, eval = FALSE}
nhanes$weight
```

### Exercise 2

We will create a function that allows us to sample `weight` from a tibble that contains no NA values for any of its variables. To warm up, use `sample()` to sample 5 values from `nhanes$weight`.

```{r no-2, exercise = TRUE}

```


```{r no-2-hint-1, eval = FALSE}
sample(..., ...)
```

```{r no-2-hint-2, eval = FALSE}
sample(nhanes$..., size = ...)
```

### Exercise 3

Start a pipe with `nhanes`. Use `drop_na()` to get rid of any NA values.

```{r no-3, exercise = TRUE}

```

```{r no-3-hint, eval = FALSE}
... %>% 
  drop_na()
```

### Exercise 4

Copy/paste your code from above. Pipe the result to `sample_n()`, setting the `size` argument to 3. Note that we are using `sample_n()` --- because we want all the rows from the tibble --- and not `sample()` --- which just gets values from a vector --- as we did in Exercise 2

```{r no-4, exercise = TRUE}

```

```{r no-4-hint, eval = FALSE}
... %>% 
  sample_n(size = ...)
```

### Exercise 5 

Copy/paste your code from above. Pipe the result to `pull()` with the argument `weight`. 

```{r no-5, exercise = TRUE}

```


```{r no-5-hint, eval = FALSE}
... %>% 
  pull(...)
```

### Exercise 6

The above code does what we want. Now we need to place it into a function. But, first, let's make a function `no_NA_sampler()` that doesn't do anything.

```{r no-6, exercise = TRUE}

```


```{r no-6-hint, eval = FALSE}
no_NA_sampler <- function(){
  
}
```

### Exercise 7

Copy/paste your code from above. Then, on the line below, call `no_NA_sampler()` to confirm that no output, beyond NULL, is returned. This is a common structure for tutorial questions going forward: define the function and then call the function you have, in this answer, just defined.

```{r no-7, exercise = TRUE}

```


```{r no-7-hint-1, eval = FALSE}
no_NA_sampler <- function(){
  
}

no_NA_sampler()
```

### Exercise 8

Copy/paste your code from Exercise 5 and place it inside the body `{ }` of `no_NA_sampler()`. Then, call `no_NA_sampler()`. 

```{r no-8, exercise = TRUE}

```


```{r no-8-hint-1, eval = FALSE}
no_NA_sampler <- function(){
  ...
}

no_NA_sampler()
```

### Exercise 9

Now adjust the code so we can pull any sample, not just 3! To do so, add the `n` argument inside `function()`. Also replace the 3 within `sample_n()` with `n`. 

```{r no-9, exercise = TRUE}

```


```{r no-9-hint-1, eval = FALSE}
no_NA_sampler <- function(...){
  nhanes %>% 
    drop_na() %>%
    sample_n(size = ...) %>% 
    pull(weight)
}
```

### Exercise 10

Add a call `no_NA_sampler()`. Notice that you receive an error message.


```{r no-10, exercise = TRUE}

```

```{r no-10-hint, eval = FALSE}
no_NA_sampler <- function(n){
  nhanes %>% 
    drop_na() %>%
    sample_n(size = n) %>% 
    pull(weight)
}

no_NA_sampler()
```

### Exercise 11

The error message suggested that we need to pass an argument for `n` when we call `no_NA_sampler()`. Call `no_NA_sampler()` setting the `n` argument to 5.


```{r no-11, exercise = TRUE}

```

```{r no-11-hint, eval = FALSE}
no_NA_sampler <- function(n){
  nhanes %>% 
    drop_na() %>%
    sample_n(size = n) %>% 
    pull(weight)
}

no_NA_sampler(...)
```

Great. Now we can use `no_NA_sampler()` to get however many values of weight that we want!


### Exercise 12

Copy/paste your code from above. Let's adjust our function to allow sampling from any variable. To do so, add the `var` argument inside `function()`. Also replace `weight` within `pull()` with `{{var}}`. (See *The Primer* for a discussion of the magic associated with "{{}}")

```{r no-12, exercise = TRUE}

```


```{r no-12-hint-1, eval = FALSE}
no_NA_sampler <- function(n, ...){
  nhanes %>% 
    drop_na() %>%
    sample_n(size = n) %>% 
    pull(...)
}
```

```{r no-12-hint-2, eval = FALSE}
no_NA_sampler <- function(n, var){
  nhanes %>% 
    drop_na() %>%
    sample_n(size = n) %>% 
    pull({{var}})
}
```

### Exercise 13

Now call `no_NA_sampler()`. (Recall that you need to copy/paste the definition of the function into any answer which is using that function.) Recall that we will receive an error message if we don't specify the `n` and `var` arguments. Call `no_NA_sampler()` setting the `n` argument to 5 and `var` to `height`.



```{r no-13, exercise = TRUE}

```


```{r no-13-hint-1, eval = FALSE}
no_NA_sampler <- function(n, var){
  nhanes %>% 
    drop_na() %>%
    sample_n(size = n) %>% 
    pull({{var}})
}

no_NA_sampler(n = ..., var = ...)
```

### Exercise 14

Let's adjust our function one last time to now allow sampling from any tibble. (The code so far has been provided for you because we are nice.)  Add the `tbl` argument inside `function()`. Also replace `nhanes` with `tbl`. We do not need to use the magic of "{{}}" for passing a tibble into a function.

```{r no-14, exercise = TRUE}
no_NA_sampler <- function(n, var){
  nhanes %>% 
    drop_na() %>%
    sample_n(size = n) %>% 
    pull({{var}})
}
```


```{r no-14-hint-1, eval = FALSE}
no_NA_sampler <- function(n, var, ...){
... %>% 
    drop_na() %>%
    sample_n(size = n) %>% 
    pull({{var}})
}
```

### Exercise 15

Great. Now call the `no_NA_sampler()` with the argument `n` set to 5. Also set `var` to `age` and set `tbl` to `cces`.



```{r no-15, exercise = TRUE}

```

```{r no-15-hint, eval = FALSE}
no_NA_sampler <- function(n, var, tbl){
  tbl %>% 
    drop_na() %>%
    sample_n(size = n) %>% 
    pull({{var}})
}

no_NA_sampler(n = ..., var = ..., tbl = ...)
```

Great work. `no_NA_sampler()` allows us to sample values from any variable in any tibble, after removing any rows with NA values. 

## Prediction Game
###

<!-- BG: write intro sentence.-->

### Exercise 1

Let's start by using `glimpse()` to look at `kenya`.

```{r pg-1, exercise = TRUE}

```

### Exercise 2

Assign the value 500 to the object `your_guess`. Then assign the value 600 to the object `my_guess`.

```{r pg-2, exercise = TRUE}

```

```{r pg-2-hint-1, eval = FALSE}
  your_guess <- ...
  my_guess <- ...
```

### Exercise 3

Copy/paste your code from above. Call `no_NA_sampler()` with the arguments. The first argument to `no_NA_sampler()` should be `kenya`. The second argument should be `rv13`. Also set the argument `n` to 1. Assign your code to an object named `sampled_value`.

```{r pg-3, exercise = TRUE}

```

```{r pg-3-hint-1, eval = FALSE}
your_guess <- 500
my_guess <- 600
sampled_value <- no_NA_sampler(...) 
```

```{r pg-3-hint-2, eval = FALSE}
your_guess <- 500
my_guess <- 600
sampled_value <- no_NA_sampler(kenya, rv13, ...)
```

### Exercise 4

Copy/paste your code from above. Let's now use `abs()` to calculate error for `your_guess`. Within `abs()`, subtract `sampled_value` from `your_guess`. Assign your code to an object named `your_error`.

```{r pg-4, exercise = TRUE}

```

```{r pg-4-hint, eval = FALSE}
...
...
...
your_error <- abs(... - ...)
```


### Exercise 5

Copy/paste your code from above. Do the same for `my_guess`. Within `abs()`, subtract `sampled_value` from `my_guess`. Assign your code to an object named `my_error`.

```{r pg-5, exercise = TRUE}

```

```{r pg-5-hint-1, eval = FALSE}
your_error <- abs(... - ...)
```

```{r pg-5-hint-2, eval = FALSE}
Your code so far should look like this:

your_guess <- 500
my_guess <- 600
sampled_value <- no_NA_sampler(kenya, rv13, n = 1) 
your_error <- abs(your_guess - sampled_value)
my_error <- abs(my_guess - sampled_value)
```

### Exercise 6

Copy/paste your code from above. Use `if()` with the argument `your_error` set greater than `my_error`. Then call `cat()` with the argument "I win!".


```{r pg-6, exercise = TRUE}

```

```{r pg-6-hint-1, eval = FALSE}
if(... < ...) cat(...)
```

### Exercise 7

Copy/paste your code from above. Use `if()` with the argument `my_error` set greater than `your_error`. Then call `cat()` with the argument "You win!".

```{r pg-7, exercise = TRUE}

```

```{r pg-7-hint, eval = FALSE}
if(... < ...) cat(...)
```

### Exercise 8

Good work. The above code does what we want. Now we need to place it into a function. But, first, let's make a function `prediction_game()` that doesn't do anything.

```{r pg-8, exercise = TRUE}

```

```{r pg-8-hint, eval = FALSE}
prediction_game() <- function(){
  
}
```

### Exercise 9

Copy/paste your code from Exercise 7 and place it inside the body `{ }` of `prediction_game()`. Then, call `prediction_game()`. 

```{r pg-9, exercise = TRUE}

```

```{r pg-9-hint, eval = FALSE}
prediction_game<- function() { 
your_guess <- 500
my_guess <- 600
  
sampled_value <- no_NA_sampler(kenya, rv13, n = 1) 
  
your_error <- abs(your_guess - sampled_value)
my_error <- abs(my_guess - sampled_value)
  
if(your_error < my_error) cat("You win!")
if(your_error > my_error) cat("I win!")

}

prediction_game()
```

### Exercise 10

Awesome. Let's use `replicate()` to run our function multiple times. The first argument to `replicate()` should be 4. The second argument should be the function `prediction_game()`.

```{r pg-10-setup}
prediction_game <- function(){
  your_guess <- 500
  my_guess <- 600
  
  sampled_value <- no_NA_sampler(kenya, rv13, n = 1) 
  
  your_error <- abs(your_guess - sampled_value)
  my_error <- abs(my_guess - sampled_value)
  
  if(your_error < my_error) cat("You win!")
  if(your_error > my_error) cat("I win!")
}
```

```{r pg-10, exercise = TRUE}

```

```{r pg-10-hint-1, eval = FALSE}
replicate(..., ...)
```

```{r pg-10-hint-2, eval = FALSE}
replicate(4, prediction_game())
```

Our function tells us who wins. What if we want to be more specific? In the next exercise, we will have our function print out the numerical guess that wins. For example, "Guess 500 wins!"


<!-- BG: I think this is unclear. Rephrase?  -->

### Exercise 11

The code you have created so far is below. Replace both `cat()` functions with the `return()` function. Within each `return()` statement, use the argument `paste()`. The first argument to `paste()` should be "Guess". The second argument should be `guess_1`(or guess_2 based on the `if()` statement). The third argument should be "wins!"

```{r pg-11, exercise = TRUE, error = TRUE}
prediction_game <- function(){
  your_guess <- 500
  my_guess <- 600
  
  sampled_value <- no_NA_sampler(kenya, rv13, n = 1) 
  
  your_error <- abs(your_guess - sampled_value)
  my_error <- abs(my_guess - sampled_value)
  
  if(your_error < my_error) cat("You win!")
  if(your_error > my_error) cat("I win!")
}
```

```{r pg-11-hint, eval = FALSE}
if(your_error < my_error){ 
    return(paste("Guess", your_guess, "wins!"))
}

 if(your_error > my_error){ 
    return(paste(..., ..., ...))
  }

```

<!-- TO-DO -->
<!-- adding stop_if_not() -->
<!-- generalize function -->
<!-- plot  -->



## Submit

```{r context = "setup"}
submission_ui
```

```{r context = "server"}
submission_server()
```


