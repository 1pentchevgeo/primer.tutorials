---
title: "Rubin Causal Model: Shaming (draft)"
tutorial:
  id: rubin-causal-model-shaming
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: "Exploring a data set involving attempts to get-out-the-vote in Michigan."
---

```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(primer.data)
library(skimr)
library(gt)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
```

```{r copy-code-chunk, child = "../../child_documents/copy_button.Rmd"}
```

```{r info-section, child = "../../child_documents/info_section.Rmd"}
```

First section, maybe only 5 or so questions, are EDA. Use shaming, ?shaming, summary(shaming), glimpse(shaming), skim(shaming).


## Shaming
###

The tibble `shaming` from **primer.data** includes data from "Social Pressure and Voter Turnout: Evidence from a Large-Scale Field Experiment" by Gerber, Green, and Larimer (2008). The aim of the study was to find out whether and to what extent people are motivated to vote by social pressure.

Today, we'll be doing a *deep dive* into the data set `shaming`, which investigates the effect of social pressure on voter turnout. Heads up, we'll be building ~ 6 tables, one written answer, and one plot. Should take about 3 hours. 

Our first table of the day is

```{r}
table1_show <- tibble(ID = c("1", "10", "323", "875", "344084"),
       ytreat = c("0", "?", "?", "1", "?"),
       ycontrol= c("?", "0", "1", "?", "1")) %>% 
  
  # For this question, we don't make the table too pretty. We want to build up
  # the complexity of the table over the course of several questions.

  gt()
table1_show
```

###
### Exercise 1

Let's start by loading in tidyverse and gt

```{r shaming-ex-1, exercise = TRUE}

```

```{r shaming-ex-1-hint, eval = FALSE}
library(tidyverse)
library(gt)
```

###
### Exercise 2


```{r shaming-ex-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-ex-2-hint, eval = FALSE}

```

###

## Covariates
###

Now, we'll be adding covariates into this table! 

```{r}
tibble(ID = c("1", "10", "323", "875", "344084"),
       ytreat = c("0", "?", "?", "1", "?"),
       ycontrol= c("?", "0", "1", "?", "1"),
       Age = c("65", "39", "56", "47", "57"),
       Sex = c("Male", "Male", "Male", "Female", "Female")) %>% 
 
   gt() %>% 
     
   tab_spanner(label = "Outcomes", c(ytreat, ycontrol)) %>% 
   tab_spanner(label = "Covariates", c(Age, Sex))    
```


## MoreOutcomes

Let's add some more outcomes. 

``` {r}
tibble(ID = c("1", "3", "10", "48", "51", "68", "198", "323", "875", "338640"),
       ycivic = c("0","?", "?", "?","1", "?", "?","?", "?","?"),
       yhawth = c("?", "1","?", "0", "?","?","?","?", "?","?"),
       yself = c("?","?", "?", "?","?","0","1", "?", "?","?"),
       yneigh = c("?","?", "?", "?","?","?", "?","?", "1","0"),
       ycontrol = c("?", "?","0", "?","?", "?","?", "1", "?", "?"),
       Age = c("65", "55","39", "53", "38 ", "56","46", "56", "47", "72"),
       Sex = c("Male", "Male", "Male", " Male", "Female", 
               "Female", "Female", "Male", "Female", "Male")) %>% 

  
  gt() %>%   
  
    # Adding curly braces { } allows the entire word (i.e. civic, hawth, etc) to
    # be subscript. If we did not use the curly braces, only the first letter
    # would be subscript, which we do not want.
  
    cols_label(ycivic = md("Y<sub>civic</sub>"),
               yhawth = md("Y<sub>hawth</sub>"),
               yself = md("Y<sub>self</sub>"),
               yneigh = md("Y<sub>neigh</sub>"),
               ycontrol = md("Y<sub>control</sub>")) %>% 
    tab_spanner(label = "Outcomes", c(ycivic, yhawth, yself, 
                                         yneigh, ycontrol)) %>% 
    tab_spanner(label = "Covariates", c(Age, Sex))

```


## Explaining Shaming
### Exercise 1
Write two paragraphs that explain the shaming experiment in the context of the Rubin Causal Model. The first paragraph should use these terms: “unit,” “treatment,” “outcome,” “potential outcomes,” “casual effect,” “assignment mechanism,” and “heterogeneous treatment effects.” Do not discuss “Preceptor Tables.”  ** this can be broken down even further

```{r written-ex-1}
question_text(NULL,
	message = "The shaming experiment consists of dividing the population of Michigan residents who voted in the 2004 general election into five parts. The *units* were Michigan individual voters. Half the residents were assigned to one of 5 possible *treatments*: being mailed one of four post card types or, the *control group*, being mailed nothing. The *assignment mechanism* by which the authors choose who received which post cards was random assignment. Each card contained different messages about voting. The *outcome* variable was voting (1) or not voting (0) in the 2006 primary election. Relative to the control, the largest *causal effect* --- the largest difference between the probability of voting --- was for the 'Neighbors' treatment. The causal effect of sending someone a Neighbors postcard was an increase in 8% in their likelihood of voting relative to what it would have been with no postcard. However, the treatment effect was not the same for all groups in our study population, in other words there were *heterogeneous treatment effects*. For example, the treatment effect was smaller in younger people.",
	answer(NULL,
	correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	options = list(nrows = 6))
```

### Exercise 2

Discuss 'population.' For context, imagine you are running for governor in Indiana 2022, and you are trying to decide if this experiment is relevant to your campaign. Use the terms “representative” and “validity.”
```{r explaining-shaming-ex-2}
question_text(NULL,
	message = "If I was running for governor in Indiana 2022, I would hesitate to use the experimental data. The outcome of the experiment is not relevant to my campaign. That is, it is not *valid* for my purposes. The goal is to win the election, yet the experimental data is about getting people to vote. I do not care if a postcard causes someone to vote who otherwise would not have voted. I want to cause people to vote for me! In addition, the *representativness* of the sample is a concern. The sample includes only Michigan voters, which may not be useful for making inferences about Indiana voters. In other words, the population for the study we have here does not look like the population we would have in 2022.",
	answer(NULL,
	correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	options = list(nrows = 6))
```

###

### Exercise 3

Insert q about ate, and potentially something about necessity of assumptions
Meaning of ATE --> for which group, how many do you think we need, something along those lines 
or don't even need q, just drop it along the way
** smoething abotu 2 sentences about ATE, go further in depth later in descript
```{r explaining-shaming-ex-3}
question_text(NULL,
	message = "answer here",
	answer(NULL,
	correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	options = list(nrows = 6))
```

###



## Object 1
###

###

We will create a tibble which looks like this:

``` {r}
object_1 <- shaming %>% 
  filter(treatment %in% c("Control", "Neighbors")) %>% 
  
  # Group by treatment so summarize() does not take the average of all 
  # treatments together, but instead for each individual treatment individually.
  
  group_by(treatment) %>% 
  summarize(avg.percent = mean(primary_06), .groups = "drop")  %>%

  # Use pivot_wider() to have the columns take the name of each treatment. Better
  # to visualize the avg.percent values this way.
  
  pivot_wider(names_from = treatment,
              values_from = avg.percent) %>%
  
  # Lastly, creating a column for the ATE values. Note that the tibble is already
  # grouped by treatment so we do not need to do it here.
  
  mutate(ATE = Neighbors - Control)

object_1
```

###


 
### Exercise 1

Start a new pipe with shaming, and filter it to find the value of control and neighbors within treatment

```{r object-ex-1, exercise = TRUE}

```

```{r object-ex-1-hint-1, eval = FALSE}
Use %in% and c()
```

```{r object-ex-1-hint-2, eval = FALSE}
shaming %>% 
  filter(treatment %in% c("...","..."))
```

###

### Exercise 2

Now let's group by treatment 

```{r object-ex-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r object-ex-2-hint, eval = FALSE}
filter(treatment %in% c("Control", "Neighbors")) %>% 
  
  # Group by treatment so summarize() does not take the average of all 
  # treatments together, but instead for each individual treatment individually.
  
  group_by(treatment) %>% 
  summarize(avg.percent = mean(primary_06), .groups = "drop")  %>%

  # Use pivot_wider() to have the columns take the name of each treatment. Better
  # to visualize the avg.percent values this way.
  
  pivot_wider(names_from = treatment,
              values_from = avg.percent) %>%
  
  # Lastly, creating a column for the ATE values. Note that the tibble is already
  # grouped by treatment so we do not need to do it here.
  
  mutate(ATE = Neighbors - Control)
```

###

### Exercise 3

Hmm... well we don't care about EVERYBODY, we just care about the general public. Let's reduce the data so we find the mean for people in primary 06
```{r object-ex-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r object-ex-3-hint, eval = FALSE}
 summarize(avg.percent = mean(primary_06), .groups = "drop")
```

###

### Exercise 4

Let's make this a bit cleaner. 
```{r object-ex-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r object-ex-4-hint, eval = FALSE}
pivot_wider(names_from = ...., 
            values_from = ....)
```

###


### Exercise 5

Let's add the ATE back using mutate
```{r object-ex-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r object-ex-5-hint-1, eval = FALSE}
ATE = Difference between treated group and control group
```

```{r object-ex-5-hint-2, eval = FALSE}
ATE = Neighbour - Control 
```

###


 
 
## Objecttwo

``` {r}
results <- shaming %>% 
  group_by(treatment) %>% 
  summarize(avg.vote = mean(primary_06), 
            .groups = "drop")
 
# crossing() and unique() are functions that might be useful. unique() returns a
# the unique values in a vector.

object_2 <- crossing(treatment = unique(shaming$treatment), 
         control = unique(shaming$treatment)) %>%
  filter(! treatment==control) %>% 
  left_join(results, by = "treatment") %>% 
  left_join(results, 
            by = c("control" = "treatment"), 
            suffix = c(".treatment", ".control")) %>% 
  mutate(ATE = avg.vote.treatment - avg.vote.control)

object_2
```


### Exercise 1

Start a new pipe with shaming, and group it by treatment

```{r objecttwo-ex-1, exercise = TRUE}

```


```{r objecttwo-ex-1-hint, eval = FALSE}


```

###

### Exercise 2

Once again, we want to focus on primary_06. Summarize the avg vote by finding the mean.Save this to an object named results

```{r objecttwo-ex-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-2-hint, eval = FALSE}
summarize(avg_vote = mean(...), 
          .groups = "drop")

```

###

### Exercise 3

With col treatment and control, find all possible combinations 

```{r objecttwo-ex-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-3-hint, eval = FALSE}
... %>% 
crossing(treatment = unique(shaming$treatment), 
         control = unique(shaming$treatment)) 
```

###
### Exercise 4

Filter results so that the group in treatment is not the same as the one in control
```{r objecttwo-ex-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-4-hint, eval = FALSE}
  filter(! treatment==control)
```

###

### Exercise 5

Join the object results with the current tibble by treatment
```{r objecttwo-ex-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-5-hint, eval = FALSE}
  left_join(..., by = "...")

```

###

### Exercise 6

join results again, no further niching down to avg.vote.treatment and avg.vote.control
```{r objecttwo-ex-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-6-hint, eval = FALSE}

```

###

### Exercise 7

Add column ATE. Save result to object 2
```{r objecttwo-ex-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-7-hint-1, eval = FALSE}
ATE = Difference between treated group and control group
```
```{r objecttwo-ex-7-hint-2, eval = FALSE}
ATE = avg.vote.treatment - avg.vote.control
```
###




## Objectthree

``` {r}
object_3 <- shaming %>% 
  filter(treatment %in% c("Neighbors", "Control")) %>% 

  # Here, we use an ifelse() statement here to return "old" in the rows where
  # age is 64 # or older, and "young" elsewhere.
  
  mutate(age = ifelse(age > 64, "old", "young")) %>% 

  # Group by treatment AND age here so the avg.percent values are calculated for
  # "old" and "young" separately.
  
  group_by(treatment, age) %>% 
  summarize(avg.perc = mean(primary_06),
            .groups = "drop") %>% 
  pivot_wider(names_from = treatment,
            values_from = avg.perc) %>% 
  mutate(ATE = Neighbors - Control) %>% 
  
  # Using rename() to make the column names less confusing. We want to be specific
  # as possible. Having "Control" or "Neighbors" is too confusing.

  rename(c("control.perc" = Control,
           "neighbors.perc" = Neighbors))

object_3
```


## Plot

``` {r}
shaming %>% 
  filter(treatment %in% c("Neighbors", "Control")) %>% 
  filter(age < 90) %>% 
  
  # We filter here because there are NA values in ages such as 102 that give us a
  # "missing rows" message when we plot our values. The plot also looks nicer this way.

  group_by(treatment, age) %>% 
  summarize(avg.perc = mean(primary_06),
            .groups = "drop") %>% 

  # Using arrange allows us to see show the rows that have the youngest ages 
  # first.
  
  arrange(age) %>% 
  pivot_wider(names_from = treatment,
              values_from = avg.perc) %>% 
  mutate(ATE = Neighbors - Control) %>% 
  rename(c("control.perc" = Control,
           "neighbors.perc" = Neighbors)) %>% 
  ggplot(aes(x = age, y = ATE)) +
    geom_point() +
    geom_smooth(method = "loess",
                formula = y ~ x) +
  
    # Possibly revisit removing the gray area here because confidence intervals have
    # not been discussed yet.
  
    labs(title = "Effect on Voting of Neighbors Postcard",
        subtitle = "Average treatment effect is lower for the young and the very old",
         y = "Average Treatment Effect",
         x = "Age",
         caption = "Source: Gerber, Green, and Larimer (2008)") +
    theme_bw()
```

```{r download-answers, child = "../../child_documents/download_answers.Rmd"}
```
