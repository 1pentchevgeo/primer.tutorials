---
title: "Rubin Causal Model: Shaming"
author: 
tutorial:
  id: rubin-causal-model-shaming
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: "Exploring a data set involving attempts to get-out-the-vote in Michigan."
---

```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(primer.data)
library(skimr)
library(gt)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
```

```{r copy-code-chunk, child = "../../child_documents/copy_button.Rmd"}
```

```{r info-section, child = "../../child_documents/info_section.Rmd"}
```

<!-- You can't drop knowledge about the line of code. The code is easy! So, drop knowledge about the Chapter. -->

<!-- Unsure about stability.  -->

<!-- potentially add a question about population tables, and their purpose? As well maybe a ATE written response later in tutorial. -->

<!-- Estimand? -->


## Table of outcomes and covariates

###

The tibble `shaming` from the **primer.data** package includes data from "Social Pressure and Voter Turnout: Evidence from a Large-Scale Field Experiment" ([pdf](https://github.com/PPBDS/primer.data/blob/master/inst/papers/shaming.pdf)) by Gerber, Green, and Larimer (2008). The aim of the study was to explore to what extent people are motivated to vote by social pressure. 

###

Using the data, we'll be making this table to find how different treatments impact the amount of people who vote (primary_06).

```{r}
tibbleone <- tibble(ID = c("1", "3", "10", "48", "51", "68", "198", "323", "875", "338640"),
       ycivic = c("0","?", "?", "?","1", "?", "?","?", "?","?"),
       yhawth = c("?", "1","?", "0", "?","?","?","?", "?","?"),
       yself = c("?","?", "?", "?","?","0","1", "?", "?","?"),
       yneigh = c("?","?", "?", "?","?","?", "?","?", "1","0"),
       ycontrol = c("?", "?","0", "?","?", "?","?", "1", "?", "?"),
       Age = c("65", "55","39", "53", "38 ", "56","46", "56", "47", "72"),
       Sex = c("Male", "Male", "Male", " Male", "Female", 
               "Female", "Female", "Male", "Female", "Male")) %>% 

  
  gt() %>%   
  
    # Adding curly braces { } allows the entire word (i.e. civic, hawth, etc) to
    # be subscript. If we did not use the curly braces, only the first letter
    # would be subscript, which we do not want.
  
    cols_label(ycivic = md("Y<sub>civic</sub>"),
               yhawth = md("Y<sub>hawth</sub>"),
               yself = md("Y<sub>self</sub>"),
               yneigh = md("Y<sub>neigh</sub>"),
               ycontrol = md("Y<sub>control</sub>")) %>% 
    tab_spanner(label = "Outcomes", c(ycivic, yhawth, yself, 
                                         yneigh, ycontrol)) %>% 
    tab_spanner(label = "Covariates", c(Age, Sex))
```


### Exercise 1

Load in libraries **tidyverse**, **gt**, and **skimr**.

```{r shaming-ex-1, exercise = TRUE}

```

```{r shaming-ex-1-hint, eval = FALSE}

```

###

The experimenters sent 5 different postcards to all the voters in Michigan before the 2006 primary election. They wanted to understand if certain types of messages increase voter turnout. 

<!-- Insert talks about unit here, and how one citizen is a unit for shaming -->

### Exercise 2

Run `glimpse()` into the data set `shaming`.

```{r shaming-ex-2, exercise = TRUE}

```

```{r shaming-ex-2-hint, eval = FALSE}
glimpse(shaming)
```

###

The first postcard was named "Civic Duty", contained a letter "to do their civic duty and vote". The second postcard was named "Hawthorne" which contained the same letter, as well as a notice  that they were being studied by researchers. The third postcard "Self" contained everything in the Hawthorn postcard, and added a message which said that every household member would be notified of each others' voting behaviors. The last postcard "Neighbors" would list not only the voting behavior of household members, but also voting records of people nearby. 

<!-- reduce? -->

### Exercise 3

Try out `?shaming` to compare it to `glimpse(shaming)`

```{r shaming-ex-3, exercise = TRUE}

```

```{r shaming-ex-3-hint, eval = FALSE}
?shaming
```

###

Notice how `?shaming` gives you an explanation of the experiment, and each column! It can also tell you the column type and number of empty rows. 

<!-- Insert assignment mechnism here. -->

### Exercise 4

Type `tibble(ID = "1")` in order to create the start of the pipe which we will build into the Preceptor Table which we showed you above. The number 1 is the way that we will refer to the first person in the table, since we do not know their name.


```{r shaming-ex-4, exercise = TRUE}
 
```

For your reference, this is row 1 of the `shaming` data set

``` {r}
shaming %>% 
  slice(1)  
```


```{r shaming-ex-4-hint, eval = FALSE}
tibble(ID = "1")
```

###

For review, you can find the basics of gt tables [here](https://gt.rstudio.com/articles/intro-creating-gt-tables.html), and by referencing the earlier tutorial.

### Exercise 5

Create another column in your tibble by adding `, ytreat = "0"` after `ID = "1"`.


```{r shaming-ex-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-ex-5-hint, eval = FALSE}
tibble(ID = "1",
       ytreat = "0")

```

###

ytreat is the column where we input whether or not they voted (primary_06), *if they were apart of one of the treatment groups*, using a 0 or 1. 0 means that they did not vote, while 1 means that they did. However, if person 1 was part of the control group, we would list a "?" in the ytreat column, since we do not know whether they would have voted. 

### Exercise 6

Add a new column named `ycontrol`. Set the value of `ycontrol` to '?'.

```{r shaming-ex-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-ex-6-hint, eval = FALSE}
tibble(ID = ("1"),
       ytreat = "0",
       ycontrol = "?")
```

###

The ? in the ycontrol column is due to the Fundamental Problem of Causal Inference. Since we are already observing one potential outcome (Person 1 was given a treatment postcard), we can not also see the other potential outcome (Person 1 is given a control postcard), which is why we list it as ?. 

<!-- Insert tao calculate + talk here -->

### Exercise 7

Let's add Person 10 into the tibble. Use `c()` to add more than one number into the column. Notice how this person is apart of the control group. How will this change the entry? 

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-ex-7, exercise = TRUE}

```

For your reference, this is row 10 of `shaming`.
``` {r}
shaming %>% 
  slice(10)
```

```{r shaming-ex-7-hint-1, eval = FALSE}
Remember to use c("..", "...") if you want to add more than 1 number in each column.
```

```{r shaming-ex-7-hint-2, eval = FALSE}
tibble(ID = c("1","10"),
       ytreat = c("0", "?"),
       ycontrol = c("?", "0"))
```

###

Here, we start seeing a key assumption of Population Tables. Consider validity in the context of Preceptor Tables. Do you think the treatments of Person 1 and 10 were exactly the same? What if they saw the postcards on different days or times? Could seeing it on a Monday rather than a Wednesday affect their reaction? At 8AM rather than 8PM? 

<!-- Insert Heterogenous treatment effects talk here + multiple tao-->

###

Your table should look like this. 
```{r}
tibble(ID = c("1","10"),
       ytreat = c("0", "?"),
       ycontrol = c("?", "0"))
```

### Exercise 8

Expand your tibble by adding Person 313, 875, and 344084. Pipe `gt()` at the end to make it a gt table. 

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-ex-8, exercise = TRUE}

```

For your reference, here are the rows 

``` {r}
shaming %>% 
  mutate(row_number = row_number()) %>% 
  filter(row_number == "323" | row_number == "875" | row_number == "344084") %>% 
  relocate(row_number)
```


```{r shaming-ex-8-hint-1, eval = FALSE}
`View(shaming)` will let you see all the data.
```

```{r shaming-ex-8-hint-2, eval = FALSE}
tibble(ID = c("1", "10", "323", "875", "344084"),
       ytreat = c("0", "?", "?", "1", "?"),
       ycontrol= c("?", "0", "1", "?", "1")) %>% 
  gt()
```

###

`View(shaming)` would have also allowed you to see all the `shaming` data.

###

Your table should look like this.

```{r}
tibble(ID = c("1", "10", "323", "875", "344084"),
       ytreat = c("0", "?", "?", "1", "?"),
       ycontrol= c("?", "0", "1", "?", "1")) %>% 
  gt()
```

### Exercise 9

Add columns "age" and "sex" to the tibble. Use the data from the table to fill in the rows accordingly.

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-ex-9, exercise = TRUE}

```

Rows of `shaming`, for your reference.
``` {r}
shaming %>% 
  mutate(row_number = row_number()) %>% 
  filter(row_number == "1" | row_number == "10" | row_number == "323" | row_number == "875" | row_number == "344084" ) %>% 
  relocate(row_number)
```


```{r shaming-ex-9-hint, eval = FALSE}
tibble(...., 
       age = c("65","39"), 
       sex = c("Male","Male"))
```

###

Age and sex are covariants, which are variables which could *possibly* influence whether a person votes. Other examples of covariants include income, race, and whether they voted in the previous election. 

### Exercise 10

We want to replace the column `ytreat` with the four different treated categories: `Civic Duty`, `Hawthorne`, `Self`, and `Neighbors`. Delete column `ytreat` and add column `ycivic` by adding `ycivic = c("0","?","...","...","...")` after column `ID`. Fill in the column with the correct outcomes for each ID.     

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-ex-10, exercise = TRUE}

```

``` {r}
shaming %>% 
  mutate(row_number = row_number()) %>% 
  filter(row_number == "1" | row_number == "10" | row_number == "323" | row_number == "875" | row_number == "344084" ) %>% 
  relocate(row_number)
```

```{r shaming-ex-10-hint-1, eval = FALSE}
tibble(ID = c("1", "10", "323", "875", "344084"),
       ycivic = c("0", "...","...", "...","..."),
       ycontrol= c("?", "0", "1", "?", "1"), 
       age = c("65", "39", "56", "47", "57"),
       ....

```

```{r shaming-ex-10-hint-2, eval = FALSE}
Recall, if we don't know the reaction of the person to something, 
we put in a "?", we like have for column `ycontrol` and `ytreat`. 
Love the Fundamental Problem of Causal Inference.
```

```{r shaming-ex-12-hint-3, eval = FALSE}
tibble(ID = c("1", "10", "323", "875", "344084"),
       ycivic = c("0", "?","?", "?","?"),
       ycontrol= c("?", "0", "1", "?", "1"), 
       age = c("65", "39", "56", "47", "57"),
       ....
```

###

Going back to the assumptions of Population Tables, we can also consider stability in the context of Preceptor Tables. 

<!-- Insert talk about stability -->

### Exercise 11

Create column `yhawth` below `ycivic`. Add the corresponding outcomes for each person, like you did for column `ycivic`. 

<!-- SZ: Should I guide them more here?, also should i include so many rows of shaming? -->

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-11, exercise = TRUE}

```

``` {r}
shaming %>% 
  mutate(row_number = row_number()) %>% 
  filter(row_number == "1" | row_number == "10" | row_number == "323" | row_number == "875" | row_number == "344084" ) %>% 
  relocate(row_number)
```

```{r table-of-outcomes-an-11-hint, eval = FALSE}
tibble(ID = c("1","10", "323", "875", "338640"),
       ycivic = c("0", "?","?", "?","?"),
       yhawth = c("?","?","?", "?","?"),
       ycontrol = c("?","0", "1", "?", "?") ... 
```

###

We currently only deal with 5 people (or IDs). Does this small sample represent the entire population? This data only represents a small neighborhood in Michigan. Could we use this data for all citizens in Michigan? For everyone in America? Maybe everyone in Michigan is similar, so we could use these findings.  

### Exercise 12

Add columns `yself` and `yneigh` like you did for the other two treatment columns. Add in the respective outcomes. 

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-12, exercise = TRUE}

```

``` {r}
shaming %>% 
  mutate(row_number = row_number()) %>% 
  filter(row_number == "1" | row_number == "10" | row_number == "323" | row_number == "875" | row_number == "344084" ) %>% 
  relocate(row_number)
```

```{r table-of-outcomes-an-12-hint, eval = FALSE}
tibble(ID = c("1","10", "323", "875", "338640"),
       ycivic = c("0", "?","?", "?","?"),
       yhawth = c("?","?","?", "?","?"),
       yself = c("?", "?", "?", "?","?"),
       yneigh = c("?", "?", "?", "1","0"),
       ycontrol = c("?","0", "1", "?", "?")
       ....
```

###

Your table should look something like this
```{r}
tibble(ID = c("1","10", "323", "875", "338640"),
       ycivic = c("0", "?","?", "?","?"),
       yhawth = c("?","?","?", "?","?"),
       yself = c("?", "?", "?", "?","?"),
       yneigh = c("?", "?", "?", "1","0"),
       ycontrol = c("?","0", "1", "?", "?"),
       age = c("65","39", "56", "47", "72"),
       sex = c("Male", "Male", "Male", "Female", "Male")) %>% 

  
  gt()  

```

### Exercise 13

Use `tab_spanner()` to create an overarching subtitle. Within `tab_spanner()`, set `label = "Covariants", c(age, sex)`.

<!-- SZ: Less guidence?  -->

```{r shaming-ex-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-ex-13-hint-1, eval = FALSE}
The code should be placed after the gt(). Continue the pipe with %>% before adding in your commands, making sure to use c() for ytreat and ycontrol. 
```

```{r shaming-ex-13-hint-2, eval = FALSE}
tibble(....) %>% 
  gt() %>% 
  tab_spanner(label = "Outcomes", c(ytreat, ...))
```

###

This allows us to separate the covariants from the outcome data to better organize the data. Think of them as subtitles of the table. 

###

Your table should look like this
```{r}
tibble(ID = c("1", "10", "323", "875", "344084"),
       ytreat = c("0", "?", "?", "1", "?"),
       ycontrol= c("?", "0", "1", "?", "1"),
       age = c("65", "39", "56", "47", "57"),
       sex = c("Male", "Male", "Male", "Female", "Female")) %>% 
 
   gt() %>% 
     
   tab_spanner(label = "Covariants", c(age, sex))
```


### Exercise 14

Use `tab_spanner()` to create another overarching title. Set `label = "Outcome"`, and include all the treatment columns (ycivic, yhawth, etc.) after the label, like we did with the covariants. 
```{r table-of-outcomes-an-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-14-hint-1, eval = FALSE}
tibble(....) %>% 
  gt() %>% 
  tab_spanner(label = "Covariants", c(age, sex)) %>% 
  tab_spanner(label = "Outcomes", c(..., ...)) 
  
```

```{r table-of-outcomes-an-14-hint-2, eval = FALSE}
tibble(....) %>% 
  gt() %>% 
  tab_spanner(label = "Covariants", c(age, sex)) %>% 
  tab_spanner(label = "Outcomes", c(ycivic, yhawth, yself, ....)) 
  
```
###

If you want more info on gt functions that help with formatting/style, click [here](https://gt.rstudio.com/reference/index.html). Good looking tables are HOT!


### Exercise 15

Format these variables to look more professional by changing ycivic into $\sf{Y_{civic}}$ using `cols_label()` and HTML (`<sub>` and `</sub>`   ). The format of this function is `cols_label(columnname = md("inserttext<sub>insertsubscripttext</sub>")`. Window users may have issues with this function, if it isn't working, feel free to skip this part. 

<!-- SZ: More guidence?  -->

```{r shaming-ex-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-ex-15-hint, eval = FALSE}
gt %>%
cols_label(ycivic = md("Y<sub>civic</sub>"),
            yhawth = md("Y<sub>hawth</sub>")
           ....
```

###

Use `?gt::md` in the console if you want more info about the `md()` function, which helps with converting text into t R Markdown-formatted text. Super useful for things like footnotes, fonts, currency, etc. 

### Exercise 16

Change all the other treatment labels (yhawth, yself, yneigh) in the table to have the same formatting, using `cols_label()`. 

```{r table-of-outcomes-an-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-16-hint, eval = FALSE}
cols_label(ycivic = md("Y<sub>civic</sub>"),
               yhawth = md("Y<sub>hawth</sub>"),
               yself = md("Y<sub>self</sub>"),
               yneigh = md("Y<sub>neigh</sub>"),
               ycontrol = md("Y<sub>control</sub>"))
```

###

`col_label()` can hold multiple columns within it, similar to ID. Although `col_label(ycivic = md("Y<sub>civic</sub>")) %>% cols_label(ycontrol = md("Y<sub>control</sub>"))` works, you can also do `cols_label(ycivic = md("Y<sub>civic</sub>"), yhawth = md("Y<sub>hawth</sub>"))` for efficiency. 

<!-- SZ: Is it possible to format this chunk of code better?  -->

### Exercise 16

Add Person 3, 48, 51, 68 and 198 into the table! Fill in each column as necessary.  

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-ex-16, exercise = TRUE}

```

For your reference, the rows look like this: 

```{r}
shaming %>% 
  mutate(row_number = row_number()) %>% 
  filter(row_number == "3" | row_number == "48" | row_number == "51" | row_number == "68" | row_number == "198") %>% 
  relocate(row_number)
```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-ex-16-hint, eval = FALSE}
tibble(ID = c("1", "3", "10", "48", "51", "68", "198", "323", "875", "338640"),
       ycivic = c("0","?", "?", "?","1", "?", "?","?", "?","?"),
       yhawth = c("?", "1","?", "0", "?","?","?","?", "?","?"),
       yself = c("?","?", "?", "?","?","0","1", "?", "?","?"),
       yneigh = c("?","?", "?", "?","?","?", "?","?", "1","0"),
       ycontrol = c("?", "?","0", "?","?", "?","?", "1", "?", "?")....
```

<!-- Sz: hint is too direct? -->

###

Your table should look like this 
```{r}
tibbleone 
```

### 

You can also add a title using `tab_header()`. I propose the title "WOO! Peer pressure works wonders ;)" 
Good job with this section!

## Understanding shaming

### Exercise 1
Write a paragraph that explain the shaming experiment in the context of the Rubin Causal Model. The first paragraph should use these terms: “unit,” “treatment,” “outcome,” “potential outcomes,” “casual effect,” “assignment mechanism,” and “heterogeneous treatment effects.” Do not discuss “Preceptor Tables.”  

Hint: Many of these terms are defined in their respective sections in [Chapter 4](https://ppbds.github.io/primer/rubin-causal-model.html) of the Primer. All you really need to do is connect back to the `shaming` experiment. Give examples! 
```{r written-ex-1}
question_text(NULL,
	message = "The shaming experiment consists of dividing the population of Michigan residents who voted in the 2004 general election into five parts. The *units* were Michigan individual voters. Half the residents were assigned to one of 5 possible *treatments*: being mailed one of four post card types or, the *control group*, being mailed nothing. The *assignment mechanism* by which the authors choose who received which post cards was random assignment. Each card contained different messages about voting. The *outcome* variable was voting (1) or not voting (0) in the 2006 primary election. Relative to the control, the largest *causal effect* --- the largest difference between the probability of voting --- was for the 'Neighbors' treatment. The causal effect of sending someone a Neighbors postcard was an increase in 8% in their likelihood of voting relative to what it would have been with no postcard. However, the treatment effect was not the same for all groups in our study population, in other words there were *heterogeneous treatment effects*. For example, the treatment effect was smaller in younger people.",
	answer(NULL,
	correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### Exercise 2

Discuss 'population.' For context, imagine you are running for governor in Indiana 2022, and you are trying to decide if this experiment is relevant to your campaign. Use the terms “representative” and “validity.”

Hint: you may find the [Cardinal Virtues section](https://ppbds.github.io/primer/probability.html#cardinal-virtues) of Chapter 5, or the [Population Table section](https://ppbds.github.io/primer/rubin-causal-model.html#population-table) of Chapter 4 to be useful. Check them out :)
```{r explaining-shaming-ex-2}
question_text(NULL,
	message = "If I was running for governor in Indiana 2022, I would hesitate to use the experimental data. The outcome of the experiment is not relevant to my campaign. That is, it is not *valid* for my purposes. The goal is to win the election, yet the experimental data is about getting people to vote. I do not care if a postcard causes someone to vote who otherwise would not have voted. I want to cause people to vote for me! In addition, the *representativness* of the sample is a concern. The sample includes only Michigan voters, which may not be useful for making inferences about Indiana voters. In other words, the population for the study we have here does not look like the population we would have in 2022.",
	answer(NULL,
	correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

## One ATE

###

We will create a tibble with one ATE (average treatment effect), which looks like this:

``` {r}
object_1 <- shaming %>% 
  filter(treatment %in% c("Neighbors", "Control")) %>% 
  
  # Group by treatment so summarize() does not take the average of all 
  # treatments together, but instead for each individual treatment individually.
  
  group_by(treatment) %>% 
  summarize(avg.percent = mean(primary_06), .groups = "drop")  %>%

  # Use pivot_wider() to have the columns take the name of each treatment. Better
  # to visualize the avg.percent values this way.
  
  pivot_wider(names_from = treatment,
              values_from = avg.percent) %>%
  
  
  # Lastly, creating a column for the ATE values. Note that the tibble is already
  # grouped by treatment so we do not need to do it here.
  
  mutate(ATE = Neighbors - Control) %>% 
  relocate(Neighbors) 
  

object_1
```

###

The purpose of this tibble is to estimate the ATE to see how the treatment "Neighbor" compares to the control. 
 
### Exercise 1

Start a new pipe with shaming, and `filter()` it to find the value of control and neighbors within treatment 

```{r object-ex-1, exercise = TRUE}

```

```{r object-ex-1-hint-1, eval = FALSE}
Use %in% and c()
```

```{r object-ex-1-hint-2, eval = FALSE}
shaming %>% 
  filter(treatment %in% c("control","..."))
```

###

Data science is mostly filtering out all the important parts of a data set, which helps you analyze it. Although tedious, removing values which contain errors, or anything unnecessary is important. 


### Exercise 2

Now let's `group_by` treatment 

```{r object-ex-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r object-ex-2-hint, eval = FALSE}
... %>% 
group_by(treatment) %>% 

```

###  

We want to `group_by()` treatment, since it takes the average of each individual treatment, individually. `summarize()`, on the other hand, takes the averages of all treatments together. 

### Exercise 3

Create a new column called avg.percent using `summarize()`. Set the first input to the mean of `primary_06`, and set .groups equal to "drop". 

<!-- SZ: How do i phrase this? also saying we want to use groupby then using summarize -->

```{r object-ex-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r object-ex-3-hint, eval = FALSE}
... %>%  
summarize(avg.percent = mean(primary_06),
          .groups = "drop")
```

###

We don't want every single person in the data set, we just want to see the general trends. Recall the Population Table assumption representativeness. We define our scope (a small neighborhood in Michigan), and remove any data that is not within our scope.    

### Exercise 4

Use `pivot_wider()` to make the table look better. Set `names_from` to treatment, and `values_from` to avg.percent
```{r object-ex-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r object-ex-4-hint, eval = FALSE}
... %>% 
pivot_wider(names_from = ...., 
            values_from = ....)
```

###

`pivot_wider()` ensures that the table is easier to look at, by displaying all the data in one row, rather than multiple. This is the opposite of `pivot_longer()`, which makes the tibble longer and is clearly inferior. 

### Exercise 5

Create a new column using `mutate` called `ATE`, by finding the difference between treated group and control group 
```{r object-ex-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r object-ex-5-hint-1, eval = FALSE}
ATE = Subtract the value of Control from Neighbor
```

```{r object-ex-5-hint-2, eval = FALSE}
... %>% 
mutate(ATE = Neighbour - Control) 
```

###

Remember that ATE is the average treatment effect and is the difference between potential outcomes (effect of treatment neighbor vs effect of control). In this tibble, we take the mean of `primary_06`, full of 0 and 1s, and figures out on average, how likely a person is to vote when subjected to treatment `neighbor`, and treatment `control`. 

### Exercise 6

Pipe in `relocate(Neighbors)`, which will make column `Neighbors` the leftmost column. Once you're finished, save the tibble to 'object_1'.
```{r object-ex-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r object-ex-6-hint-1, eval = FALSE}
... %>% 
relocate(Neighbors)
```

###

By changing `Neighbor` to be the leftmost column, it formats the table to look cleaner, since the way you calculate ATE is Neighbors - Control, rather than Control - Neighbors. Remember, details matter, and good job!

## Multiple ATE

###

In this table, our goal is to see how each treatment compares to the other, using the ATE as a frame of reference. This is the table we want to recreate. 

``` {r}
results <- shaming %>% 
  group_by(treatment) %>% 
  summarize(avg.vote = mean(primary_06), 
            .groups = "drop")
 
# crossing() and unique() are functions that might be useful. unique() returns a
# the unique values in a vector.

object_2 <- crossing(treatment = unique(shaming$treatment), 
         control = unique(shaming$treatment)) %>%
  filter(! treatment==control) %>% 
  left_join(results, by = "treatment") %>% 
  left_join(results, 
            by = c("control" = "treatment"), 
            suffix = c(".treatment", ".control")) %>% 
  mutate(ATE = avg.vote.treatment - avg.vote.control)

object_2
```


### Exercise 1

Start a new pipe with the `shaming` data set. `group_by()` treatment

```{r objecttwo-ex-1, exercise = TRUE}


```


```{r objecttwo-ex-1-hint, eval = FALSE}
shaming %>% 
group_by(treatment)

```

###

The object we are currenly making is a causal model, rather than a predictive model. Recall that a predictive model, we only want to *know a outcome*, such $\sf{Y_{u}}$, whereas for a causal model, we want to know the *function of potential outcomes*, such as the ATE.  

### Exercise 2

Use `summarize` with the mean of primary_06, and save it to 'avg_vote'. Set `.groups` to "drop". When finished, save this as object `results`

```{r objecttwo-ex-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-2-hint, eval = FALSE}
... %>% 
summarize(avg_vote = mean(...), 
          .groups = "drop")

```

###

A key difference between predictive and causal models is that predictive models only have ONE possible outcome for each person. For example, refer back to the [brother height section](https://ppbds.github.io/primer/rubin-causal-model.html#preceptor-table). The brothers only have one predicted height, and therefore, one outcome. Causal models, on the other hand, have at least two or more outcomes. Currently, we have two 'major' columns (control and treatment), which can be broken down even further (Civic duty, neighbor, etc.), which results in many different possible outcomes. 

<!-- Insert what the results object is used for.  -->

### Exercise 3

Start a new pipe. Using `crossing(treatment = (...), control = (...))`, we want to find all the different possible pairs between treatment types. Set both treatment and control as `shaming$treatment`, allowing us to grab all the treatments. 

<!-- SZ: too direct? too confusing? -->
```{r objecttwo-ex-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-3-hint-1, eval = FALSE}
... 
crossing(treatment = (...$...), 
         control = (...$...)) 
```

```{r objecttwo-ex-3-hint-2, eval = FALSE}
... %>% 
crossing(treatment = (shaming$treatment), 
         control = (shaming$treatment)) 
```

###

Notice how row 1 has `Control` in both the treatment and control columns. The same thing happens with `Civic Duty` in row 7, and `Hawthorne` in row 13. Let's change it so that this doesn't happen.


### Exercise 4

Put shaming$treatment inside of `unique()`. 

<!-- Change wording --> 

```{r multiple-ate-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r multiple-ate-4-hint, eval = FALSE}
... %>% 
crossing(treatment = unique(shaming$treatment), 
         control = unique(shaming$treatment))
```

###

<!-- SZ: don't really understand the point of unique, when we filter right after to make sure they don't equal the same thing? -->

### Exercise 5

`filter()` results so that no entry in the treatment column is the same as an entry in the control column. We can use `!...==...` to symbolize "is not equal". 
```{r objecttwo-ex-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-5-hint-1, eval = FALSE}
... %>%   
filter(! ...==...)
```

```{r objecttwo-ex-5-hint-2, eval = FALSE}
... %>%   
filter(! treatment==control)
```

###

`!=` is typically the way to symbolize "is not equal to". This also applies to various other languages, such as Python, Java, and C. It comes from the symbol $≠$ in math. 
 
### Exercise 6

Use `left_join()' to join `results` by "treatment".

```{r objecttwo-ex-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-6-hint-1, eval = FALSE}
 ... %>%  
left_join(..., by = "...")

```

```{r objecttwo-ex-6-hint-2, eval = FALSE}
... %>% 
left_join(results, by = "treatment")
```
###

Typically, `left_join()` is done using two tibbles from the same data source. However, if there are multiple columns names which are the same, and the user has not specified to join those columns in the `by` argument, they will be differentiated by adding the suffix ".x" and ".y" to the name. For example, we have two entries which are called table. Once joining, they will appear as column "table.x" and "table.y" to denote that they are different columns. The .x and .y can be changed by using `suffix()` and specifying the column's suffix.  

<!-- SZ: Check suffixes?  -->

### Exercise 7

Pipe `left_join(results, by = c("control" = "treatment"), suffix = c(".treatment", ".control"))` to join object 'results' with our current table. We want to join by treatment and control. We are also including suffixes ".treatment" and ".control" since column `avg.vote` appears twice (once in our current table, once in results), and needs to be differentiated. 

<!-- SZ: Direct? -->

```{r objecttwo-ex-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-7-hint, eval = FALSE}
... %>% 
left_join(results, 
            by = c("control" = "treatment"), 
            suffix = c(".treatment", ".control"))
```

###

<!-- something here  -->

### Exercise 8

Using `mutate` to create the column `ATE` by subtracting the average of control from the average of neighbor. Save your code to 'object_2'
```{r objecttwo-ex-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-8-hint-1, eval = FALSE}
ATE = Subtract the value of avg.vote of control from the avg.vote of treatment
```

```{r objecttwo-ex-8-hint-2, eval = FALSE}
mutate(ATE = avg.vote.treatment - avg.vote.control)
```

###

Notice how there are can be multiple ATEs in one data set. Before, we were finding the ATE of Control and Neighbor, but now we're finding the ATE of each treatment pair. The ATE can be further niched down, such as the ATE of each gender, each age group, etc. You must be specific regarding what ATE you want! 

## Percentage ATE

### 

For our last table, We will investigate whether the causal effect of Neighbors relative to Control is the same for older and younger people. 'Old people' is anyone older than 64.

``` {r}
object_3 <- shaming %>% 
  filter(treatment %in% c("Neighbors", "Control")) %>% 

  # Here, we use an ifelse() statement here to return "old" in the rows where
  # age is 64 # or older, and "young" elsewhere.
  
  mutate(age = ifelse(age > 64, "old", "young")) %>% 

  # Group by treatment AND age here so the avg.percent values are calculated for
  # "old" and "young" separately.
  
  group_by(treatment, age) %>% 
  summarize(avg.perc = mean(primary_06),
            .groups = "drop") %>% 
  pivot_wider(names_from = treatment,
            values_from = avg.perc) %>% 
  mutate(ATE = Neighbors - Control) %>% 
  
  # Using rename() to make the column names less confusing. We want to be specific
  # as possible. Having "Control" or "Neighbors" is too confusing.

  rename(c("control.perc" = Control,
           "neighbors.perc" = Neighbors)) %>% 
  relocate(neighbors.perc, .after = age)

object_3
```


### Exercise 1

Start a pipe with `shaming`. Since we want to compare neighbor and control, let's `filter()` those variables, which are located `%in%` treatment 
```{r objectthree-ex-1, exercise = TRUE}

```

```{r objectthree-ex-1-hint-1, eval = FALSE}
Filter uses %in% and if you want to filter multiple variables, we use c("...","...")
```

```{r objectthree-ex-1-hint-2, eval = FALSE}
shaming %>% 
  filter(treatment %in% c("...", "...") )
```

###

This object will also deal with a causal model. I'd like to emphasize how, ultimately, every model is predictive, since all tables will predict at least one outcome. However, causal models are like a subgroup within predictive models, where we are able to figure out how the outcome the [height of each brother](https://ppbds.github.io/primer/rubin-causal-model.html#preceptor-table) will change depending on various factors such as treatment groups and covarients (ex. sports they played), which can be used to calculate the causal effect. By using only predictive models, we would only able to compare the heights of each brother.... Boring! 

### Exercise 2

Continue the pipe. Use `mutate` to create a column called `age` that tells us whether a person is "young" or "old" by checking if they are over 64 (old) or younger or equal to 64 (young). Within `age`, use `ifelse()` 
```{r objectthree-ex-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objectthree-ex-2-hint-1, eval = FALSE}
if statements contains 3 parts within the function: 
  the criteia, what happens if it returns true, and what happens if it returns false. 
Ex. (ifelse (primary_06 == 1, "they voted", "they did not vote"))

```

```{r objectthree-ex-2-hint-2, eval = FALSE}
... %>% 
mutate(age =ifelse(age > 64, "...", "..."))
```

###

This syntax is different from other programming languages, which usually split up "if" and "else". 

<!-- SZ: Necessary?  -->

### Exercise 3

`group_by` the data using both treatment and age
```{r objectthree-ex-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objectthree-ex-3-hint, eval = FALSE}
... %>% 
  group_by(treatment, age)
```

###

<!-- add 3,4,5  knowedlge stuff... maybe shift bias talk here? -->
<!-- or just split one into severeal sections -->

### Exercise 4

Use `summarize()` to create a new column which contains the mean of primary_06. Set .groups = "drop". 

```{r objectthree-ex-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objectthree-ex-4-hint-1, eval = FALSE}
... %>% 
summarize (avg.perc = mean(...),
            .groups = "drop")
```

```{r objectthree-ex-4-hint-2, eval = FALSE}
... %>% 
summarize (avg.perc = mean(primary_06),
            .groups = "drop")
```

###

<!-- consider putting something about average percentile -->

### Exercise 5

Using `pivot_wider`, clean up your table. Set the `names_from` to treatment, and `values_from` to avg.perc. 
```{r objectthree-ex-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objectthree-ex-5-hint, eval = FALSE}
... %>%   
pivot_wider(names_from = treatment,
            values_from = avg.perc)
```

###

### Exercise 6

Create a new column with `mutate`, which displays the ATE value between the two different treatment types. 
```{r objectthree-ex-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objectthree-ex-6-hint-1, eval = FALSE}
You calculate the ATE by finding the difference between neighbor and control, the two different treatment types.  
```

```{r objectthree-ex-6-hint-2, eval = FALSE}
... %>% 
mutate(ATE = Neighbors - Control)
```
###

Recall [heterogenous treatment effects](https://ppbds.github.io/primer/rubin-causal-model.html#heterogenous-treatment-effects), and how we can only calculate teh ATE due to our assumption that tao, or the treatment effect is constant for every person (which goes back to validity). Unlike the first section where we cared about each person, we just use the ATE as a generalization to understand the effect of the neighbor treatment on a large population. 

### Exercise 7

Use `relocate()` to move the `Neighbors` column to be the column second from the left, after the column `age`. Since we don't want `Neighbors` to be the leftmost column, use `relocate(Neighbors, .after = ...)` and set `.after` equal to the column we want to in front of `Neighbors`.  

<!-- Not direct enough? -->

```{r percentage-ate-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r percentage-ate-7-hint, eval = FALSE}
... %>% 
relocate(Neighbors, .after = age)
```

###

Once again, this decision is solely to make it more organized, due to the ATE calculation. We all love the ATE because it's a) a great frame of reference b) is unbiased, since it is randomly assigned - if you have a large enough sample size, you can be pretty confident in your estimate c) by having an ATE, you'd be able to fill in any values in a Preceptor Table (if necessary). However, we still must remember the ATE is *just* an estimate, and that the actual outcomes can be extremely different, since everyone is `~`unique`~`. 

### Exercise 8

Lastly, use `rename()` to change column 'Control' to 'control.perc' and column 'Neighbors' into 'neighbor.perc'. Save the tibble as object_3. 

```{r objectthree-ex-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objectthree-ex-8-hint-1, eval = FALSE}
... %>% 
rename(c(...))
```

```{r objectthree-ex-8-hint-2, eval = FALSE}
... %>% 
rename(c("control.perc" = Control,
           "neighbors.perc" = Neighbors))
```

###

Using `rename()` makes the column names more specific. Having just "Control" or "Neighbors" is too confusing.


## Visualizing age and ATE 

We will be creating this plot, to see the effect of age on the ATE of treatment 'Neighbor'. 

``` {r}
age_p <- shaming %>% 
  filter(treatment %in% c("Neighbors", "Control")) %>% 
  filter(age < 90) %>% 
  
  # We filter here because there are NA values in ages such as 102 that give us a
  # "missing rows" message when we plot our values. The plot also looks nicer this way.

  group_by(treatment, age) %>% 
  summarize(avg.perc = mean(primary_06),
            .groups = "drop") %>% 

  # Using arrange allows us to see show the rows that have the youngest ages 
  # first.
  
  arrange(age) %>% 
  pivot_wider(names_from = treatment,
              values_from = avg.perc) %>% 
  mutate(ATE = Neighbors - Control) %>% 
  rename(c("control.perc" = Control,
           "neighbors.perc" = Neighbors)) %>% 
  ggplot(aes(x = age, y = ATE)) +
    geom_point() +
    geom_smooth(method = "loess",
                formula = y ~ x) +
  
    # Possibly revisit removing the gray area here because confidence intervals have
    # not been discussed yet.
  
    labs(title = "Effect on Voting of Neighbors Postcard",
        subtitle = "Average treatment effect is lower for the young and the very old",
         y = "Average Treatment Effect",
         x = "Age",
         caption = "Source: Gerber, Green, and Larimer (2008)") +
    theme_bw()

age_p
```

### Exercise 1

Start your pipe with `shaming`. `filter()` the data to only see Control and Neighbors in treatment, using `%in%` as part of the code. 

```{r plot-ex-1, exercise = TRUE}

```

```{r plot-ex-1-hint-1, eval = FALSE}
shaming %>% 
  filter(treatment %in% c("...", "..."))
```

```{r plot-ex-1-hint-2, eval = FALSE}
shaming %>% 
  filter(treatment %in% c("Neighbors", "Control"))
```

###

If instead of including just these two types of `treatment`, we could also exclude them both with the "not" (!) symbol:  `filter(! treatment %in% c("Hawthorne", "...", "..."))`.


### Exercise 2

`group_by()` the data by treatment and age

```{r plot-ex-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r plot-ex-2-hint, eval = FALSE}
... %>% 
group_by(treatment, age)
```

###

Looking back on the data, do you think it is biased? We're trying to find the effect of treatment postcards on Michigan citizens through sampling, and randomly assignment postcards to each citizen, trying to reduce as much bias as possible. Yet, if we inadvertently selected Michigan, or this group due to outside biases, that would ruin everything! This problem, which is part of the assignment mechanism, is called confounding and negatively impacts our ATE since it could *possibly* be biased.  

<!-- Redefine assignment mechanism?  -->

### Exercise 3

Calculate the `avg.perc` of of each age group by finding the mean of primary_06. Create a new column called "avg.perc" using `summarize()` to display the mean. 
```{r plot-ex-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r plot-ex-3-hint, eval = FALSE}
... %>%  
summarize(avg.perc = mean(...),
            .groups = "drop")
```

###

An example of confounding: Imagine that researchers know EXACTLY which houses will react best to each treatment postcard, and their secret objective is to show how postcards will drastically increase the amount of people voting. Thus, they would send those specific postcards to those specific houses to get the best result. Now, the assignment mechanism is no longer random, and introduces a bias called selection bias into the experiment. Yikes. 

### Exercise 4

`arrange()` the data by age. 

```{r shaming-plot-ex-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-plot-ex-4-hint, eval = FALSE}
... %>% 
arrange(age)
```

###

`arrange()` will automatically sorts by ascending. Recall that using `desc()` will sort things in a descending order.

### Exercise 5

Use `pivot_wider` to make the tibble look better. Set `names_from` as treatment and `values_from` to average perc. 
```{r shaming-plot-ex-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-plot-ex-5-hint, eval = FALSE}
... %>% 
pivot_wider(names_from = ...,
              values_from = ...)
```

###

<!-- Causation 1 -->

### Exercise 6

Using `mutate`, create a new column called ATE, which has the ATE of treatment neighbor and control. 

```{r shaming-plot-ex-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-plot-ex-6-hint-1, eval = FALSE}
ATE is calculated from subtracting the treatment group from the control group
```

```{r shaming-plot-ex-6-hint-2, eval = FALSE}
... %>% 
  mutate(ATE = Neighbors - Control)
```

###

<!-- No causation without manipulation  2-->

### Exercise 7

Lets `rename` control to `control.perc`, and neighbors to `neighbor.perc`

```{r shaming-plot-ex-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-plot-ex-7-hint, eval = FALSE}
... %>% 
rename(c("control.perc" = Control,
         "neighbors.perc" = Neighbors))
```

###

Your table should look like this 

```{r}
shaming %>% 
  filter(treatment %in% c("Neighbors", "Control")) %>% 

  # We filter here because there are NA values in ages such as 102 that give us a
  # "missing rows" message when we plot our values. The plot also looks nicer this way.

  group_by(treatment, age) %>% 
  summarize(avg.perc = mean(primary_06),
            .groups = "drop") %>% 

  # Using arrange allows us to see show the rows that have the youngest ages 
  # first.
  
  arrange(age) %>% 
  pivot_wider(names_from = treatment,
              values_from = avg.perc) %>% 
  mutate(ATE = Neighbors - Control) %>% 
  rename(c("control.perc" = Control,
           "neighbors.perc" = Neighbors))
```

### Exercise 8

Using ggplot, create a scatterplot with age on the x axis, and ATE on the y axis. 

```{r shaming-plot-ex-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-plot-ex-8-hint, eval = FALSE}
... %>% 
ggplot(aes(x = ..., y = ...)) +
    geom_point() 
```

###

<!-- Introduce randomization to prevent bias-->

### Exercise 9

Let's add a regression line using `geom_smooth`. Set method to "loess", and formula  to y ~ x 
```{r shaming-plot-ex-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-plot-ex-9-hint, eval = FALSE}
geom_smooth(method = "loess", formula = y ~ x)
```

###

R does automatically set the parameters of method and formula to 'loess' and 'y ~ x' respectively, however it is always nice to add them in. Additionally, this will show our confidence interval, which shows the range of possible ATE values. 

<!-- SZ: Advice for describing confidence interval? -->

### Exercise 10

Adjust the feel of the graph by adding the `theme_bw()`. To finish your plot, use labs() to give the graph a title, subtitle, axes labels, legend heading, and caption.

```{r shaming-plot-ex-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r shaming-plot-ex-10-hint, eval = FALSE}
labs(title = "..."
     ....) +
  theme_bw()
```


Your graph should look like this 

```{r}
shaming %>% 
  filter(treatment %in% c("Neighbors", "Control")) %>% 

  # We filter here because there are NA values in ages such as 102 that give us a
  # "missing rows" message when we plot our values. The plot also looks nicer this way.

  group_by(treatment, age) %>% 
  summarize(avg.perc = mean(primary_06),
            .groups = "drop") %>% 

  # Using arrange allows us to see show the rows that have the youngest ages 
  # first.
  
  arrange(age) %>% 
  pivot_wider(names_from = treatment,
              values_from = avg.perc) %>% 
  mutate(ATE = Neighbors - Control) %>% 
  rename(c("control.perc" = Control,
           "neighbors.perc" = Neighbors)) %>% 
  ggplot(aes(x = age, y = ATE)) +
    geom_point() +
    geom_smooth(method = "loess",
                formula = y ~ x) +
  
    # Possibly revisit removing the gray area here because confidence intervals have
    # not been discussed yet.
  
    labs(title = "Effect on Voting of Neighbors Postcard",
        subtitle = "Average treatment effect is lower for the young and the very old",
         y = "Average Treatment Effect",
         x = "Age",
         caption = "Source: Gerber, Green, and Larimer (2008)") +
    theme_bw()
```

###

However, notice the right hand side of the graph, the graph starts behaving strangely past ~90, and how there are strange messages about missing values that show up. Let's get rid of them.

pr_
### Exercise 11

`filter()` the data so that only people younger than 90 are included in the data. 
```{r age-and-ate-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r age-and-ate-11-hint, eval = FALSE}
... %>% 
filter(age < 90) %>% 
... 
```

###

Although we are reducing the representiveness of this data by removing a part of the population, we unfortunately do not have a large enough sample size (Ex. there is only one person who is 103 years old) to accurately predict the effect of these postcards. There is too much missing data beyond 90.

###

Your graph should look like this
```{r}
age_p
```


WOO NICE! You made it through this tutorial, I'm proud of you buddy :)


```{r download-answers, child = "../../child_documents/download_answers.Rmd"}
```
