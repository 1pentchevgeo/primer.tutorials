---
title: 'Rubin Causal Model: Shaming'
author: Sophia Zhu
tutorial:
  id: rubin-causal-model-shaming
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: Exploring a data set involving attempts to get-out-the-vote in Michigan.
---

```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(primer.data)
library(skimr)
library(gt)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
```

```{r copy-code-chunk, child = "../../child_documents/copy_button.Rmd"}
```

```{r info-section, child = "../../child_documents/info_section.Rmd"}
```

<!-- Add Introduction and Summary sections. -->

<!-- You can't drop knowledge about the line of code. The code is easy! So, drop knowledge about the Chapter. -->

<!-- change exercise numbers -->

<!-- insert ate ramble somwhere -->

## Introduction
###

## Table of outcomes and covariates
### 

The tibble `shaming` from the **primer.data** package includes data from "Social Pressure and Voter Turnout: Evidence from a Large-Scale Field Experiment" ([pdf](https://github.com/PPBDS/primer.data/blob/master/inst/papers/shaming.pdf)) by Gerber, Green, and Larimer (2008). The aim of the study was to explore to what extent people are motivated to vote by social pressure. 

### 

Using the data, we'll be making this `gt` table to find how different treatments and covarients impact whether people vote (primary_06).

```{r}
tibbleone <- tibble(ID = c("1", "3", "10", "48", "51", "68", "198", "323", "875", "338640"),
       ycivic = c("0","?", "?", "?","1", "?", "?","?", "?","?"),
       yhawth = c("?", "1","?", "0", "?","?","?","?", "?","?"),
       yself = c("?","?", "?", "?","?","0","1", "?", "?","?"),
       yneigh = c("?","?", "?", "?","?","?", "?","?", "1","0"),
       ycontrol = c("?", "?","0", "?","?", "?","?", "1", "?", "?"),
       Age = c("65", "55","39", "53", "38 ", "56","46", "56", "47", "72"),
       Sex = c("Male", "Male", "Male", " Male", "Female", 
               "Female", "Female", "Male", "Female", "Male")) %>% 

  
  gt() %>%   
  
    # Adding curly braces { } allows the entire word (i.e. civic, hawth, etc) to
    # be subscript. If we did not use the curly braces, only the first letter
    # would be subscript, which we do not want.
  
    cols_label(ycivic = md("Y<sub>civic</sub>"),
               yhawth = md("Y<sub>hawth</sub>"),
               yself = md("Y<sub>self</sub>"),
               yneigh = md("Y<sub>neigh</sub>"),
               ycontrol = md("Y<sub>control</sub>")) %>% 
    tab_spanner(label = "Outcomes", c(ycivic, yhawth, yself, 
                                         yneigh, ycontrol)) %>% 
    tab_spanner(label = "Covariates", c(Age, Sex))

tibbleone
```

### Exercise 1

Load in libraries **tidyverse**, **gt**, and **skimr**.

```{r table-of-outcomes-an-1, exercise = TRUE}

```

```{r table-of-outcomes-an-1-hint-1, eval = FALSE}

```

### 

The experimenters sent 5 different postcards to 180,000 households (or 180,000 units) in Michigan before the 2006 primary election. They wanted to understand if certain types of messages increase voter turnout. 

<!-- Insert talks about unit here, and how one citizen is a unit for shaming -->

### Exercise 2

Run `glimpse()` into the data set `shaming`.

```{r table-of-outcomes-an-2, exercise = TRUE}

```

```{r table-of-outcomes-an-2-hint-1, eval = FALSE}
glimpse(shaming)
```

### 

The first postcard was named "Civic Duty", contained a letter "to do their civic duty and vote". The second postcard was named "Hawthorne" which contained the same letter, as well as a notice  that they were being studied by researchers. The third postcard "Self" contained everything in the Hawthorn postcard, and added a message which said that every household member would be notified of each others' voting behaviors. The last postcard "Neighbors" would list not only the voting behavior of household members, but also voting records of people nearby. The "Control" group did not receive post cards. 

<!-- reduce? -->

### Exercise 3

Try out `?shaming` to compare it to `glimpse(shaming)`

```{r table-of-outcomes-an-3, exercise = TRUE}

```

```{r table-of-outcomes-an-3-hint-1, eval = FALSE}
?shaming
```

### 

Notice how `?shaming` gives you an explanation of the experiment, and each column! It also introduces the assignment mechanism - the process which decides which unit got treatment postcards and which got control postcards. 

### Exercise 4

Type `tibble(ID = "1")` in order to create the start of the pipe which we will build into the Preceptor Table which we showed you above. The number 1 is the way that we will refer to the first person in the table, since we do not know their name.


```{r table-of-outcomes-an-4, exercise = TRUE}
 
```

For your reference, this is row 1 of the `shaming` data set

``` {r}
shaming %>% 
  slice(1)  
```


```{r table-of-outcomes-an-4-hint-1, eval = FALSE}
tibble(ID = "1")
```

### 

For review, you can find the basics of gt tables [here](https://gt.rstudio.com/articles/intro-creating-gt-tables.html), and by referencing the earlier tutorial.

### Exercise 5

Create another column in your tibble by adding `, ytreat = "0"` after `ID = "1"`.


```{r table-of-outcomes-an-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-5-hint-1, eval = FALSE}
tibble(ID = "1",
       ytreat = "0")

```

### 

ytreat is the column where we input whether or not they voted (primary_06), *if they were apart of one of the treatment groups*, using a 0 or 1. 0 means that they did not vote, while 1 means that they did. However, if person 1 was part of the control group, we would list a "?" in the ytreat column, since we do not know whether they would have voted. 

### Exercise 6

Add a new column named `ycontrol`. Set the value of `ycontrol` to '?'.

```{r table-of-outcomes-an-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-6-hint-1, eval = FALSE}
tibble(ID = ("1"),
       ytreat = "0",
       ycontrol = "?")
```

### 

The ? in the ycontrol column is due to the Fundamental Problem of Causal Inference. Since we are already observing one potential outcome (Person 1 was given a treatment postcard), we can not also see the other potential outcome (Person 1 is given a control postcard), which is why we list it as ?. 

<!-- Insert tao calculate + talk here -->

### Exercise 7

Let's add Person 10 into the tibble. Use `c()` to add more than one number into the column. Notice how this person is apart of the control group. How will this change the entry? 

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-7, exercise = TRUE}

```

For your reference, this is row 10 of `shaming`.
``` {r}
shaming %>% 
  slice(10)
```

```{r table-of-outcomes-an-7-hint-1, eval = FALSE}
Remember to use c("..", "...") if you want to add more than 1 number in each column.
```

```{r table-of-outcomes-an-7-hint-2, eval = FALSE}
tibble(ID = c("1","10"),
       ytreat = c("0", "?"),
       ycontrol = c("?", "0"))
```

### 

Here, we start seeing a key assumption of Population Tables. Consider validity in the context of Preceptor Tables. Do you think the treatments of Person 1 and 10 were exactly the same? What if they saw the postcards on different days or times? Could seeing it on a Monday rather than a Wednesday affect their reaction? At 8AM rather than 8PM? We must assume that the treatments each hosuehold recieves are similar enough to be compared.

<!-- Insert Heterogenous treatment effects talk here + multiple tao-->

### 

Your table should look like this. 
```{r}
tibble(ID = c("1","10"),
       ytreat = c("0", "?"),
       ycontrol = c("?", "0"))
```

### Exercise 8

Expand your tibble by adding Person 313, 875, and 344084. Pipe `gt()` at the end to make it a gt table. 

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-8, exercise = TRUE}

```

For your reference, here are the rows 

``` {r}
shaming %>% 
  mutate(row_number = row_number()) %>% 
  filter(row_number == "323" | row_number == "875" | row_number == "344084") %>% 
  relocate(row_number)
```


```{r table-of-outcomes-an-8-hint-1, eval = FALSE}
`View(shaming)` will let you see all the data.
```

```{r table-of-outcomes-an-8-hint-2, eval = FALSE}
tibble(ID = c("1", "10", "323", "875", "344084"),
       ytreat = c("0", "?", "?", "1", "?"),
       ycontrol= c("?", "0", "1", "?", "1")) %>% 
  gt()
```

### 

`View(shaming)` would have also allowed you to see all the `shaming` data.

### 

Your table should look like this.

```{r}
tibble(ID = c("1", "10", "323", "875", "344084"),
       ytreat = c("0", "?", "?", "1", "?"),
       ycontrol= c("?", "0", "1", "?", "1")) %>% 
  gt()
```

### Exercise 9

Add columns "age" and "sex" to the tibble. Use the data from the table to fill in the rows accordingly.

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-9, exercise = TRUE}

```

Rows of `shaming`, for your reference.
``` {r}
shaming %>% 
  mutate(row_number = row_number()) %>% 
  filter(row_number == "1" | row_number == "10" | row_number == "323" | row_number == "875" | row_number == "344084" ) %>% 
  relocate(row_number)
```


```{r table-of-outcomes-an-9-hint-1, eval = FALSE}
tibble(...., 
       age = c("65","39"), 
       sex = c("Male","Male"))
```

### 

Age and sex are covariants, which are variables which could *possibly* influence whether a person votes. Other examples of covariants include income, race, and whether they voted in the previous election. 

### Exercise 10

We want to replace the column `ytreat` with the four different treated categories: `Civic Duty`, `Hawthorne`, `Self`, and `Neighbors`. Delete column `ytreat` and add column `ycivic` by adding `ycivic = c("0","?","...","...","...")` after column `ID`. Fill in the column with the correct outcomes for each ID.     

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-10, exercise = TRUE}

```

``` {r}
shaming %>% 
  mutate(row_number = row_number()) %>% 
  filter(row_number == "1" | row_number == "10" | row_number == "323" | row_number == "875" | row_number == "344084" ) %>% 
  relocate(row_number)
```

```{r table-of-outcomes-an-10-hint-1, eval = FALSE}
tibble(ID = c("1", "10", "323", "875", "344084"),
       ycivic = c("0", "...","...", "...","..."),
       ycontrol= c("?", "0", "1", "?", "1"), 
       age = c("65", "39", "56", "47", "57"),
       ....

```

```{r table-of-outcomes-an-10-hint-2, eval = FALSE}
Recall, if we don't know the reaction of the person to something, 
we put in a "?", we like have for column `ycontrol` and `ytreat`. 
Love the Fundamental Problem of Causal Inference.
```

```{r table-of-outcomes-an-10-hint-3, eval = FALSE}
tibble(ID = c("1", "10", "323", "875", "344084"),
       ycivic = c("0", "?","?", "?","?"),
       ycontrol= c("?", "0", "1", "?", "1"), 
       age = c("65", "39", "56", "47", "57"),
       ....
```

### 

Going back to the assumptions of Population Tables, we can also consider stability in the context of Preceptor Tables. Stability focuses on how our past data can be used in the future. This data is only for the 2006 primary election, but how can I use it to find out the effect of these postcards in the 2010 primary election? How about right now? Thus, if we use the data, we are forced to assume that the households will behave in a similar way as they did in 2006.   

<!-- Insert talk about stability -->

### Exercise 11

Create column `yhawth` below `ycivic`. Add the corresponding outcomes for each person, like you did for column `ycivic`. 

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-11, exercise = TRUE}

```

``` {r}
shaming %>% 
  mutate(row_number = row_number()) %>% 
  filter(row_number == "1" | row_number == "10" | row_number == "323" | row_number == "875" | row_number == "344084" ) %>% 
  relocate(row_number)
```

```{r table-of-outcomes-an-11-hint-1, eval = FALSE}
tibble(ID = c("1","10", "323", "875", "338640"),
       ycivic = c("0", "?","?", "?","?"),
       yhawth = c("?","?","?", "?","?"),
       ycontrol = c("?","0", "1", "?", "?") ... 
```

### 

We currently only deal with 5 people (or IDs). Think back to the assumption of representiveness, and whether this small sample represent the entire population? This data only represents a small neighborhood in Michigan. Could we use this data for all citizens in Michigan? For everyone in America? By using this data, we are forced to assume that our sample in this data set is large enough to represent a state. 

### Exercise 12

Add columns `yself` and `yneigh` like you did for the other two treatment columns. Add in the respective outcomes. 

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-12, exercise = TRUE}

```

``` {r}
shaming %>% 
  mutate(row_number = row_number()) %>% 
  filter(row_number == "1" | row_number == "10" | row_number == "323" | row_number == "875" | row_number == "344084" ) %>% 
  relocate(row_number)
```

```{r table-of-outcomes-an-12-hint-1, eval = FALSE}
tibble(ID = c("1","10", "323", "875", "338640"),
       ycivic = c("0", "?","?", "?","?"),
       yhawth = c("?","?","?", "?","?"),
       yself = c("?", "?", "?", "?","?"),
       yneigh = c("?", "?", "?", "1","0"),
       ycontrol = c("?","0", "1", "?", "?")
       ....
```

### 

Your table should look something like this
```{r}
tibble(ID = c("1","10", "323", "875", "338640"),
       ycivic = c("0", "?","?", "?","?"),
       yhawth = c("?","?","?", "?","?"),
       yself = c("?", "?", "?", "?","?"),
       yneigh = c("?", "?", "?", "1","0"),
       ycontrol = c("?","0", "1", "?", "?"),
       age = c("65","39", "56", "47", "72"),
       sex = c("Male", "Male", "Male", "Female", "Male")) %>% 

  
  gt()  

```

### Exercise 13

Use `tab_spanner()` to create an overarching subtitle. Within `tab_spanner()`, set `label = "Covariants", c(age, sex)`.

```{r table-of-outcomes-an-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-13-hint-1, eval = FALSE}
The code should be placed after the gt(). Continue the pipe with %>% before adding in your commands, making sure to use c() for ytreat and ycontrol. 
```

```{r table-of-outcomes-an-13-hint-2, eval = FALSE}
tibble(....) %>% 
  gt() %>% 
  tab_spanner(label = "Outcomes", c(ytreat, ...))
```

### 

This allows us to separate the covariants from the outcome data to better organize the data. Think of them as subtitles of the table. 

### 

Your table should look like this
```{r}
tibble(ID = c("1", "10", "323", "875", "344084"),
       ytreat = c("0", "?", "?", "1", "?"),
       ycontrol= c("?", "0", "1", "?", "1"),
       age = c("65", "39", "56", "47", "57"),
       sex = c("Male", "Male", "Male", "Female", "Female")) %>% 
 
   gt() %>% 
     
   tab_spanner(label = "Covariants", c(age, sex))
```

### Exercise 14

Use `tab_spanner()` to create another overarching title. Set `label = "Outcome"`, and include all the treatment columns (ycivic, yhawth, etc.) after the label, like we did with the covariants. 
```{r table-of-outcomes-an-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-14-hint-1, eval = FALSE}
tibble(....) %>% 
  gt() %>% 
  tab_spanner(label = "Covariants", c(age, sex)) %>% 
  tab_spanner(label = "Outcomes", c(..., ...)) 
  
```

```{r table-of-outcomes-an-14-hint-2, eval = FALSE}
tibble(....) %>% 
  gt() %>% 
  tab_spanner(label = "Covariants", c(age, sex)) %>% 
  tab_spanner(label = "Outcomes", c(ycivic, yhawth, yself, ....)) 
  
```

### 

If you want more info on gt functions that help with formatting/style, click [here](https://gt.rstudio.com/reference/index.html). Good looking tables are HOT!


### Exercise 15

Format these variables to look more professional by changing ycivic into $\sf{Y_{civic}}$ using `cols_label()` and HTML (`<sub>` and `</sub>`). The format of this function is:

````
cols_label(columnname = md("inserttext<sub>insertsubscripttext</sub>")
````

Window users may have issues with this function, if it isn't working, feel free to skip this part. 

<!-- More guidance?  -->

```{r table-of-outcomes-an-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-15-hint-1, eval = FALSE}
gt %>%
cols_label(ycivic = md("Y<sub>civic</sub>"),
            yhawth = md("Y<sub>hawth</sub>")
           ....
```

### 

Use `?gt::md` in the console if you want more info about the `md()` function, which helps with converting text into t R Markdown-formatted text. Super useful for things like footnotes, fonts, currency, etc. 

### Exercise 16

Change all the other treatment labels (yhawth, yself, yneigh) in the table to have the same formatting, using `cols_label()`. 

```{r table-of-outcomes-an-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-16-hint-1, eval = FALSE}
cols_label(ycivic = md("Y<sub>civic</sub>"),
               yhawth = md("Y<sub>hawth</sub>"),
               yself = md("Y<sub>self</sub>"),
               yneigh = md("Y<sub>neigh</sub>"),
               ycontrol = md("Y<sub>control</sub>"))
```

### 

`col_label()` can hold multiple columns within it, similar to ID. Although 

````
col_label(ycivic = md("Y<sub>civic</sub>")) %>% 
cols_label(ycontrol = md("Y<sub>control</sub>"))
````

works, you can also do 

````
cols_label(ycivic = md("Y<sub>civic</sub>"),
           yhawth = md("Y<sub>hawth</sub>")) 
````

for efficiency. 


### Exercise 17

Add Person 3, 48, 51, 68 and 198 into the table! Fill in each column as necessary.  

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-17, exercise = TRUE}

```

For your reference, the rows look like this: 

```{r}
shaming %>% 
  mutate(row_number = row_number()) %>% 
  filter(row_number == "3" | row_number == "48" | row_number == "51" | row_number == "68" | row_number == "198") %>% 
  relocate(row_number)
```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-17-hint-1, eval = FALSE}
tibble(ID = c("1", "3", "10", "48", "51", "68", "198", "323", "875", "338640"),
       ycivic = c("0","?", "?", "?","1", "?", "?","?", "?","?"),
       yhawth = c("?", "1","?", "0", "?","?","?","?", "?","?"),
       yself = c("?","?", "?", "?","?","0","1", "?", "?","?"),
       yneigh = c("?","?", "?", "?","?","?", "?","?", "1","0"),
       ycontrol = c("?", "?","0", "?","?", "?","?", "1", "?", "?")....
```

### 

Your table should look like this 
```{r}
tibbleone 
```

### 

You can also add a title using `tab_header()`. I propose the title "WOO! Peer pressure works wonders ;)"

###

This section showed us how to create a Preceptor Table, complete with potential outcomes and covarients. We also learned more about `gt` tables, and how to style/format text within tables. 

Good job!

## Understanding shaming

### Exercise 1

Write a paragraph that explain the shaming experiment in the context of the Rubin Causal Model. The first paragraph should use these terms: “unit,” “treatment,” “outcome,” “potential outcomes,” “casual effect,” “assignment mechanism,” and “heterogeneous treatment effects.” Do not discuss “Preceptor Tables.”  

Hint: Many of these terms are defined in their respective sections in [Chapter 4](https://ppbds.github.io/primer/rubin-causal-model.html) of the Primer. All you really need to do is connect back to the `shaming` experiment. Give examples! 
```{r understanding-shamin-1}
question_text(NULL,
	message = "The shaming experiment consists of dividing the population of Michigan residents who voted in the 2004 general election into five parts. The *units* were Michigan individual voters. Half the residents were assigned to one of 5 possible *treatments*: being mailed one of four post card types or, the *control group*, being mailed nothing. The *assignment mechanism* by which the authors choose who received which post cards was random assignment. Each card contained different messages about voting. The *outcome* variable was voting (1) or not voting (0) in the 2006 primary election. Relative to the control, the largest *causal effect* --- the largest difference between the probability of voting --- was for the 'Neighbors' treatment. The causal effect of sending someone a Neighbors postcard was an increase in 8% in their likelihood of voting relative to what it would have been with no postcard. However, the treatment effect was not the same for all groups in our study population, in other words there were *heterogeneous treatment effects*. For example, the treatment effect was smaller in younger people.",
	answer(NULL,
	correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### Exercise 2

Discuss 'population.' For context, imagine you are running for governor in Indiana 2022, and you are trying to decide if this experiment is relevant to your campaign. Use the terms “representative” and “validity.”

Hint: you may find the [Cardinal Virtues section](https://ppbds.github.io/primer/probability.html#cardinal-virtues) of Chapter 5, or the [Population Table section](https://ppbds.github.io/primer/rubin-causal-model.html#population-table) of Chapter 4 to be useful. Check them out :)

```{r understanding-shamin-2}
question_text(NULL,
	message = "If I was running for governor in Indiana 2022, I would hesitate to use the experimental data. The outcome of the experiment is not relevant to my campaign. That is, it is not *valid* for my purposes. The goal is to win the election, yet the experimental data is about getting people to vote. I do not care if a postcard causes someone to vote who otherwise would not have voted. I want to cause people to vote for me! In addition, the *representativness* of the sample is a concern. The sample includes only Michigan voters, which may not be useful for making inferences about Indiana voters. In other words, the population for the study we have here does not look like the population we would have in 2022.",
	answer(NULL,
	correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

## One ATE

### 

In section 'Table of outcomes and covariates', we examine the different characteristics of a small sample of voters. We are unable to fully understand the effect of the treatment postcards, and figure out whether or not they made a difference in voting.Thus, this section visualizes the effect of treatment `Neighbors` compared to `Control` using the Average Treatment Effect (ATE), which is the average difference in potential outcomes between the treated group and the control group. This number will help us compare how impactful the treatment was.

### 

We will create a tibble which looks like this:

``` {r}
object_1 <- shaming %>% 
  select(treatment, primary_06) %>% 
  filter(treatment %in% c("Neighbors", "Control")) %>% 
  
  # Group by treatment so summarize() does not take the average of all 
  # treatments together, but instead for each individual treatment individually.
  
  group_by(treatment) %>% 
  summarize(vote.perc = mean(primary_06), .groups = "drop")  %>%

  # Use pivot_wider() to have the columns take the name of each treatment. Better
  # to visualize the avg.percent values this way.
  
  pivot_wider(names_from = treatment,
              values_from = vote.perc) %>%
  
  
  # Lastly, creating a column for the ATE values. Note that the tibble is already
  # grouped by treatment so we do not need to do it here.
  
  mutate(ATE = Neighbors - Control) %>% 
  relocate(Neighbors) 
  

object_1
```

### 

The purpose of this tibble is to estimate the ATE to see how the treatment "Neighbor" compares to the control. 

### Exercise 1

Start a new pipe with `shaming` and then `select()` two variables, `treatment` and `primary_06`,

```{r one-ate-1, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-ate-1-hint-1, eval = FALSE}
shaming %>% 
  select(treatment, primary_06)
```

###

Although it is not necessary in this case, there are many [selection helper functions](https://tidyselect.r-lib.org/reference/select_helpers.html) which are useful when working with tibbles with many columns.

 
### Exercise 2

Use `filter()` to keep the rows in which `treatment` has a value of either "Control" or "Neighbors". 

```{r one-ate-2, exercise = TRUE}

```

```{r one-ate-2-hint-1, eval = FALSE}
Use %in% and c()
```

```{r one-ate-2-hint-2, eval = FALSE}
... %>% 
  filter(treatment %in% c("Control", "..."))
```

### 

Be careful about using `==` when you want to check inclusion. For example, `filter(treatment == c("Control", "Neighbors"))` will work, but it is not the recommended approach.

### Exercise 3

Define `vote.perc` as the `mean()` of  `primary_06`. Use `summarize()` to add `avg.percent` to the tibble.

```{r one-ate-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-ate-3-hint-1, eval = FALSE}
... %>%  
  summarize(avg.percent = mean(primary_06))
```

### 

Column `vote.perc` is the percent of people who voted. But we don't want to know the overall percentage. We need the percent of people who voted for each `treatment` type. 


### Exercise 4

Remove the `summarize()` line from the pipe and replace it with `group_by(treatment)` 

```{r one-ate-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-ate-4-hint-1, eval = FALSE}
shaming %>% 
  select(treatment, primary_06) %>% 
  filter(treatment %in% c("Control", "...")) %>% 
  group_by(treatment)
```

###  

We want to `group_by()` treatment, since it takes the average of each treatment type individually. `summarize()`, on the other hand, takes the averages of all treatments together. 

### Exercise 5

Like before, create a column called `vote.perc` using `summarize()`. Set the first input to the `mean()` of `primary_06`, and set `.groups` equal to "drop". 


```{r one-ate-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-ate-5-hint-1, eval = FALSE}
... %>%  
  summarize(avg.percent = mean(primary_06),
           .groups = "drop")
```

### 

You can set `.groups` equal to many other things, such as "keep" and "rowwise".

### Exercise 6

Use `pivot_wider()` to make the table look better. Set `names_from` to `treatment`, and `values_from` to `avg.percent`.

```{r one-ate-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-ate-6-hint-1, eval = FALSE}
... %>% 
  pivot_wider(names_from = ...., 
              values_from = ....)
```

### 

`pivot_wider()` ensures that the table is easier to look at, by displaying all the data in one row, rather than multiple. It has several useful arguments, such as 

````
pivot_wider(names_from = variable, names_sort = TRUE/FALSE)
````

which can sort the column names (By default, the columns will be listed by order of first appearence), or 

````
pivot_wider(names_from = variable, names_glue = "{variable}_{.customvalue}"
````

which can create custom column names. More info [here](https://tidyr.tidyverse.org/reference/pivot_wider.html)

### Exercise 7

Create a new column using `mutate()` called `ATE`, by finding the difference between the treated group and control group. 

```{r one-ate-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-ate-7-hint-1, eval = FALSE}
ATE = Subtract the value of Control from Neighbor
```

```{r one-ate-7-hint-2, eval = FALSE}
... %>% 
  mutate(ATE = Neighbours - Control) 
```

### 

Remember that ATE is the average treatment effect and is the difference between potential outcomes (effect of treatment neighbor vs effect of control). In this tibble, we take the mean of `primary_06`, full of 0 and 1s, and figures out on average, how likely a person is to vote when subjected to treatment `neighbor`, and treatment `control`. 

### Exercise 8

Add `relocate(Neighbors)` to the end of the pipe. Once you're finished, save the tibble to `object_1`.

```{r one-ate-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-ate-8-hint-1, eval = FALSE}
... %>% 
  relocate(Neighbors)
```

### 

`relocate()` is a function that helps move a column to the leftmost position. If you don't want to move a column all the way to the left, you can use `relocate(Neighbors, .before = )` or `relocate(Neighbors, .after = )`. More on this function later. 

###

This tibble helps you see that households that received the `Neighbors` treatment were 8% more likely to vote, compared to those that did not receive a postcard at all. 

Nice work!

## Multiple ATE
### 

Treatment effects can vary.

###

In this section, we build on our previous tibble and show how each 'pair' of treatment compare to each other. We will continue to use ATE as our frame of reference when comparing treatments. This is the table we want to recreate. 

``` {r}
results <- shaming %>% 
  select(treatment, primary_06) %>% 
  group_by(treatment) %>% 
  summarize(avg.vote = mean(primary_06), 
            .groups = "drop")
 
# crossing() and unique() are functions that might be useful. unique() returns a

# the unique values in a vector.

object_2 <- crossing(treatment = shaming$treatment, 
         control = shaming$treatment) %>%
  filter(! treatment==control) %>% 
  left_join(results, by = "treatment") %>% 
  left_join(results, 
            by = c("control" = "treatment"), 
            suffix = c(".col_1", ".col_2")) %>% 
  mutate(ATE = avg.vote.col_1 - avg.vote.col_2) %>% 
  rename(col_1 = treatment) %>% 
  rename(col_2 = control) %>% 
  arrange(desc(ATE))

object_2
```

### Exercise 1

Select columns `treatment` and `primary_06` from data set `shaming`.

```{r multiple-ate-1, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r multiple-ate-1-hint, eval = FALSE}

```

###



### Exercise 1

Start a new pipe with the `shaming` data set. `group_by()` treatment

```{r objecttwo-ex-1, exercise = TRUE}


```

```{r objecttwo-ex-1-hint, eval = FALSE}
shaming %>% 
  group_by(treatment)
```

### 

The object we are currenly making is a causal model, rather than a predictive model. Recall that a predictive model, we only want to *know a outcome*, such $\sf{Y_{u}}$, whereas for a causal model, we want to know the *function of potential outcomes*, such as the ATE.  

### Exercise 2

Use `summarize` with the mean of primary_06, and save it to 'avg_vote'. Set `.groups` to "drop". When finished, save this as object `results`

```{r objecttwo-ex-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-2-hint, eval = FALSE}
... %>% 
  summarize(avg_vote = mean(...), 
            .groups = "drop")

```

### 

A key difference between predictive and causal models is that predictive models only have ONE possible outcome for each person. For example, refer back to the [brother height section](https://ppbds.github.io/primer/rubin-causal-model.html#preceptor-table). The brothers only have one predicted height, and therefore, one outcome. Causal models, on the other hand, have at least two or more outcomes. Currently, we have two 'major' columns (control and treatment), which can be broken down even further (Civic duty, neighbor, etc.), which results in many different possible outcomes. 

<!-- Insert what the results object is used for.  -->

### Exercise 3

Start a new pipe. Using `crossing(treatment = (...), control = (...))`, we want to find all the different possible pairs between treatment types. Set both treatment and control as `shaming$treatment`, allowing us to grab all the treatments. 

<!-- too confusing? -->

```{r objecttwo-ex-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-3-hint-1, eval = FALSE}
... 
crossing(treatment = (...$...), 
         control = (...$...)) 
```

```{r objecttwo-ex-3-hint-2, eval = FALSE}
... %>% 
crossing(treatment = (shaming$treatment), 
         control = (shaming$treatment)) 
```

### 

Notice how row 1 has `Control` in both the treatment and control columns. The same thing happens with `Civic Duty` in row 7, and `Hawthorne` in row 13. Let's change it so that this doesn't happen.

### Exercise 5

`filter()` results so that no entry in the treatment column is the same as an entry in the control column. We can use `!...==...` to symbolize "is not equal". 
```{r objecttwo-ex-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-5-hint-1, eval = FALSE}
... %>%   
filter(! ...==...)
```

```{r objecttwo-ex-5-hint-2, eval = FALSE}
... %>%   
filter(! treatment==control)
```

### 

`!=` is typically the way to symbolize "is not equal to". This also applies to various other languages, such as Python, Java, and C. It comes from the symbol $≠$ in math. 
 
### Exercise 6

Use `left_join()' to join `results` by "treatment".

```{r objecttwo-ex-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-6-hint-1, eval = FALSE}
 ... %>%  
left_join(..., by = "...")

```

```{r objecttwo-ex-6-hint-2, eval = FALSE}
... %>% 
left_join(results, by = "treatment")
```

### 

`left_join()` is create for combining tibbles together. However, if tibbles share a common column name, they will automatically be differentiated by adding suffixes ".x" and ".y" to the end of the name. For example, column "table.x" and "table.y". You can customize this suffix using `suffix()`.  

### Exercise 7

Pipe `left_join(results, by = c("control" = "treatment"), suffix = c(".treatment", ".control"))` to join object 'results' with our current table, and ensure that the columns with the same name are labeled correctly 

```{r objecttwo-ex-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-7-hint, eval = FALSE}
... %>% 
left_join(results, 
            by = c("control" = "treatment"), 
            suffix = c(".treatment", ".control"))
```

### 

<!-- add -->

### Exercise 8

Using `mutate` to create the column `ATE` by subtracting the average of control from the average of neighbor. Save your code to 'object_2'
```{r objecttwo-ex-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-8-hint-1, eval = FALSE}
ATE = Subtract the value of avg.vote of control from the avg.vote of treatment
```

```{r objecttwo-ex-8-hint-2, eval = FALSE}
mutate(ATE = avg.vote.treatment - avg.vote.control)
```

### 

Notice how there are can be multiple ATEs in one data set. Before, we were finding the ATE of Control and Neighbor, but now we're finding the ATE of each treatment pair. The ATE can be further niched down, such as the ATE of each gender, each age group, etc. You must be specific regarding what ATE you want! 

### Exercise 9

The columns `treatment` and `control` don't really any sense anymore. Adjust the column names using `rename()` and the avg.vote suffix within `left_join()`. 

```{r multiple-ate-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r multiple-ate-9-hint, eval = FALSE}
... %>%   
  left_join(results, by = "treatment") %>% 
  left_join(results, 
            by = c("control" = "treatment"), 
            suffix = c("...", "...")) %>% 
  mutate(ATE = avg.vote... - avg.vote....) %>% 
  rename(.... = treatment) %>% 
  ....
```

Feel free to use the original tibble as reference: 

```{r}
object_2
```

###

### Exercise 10

Use `arrange(desc())` to arrange this tibble by ATE in descending order. 

```{r multiple-ate-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r multiple-ate-10-hint, eval = FALSE}
... %>% 
  arrange(desc(ATE))
```

###

In this section, we expanded on the tibble built in section 3, and we can now compare the effects of each treatment 'type' against each other to see the most effective method to get households to vote. Using `arrange()` on column ATE, it shows that treatment `Neighbors` is best for this job. 

###

Treatments effects are not always identical for different people or groups.


## Covariate ATE
### 

For our last tibble, We will investigate whether the ATE of Neighbors and Control is influenced by the covarient `age'. We will separate age via old and young. 'Old' is defined as anyone older than 64, and `young` is anyone 64 or lower.

This is the tibble we will be making.

``` {r}
object_3 <- shaming %>% 
  filter(treatment %in% c("Neighbors", "Control")) %>% 

  # Here, we use an ifelse() statement here to return "old" in the rows where
  # age is 64 # or older, and "young" elsewhere.
  
  mutate(age = ifelse(age > 64, "old", "young")) %>% 

  # Group by treatment AND age here so the avg.percent values are calculated for
  # "old" and "young" separately.
  
  group_by(treatment, age) %>% 
  summarize(avg.perc = mean(primary_06),
            .groups = "drop") %>% 
  pivot_wider(names_from = treatment,
            values_from = avg.perc) %>% 
  mutate(ATE = Neighbors - Control) %>% 
  
  # Using rename() to make the column names less confusing. We want to be specific
  # as possible. Having "Control" or "Neighbors" is too confusing.

  rename("control.perc" = Control,
         "neighbors.perc" = Neighbors) %>% 
  relocate(neighbors.perc, .after = age)

object_3
```


### Exercise 1

Start a pipe with `shaming`. Since we want to compare neighbor and control, let's `filter()` those variables, which are located `%in%` treatment 
```{r percentage-ate-1, exercise = TRUE}

```

```{r percentage-ate-1-hint-1, eval = FALSE}
Filter uses %in% and if you want to filter multiple variables, we use c("...","...")
```

```{r percentage-ate-1-hint-2, eval = FALSE}
shaming %>% 
  filter(treatment %in% c("...", "...") )
```

### 

This object will also deal with a causal model. I'd like to emphasize how, ultimately, every model is predictive, since all tables will predict at least one outcome. However, causal models are more like a subgroup within predictive models. 

### Exercise 2

Continue the pipe. Use `mutate` to create a column called `age` that tells us whether a person is "young" or "old" by checking if they are over 64 (old) or younger or equal to 64 (young). Within `age`, use `ifelse()` 
```{r percentage-ate-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r percentage-ate-2-hint-1, eval = FALSE}
if statements contains 3 parts within the function: 
  the criteia, what happens if it returns true, and what happens if it returns false. 
Ex. (ifelse (primary_06 == 1, "they voted", "they did not vote"))

```

```{r percentage-ate-2-hint-2, eval = FALSE}
... %>% 
mutate(age =ifelse(age > 64, "...", "..."))
```

### 

With causal models, we  we are able to figure out how the outcome the [height of each brother](https://ppbds.github.io/primer/rubin-causal-model.html#preceptor-table) will change depending on various factors such as treatment groups and covarients (ex. sports they played), which can be used to calculate the causal effect. 

### Exercise 3

`group_by` the data using both treatment and age
```{r percentage-ate-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r percentage-ate-3-hint-1, eval = FALSE}
... %>% 
  group_by(treatment, age)
```

### 

By using only predictive models, we would only able to compare the heights of each brother, since these models only have one possible outcome.... Boring! 

### Exercise 4

Use `summarize()` to create a new column which contains the mean of primary_06. Set .groups = "drop". 

```{r percentage-ate-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r percentage-ate-4-hint-1, eval = FALSE}
... %>% 
summarize (avg.perc = mean(...),
            .groups = "drop")
```

```{r percentage-ate-4-hint-2, eval = FALSE}
... %>% 
summarize (avg.perc = mean(primary_06),
            .groups = "drop")
```

### 

<!-- consider putting something about average percentile -->

### Exercise 5

Using `pivot_wider`, clean up your table. Set the `names_from` to treatment, and `values_from` to avg.perc. 
```{r percentage-ate-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r percentage-ate-5-hint-1, eval = FALSE}
... %>%   
pivot_wider(names_from = treatment,
            values_from = avg.perc)
```

### 

### Exercise 6

Create a new column with `mutate`, which displays the ATE value between the two different treatment types. 

```{r percentage-ate-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r percentage-ate-6-hint-1, eval = FALSE}
You calculate the ATE by finding the difference between neighbor and control, the two different treatment types.  
```

```{r percentage-ate-6-hint-2, eval = FALSE}
... %>% 
mutate(ATE = Neighbors - Control)
```

### 

Recall [heterogenous treatment effects](https://ppbds.github.io/primer/rubin-causal-model.html#heterogenous-treatment-effects), and how we can only calculate the ATE due to our assumption that tao, or the treatment effect is constant for every person (which goes back to validity). Unlike the first section where we cared about each person, we just use the ATE as a generalization to understand the effect of the neighbor treatment on a large population. 

### Exercise 7

Use `relocate(Neighbors, .after = ...)` and set `.after` equal to the column we want to in front of `Neighbors`.  

```{r percentage-ate-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r percentage-ate-7-hint-1, eval = FALSE}
... %>% 
relocate(Neighbors, .after = age)
```

### 
By changing `Neighbor` to be the leftmost column, it formats the table to look cleaner, since the way you calculate ATE is Neighbors - Control, rather than Control - Neighbors. Details matter!

### Exercise 8

Lastly, use `rename()` to change column 'Control' to 'control.vote' and column 'Neighbors' into 'neighbor.vote'. Save the tibble as object_3. 

```{r percentage-ate-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r percentage-ate-8-hint-1, eval = FALSE}
... %>% 
rename(...)
```

```{r percentage-ate-8-hint-2, eval = FALSE}
... %>% 
rename("control.vote" = Control,
           "neighbors.vote" = Neighbors)
```

### 

Using `rename()` makes the column names more specific. Having just "Control" or "Neighbors" is too confusing.

###

This table allows us to consider the effect of covarients when calculating ATE. We split up older people and younger people, and found out that older people are much more likely to vote! 


## Visualizing age and ATE 

Building on the previous section, We will be creating this plot to visualize the effect of age on the ATE of treatment 'Neighbor'.

``` {r}
age_p <- shaming %>% 
  filter(treatment %in% c("Neighbors", "Control")) %>% 
  filter(age < 90) %>% 
  
  # We filter here because there are NA values in ages such as 102 that give us a
  # "missing rows" message when we plot our values. The plot also looks nicer this way.

  group_by(treatment, age) %>% 
  summarize(avg.perc = mean(primary_06),
            .groups = "drop") %>% 

  # Using arrange allows us to see show the rows that have the youngest ages 
  # first.
  
  arrange(age) %>% 
  pivot_wider(names_from = treatment,
              values_from = avg.perc) %>% 
  mutate(ATE = Neighbors - Control) %>% 
  rename("control.perc" = Control,
           "neighbors.perc" = Neighbors) %>% 
  ggplot(aes(x = age, y = ATE)) +
    geom_point() +
    geom_smooth(method = "loess",
                formula = y ~ x) +
  
    # Possibly revisit removing the gray area here because confidence intervals have
    # not been discussed yet.
  
    labs(title = "Effect on Voting of Neighbors Postcard",
        subtitle = "Average treatment effect is lower for the young and the very old",
         y = "Average Treatment Effect",
         x = "Age",
         caption = "Source: Gerber, Green, and Larimer (2008)") +
    theme_bw()

age_p
```

### Exercise 1

Start your pipe with `shaming`. `filter()` the data to only see Control and Neighbors in treatment, using `%in%` as part of the code. 

```{r visualizing-age-and--1, exercise = TRUE}

```

```{r visualizing-age-and--1-hint-1, eval = FALSE}
shaming %>% 
  filter(treatment %in% c("...", "..."))
```

```{r visualizing-age-and--1-hint-2, eval = FALSE}
shaming %>% 
  filter(treatment %in% c("Neighbors", "Control"))
```

### 

If instead of including just these two types of `treatment`, we could also exclude them both with the "not" (!) symbol:  `filter(! treatment %in% c("Hawthorne", "...", "..."))`.


### Exercise 2

`group_by()` the data by treatment and age

```{r visualizing-age-and--2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--2-hint-1, eval = FALSE}
... %>% 
group_by(treatment, age)
```

### 

Looking back on the data, do you think it is biased? We're trying to find the effect of treatment postcards on Michigan citizens through sampling, and randomly assignment postcards to each citizen, trying to reduce as much bias as possible. Yet, if we inadvertently selected Michigan, or this group due to outside biases, that would ruin everything! This problem, which is part of the assignment mechanism, is called confounding and negatively impacts our ATE since it could *possibly* be biased.  

<!-- Redefine assignment mechanism?  -->

### Exercise 3

Calculate the `avg.perc` of of each age group by finding the mean of primary_06. Create a new column called "avg.perc" using `summarize()` to display the mean. 
```{r visualizing-age-and--3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--3-hint-1, eval = FALSE}
... %>%  
summarize(avg.perc = mean(...),
            .groups = "drop")
```

### 

An example of confounding: Imagine that researchers know EXACTLY which houses will react best to each treatment postcard, and their secret objective is to show how postcards will drastically increase the amount of people voting. Thus, they would send those specific postcards to those specific houses to get the best result. Now, the assignment mechanism is no longer random, and introduces a bias called selection bias into the experiment. Yikes. 

### Exercise 4

`arrange()` the data by age. 

```{r visualizing-age-and--4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--4-hint-1, eval = FALSE}
... %>% 
arrange(age)
```

### 

`arrange()` will automatically sorts by ascending. Recall that using `desc()` will sort things in a descending order.

### Exercise 5

Use `pivot_wider` to make the tibble look better. Set `names_from` as treatment and `values_from` to average perc. 

```{r visualizing-age-and--5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--5-hint-1, eval = FALSE}
... %>% 
pivot_wider(names_from = ...,
              values_from = ...)
```

### 

<!-- Causation 1 -->

### Exercise 6

Using `mutate`, create a new column called ATE, which has the ATE of treatment neighbor and control. 

```{r visualizing-age-and--6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--6-hint-1, eval = FALSE}
ATE is calculated from subtracting the treatment group from the control group
```

```{r visualizing-age-and--6-hint-2, eval = FALSE}
... %>% 
  mutate(ATE = Neighbors - Control)
```

### 

<!-- No causation without manipulation  2-->

### Exercise 7

Lets `rename` control to `control.perc`, and neighbors to `neighbor.perc`

```{r visualizing-age-and--7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--7-hint-1, eval = FALSE}
... %>% 
rename("control.perc" = Control,
         "neighbors.perc" = Neighbors)
```

### 

Your table should look like this 

```{r}
shaming %>% 
  filter(treatment %in% c("Neighbors", "Control")) %>% 

  # We filter here because there are NA values in ages such as 102 that give us a
  # "missing rows" message when we plot our values. The plot also looks nicer this way.

  group_by(treatment, age) %>% 
  summarize(avg.perc = mean(primary_06),
            .groups = "drop") %>% 

  # Using arrange allows us to see show the rows that have the youngest ages 
  # first.
  
  arrange(age) %>% 
  pivot_wider(names_from = treatment,
              values_from = avg.perc) %>% 
  mutate(ATE = Neighbors - Control) %>% 
  rename("control.perc" = Control,
           "neighbors.perc" = Neighbors)
```

### Exercise 8

Using ggplot, create a scatterplot with age on the x axis, and ATE on the y axis. 

```{r visualizing-age-and--8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--8-hint-1, eval = FALSE}
... %>% 
ggplot(aes(x = ..., y = ...)) +
    geom_point() 
```

### 

<!-- Introduce randomization to prevent bias-->

### Exercise 9

Let's add a regression line using `geom_smooth`. Set method to "loess", and formula  to y ~ x 
```{r visualizing-age-and--9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--9-hint-1, eval = FALSE}
geom_smooth(method = "loess", formula = y ~ x)
```

### 

R does automatically set the parameters of method and formula to 'loess' and 'y ~ x' respectively, however it is always nice to add them in. Additionally, this will show our confidence interval, which shows the range of possible ATE values on the graph. 

<!-- SZ: Advice for describing confidence interval? -->

### Exercise 10

Adjust the feel of the graph by adding the `theme_bw()`. To finish your plot, use labs() to give the graph a title, subtitle, axes labels, legend heading, and caption.

```{r visualizing-age-and--10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--10-hint-1, eval = FALSE}
labs(title = "..."
     ....) +
  theme_bw()
```

Your graph should look like this 

```{r}
shaming %>% 
  filter(treatment %in% c("Neighbors", "Control")) %>% 

  # We filter here because there are NA values in ages such as 102 that give us a
  # "missing rows" message when we plot our values. The plot also looks nicer this way.

  group_by(treatment, age) %>% 
  summarize(avg.perc = mean(primary_06),
            .groups = "drop") %>% 

  # Using arrange allows us to see show the rows that have the youngest ages 
  # first.
  
  arrange(age) %>% 
  pivot_wider(names_from = treatment,
              values_from = avg.perc) %>% 
  mutate(ATE = Neighbors - Control) %>% 
  rename("control.perc" = Control,
           "neighbors.perc" = Neighbors) %>% 
  ggplot(aes(x = age, y = ATE)) +
    geom_point() +
    geom_smooth(method = "loess",
                formula = y ~ x) +
  
    # Possibly revisit removing the gray area here because confidence intervals have
    # not been discussed yet.
  
    labs(title = "Effect on Voting of Neighbors Postcard",
        subtitle = "Average treatment effect is lower for the young and the very old",
         y = "Average Treatment Effect",
         x = "Age",
         caption = "Source: Gerber, Green, and Larimer (2008)") +
    theme_bw()
```

### 

However, notice the right hand side of the graph, the graph starts behaving strangely past ~90, and how there are strange messages about missing values that show up. Let's get rid of them.

pr_

### Exercise 11

`filter()` the data so that only people younger than 90 are included in the data. 

```{r visualizing-age-and--11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--11-hint-1, eval = FALSE}
... %>% 
filter(age < 90) %>% 
... 
```

### 

Although we are reducing the representiveness of this data by removing a part of the population, we unfortunately do not have a large enough sample size (Ex. there is only one person who is 103 years old) to accurately predict the effect of these postcards. There is too much missing data beyond 90.

### 

Your graph should look like this
```{r}
age_p
```

Throughout this tutorial, you've learned how to manually create Preceptor Tables in `gt`, while also dealing with ATE in various tibbles. We ended off by creating a graph to see the effects of covarients on ATE! 

WOOOO! You made it, I'm proud of you buddy :)


## Summary
###

<!-- Fundamental problem. Potential outcomes. Causal effects. Heterogenous treament effects. -->

```{r download-answers, child = "../../child_documents/download_answers.Rmd"}
```
