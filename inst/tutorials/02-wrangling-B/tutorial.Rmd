---
title: "Wrangling B"
tutorial:
  id: "wrangling-b"
output:
  learnr::tutorial:
      progressive: true
      allow_skip: true
runtime: shiny_prerendered
description: "Chapter 2 Tutorial -- Part A"
---

<!-- BG: need more questions under Characters about using ^ and $ -->


```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(lubridate)
library(stringr)
library(skimr)
library(ranger)
library(primer.data)
library(nycflights13)

# Key Data

cces_filt <- cces %>%
  filter(ideology %in% c("Conservative", "Not Sure", 
                        "Moderate", "Liberal"))

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 



```


## Information
###

```{r information}
quiz(caption = "",
  question_text(
    "Name:",
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL),
  question_text(
    "Email:",
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL))
```


## Characters 
###

A string is one or more characters that are enclosed inside a pair of matching 'single' or "double quotes". We will now use various functions to manipulate strings

### Exercise 1

Type `state.name` into the code chunk below to inspect a character vector that contains the names of all US states.

```{r exercise-2-1, exercise = TRUE}

```

```{r exercise-2-1-hint, eval = FALSE}
Type `state.name` and press Run Code
```

### Exercise 2

Use `str_detect()` on `state.name` to create a vector which will be TRUE for states which contain the pattern "ana" and FALSE otherwise.

```{r exercise-2-2, exercise = TRUE}

```

```{r exercise-2-2-hint, eval = FALSE}
str_detect(..., pattern = ...)
```

### Exercise 3

Great. Now use  `str_detect()` on `state.name` to create a vector which will be TRUE for states which contain the pattern "do" and FALSE otherwise.

```{r exercise-2-22, exercise = TRUE}

```

```{r exercise-2-22-hint, eval = FALSE}
Your code should look similar to the previous question, only changing what the pattern argument is set to.
```

### Exercise 4

Count the characters in `state.name` using `str_length()`. 

```{r exercise-2-15, exercise = TRUE}

```

```{r exercise-2-15-hint, eval = FALSE}
str_length(...)
```

### Exercise 5

Great. Now use `str_sub` to create a character vector that contains only the first three letters of each state.

```{r exercise-2-6, exercise = TRUE}

```

```{r exercise-2-6-hint, eval = FALSE}
str_sub(state.name, 1, 3)
```

### Exercise 6

Collapse `state.name` using `str_c()`. Separate them with a comma that is followed by a whitespace. This should create a single character object with all the states.

```{r exercise-2-7, exercise = TRUE}

```

```{r exercise-2-7-hint, eval = FALSE}
str_c(..., collapse = ", ")
```

### Exercise 7

Use `str_replace()` to replace the pattern `North` with `N.`. For example, transform North Carolina into N. Carolina.

```{r exercise-2-9, exercise = TRUE}

```

```{r exercise-2-9-hint, eval = FALSE}
str_replace(..., pattern = ..., replacement = "...")
```


## Factors 
###

Factors are categorical variables that may only take on a specified set of values. 

### Exercise 1

Use `select()` to look at the `ideology` variable of the `cces` data set. 

```{r factors-1, exercise = TRUE}

```

### Exercise 2

Use `str()` with the argument `cces$ideology`. Then on the line below, use `levels()` with the same argument. 

```{r factors-3, exercise = TRUE}

```

### Exercise 3

Let's now get a frequency table as a tibble. Use `fct_count()` with the argument `cces$ideology`.

```{r factors-4, exercise = TRUE}

```


```{r factors-4-hint, eval = FALSE}
fct_count(...)
```

### Exercise 4

Now use `nlevels()` with the argument `cces$ideology` to find the number of existing levels.

```{r factors-5, exercise = TRUE}

```

```{r factors-5-hint-1, eval = FALSE}

```

### Exercise 5

Now `filter()` `cces` to to only a few ideologies: `Conservative` , `Moderate`, `Liberal` and `Not Sure`. Save your work to an object named `cces_filt`.

```{r factors-6, exercise = TRUE}

```

```{r factors-6-hint-1, eval = FALSE}
Use in %>%  and c() within filter(). Within c(), the ideologies need quotes. 
```

```{r factors-6-hint-2, eval = FALSE}
cces_filt <- cces %>%
  filter(... %in% c(..., ..., ..., ...))
```

### Exercise 6

Now use `nlevels()` with the argument `cces_filt`. Notice that the same number of levels pop up.

```{r factors-7, exercise = TRUE}

```

```{r factors-7-hint, eval = FALSE}
nlevels(...)
```

### Exercise 7

Let's drop all the unused levels. Start your code with `cces_filt` and use `%>%` to add the function `droplevels()`. Then on the line below, use `nlevels()` once gain to see how many levels exist. Notice the difference?


```{r factors-8, exercise = TRUE}

```

```{r factors-8-hint-1, eval = FALSE}
Use the argument cces_filt inside nlevels()
```

```{r factors-8-hint-2, eval = FALSE}
cces_filt %>% 
  droplevels()
nlevels(...)
```

### Exercise 8

Now try ordering the levels of `cces$ideology` by frequency. Use ` %>% ` to add the function `fct_infreq()`. Then on the line below, use `levels()` to display the levels by frequency.

```{r factors-9, exercise = TRUE}

```


## Lists
###

A list is the object which contains various data types such as logicals, integers, characters, and even another list!


### Exercise 1

Create a list with three items `a`, `b`, and `c`. Let `a` be a vector containing 1, 2, and 3. Let `b` be a vector containing 4, 5, and 6, and let `c` be a vector containing 7, 8, and 9. Assign your list to an object named `my_list`.


```{r lists-1, exercise = TRUE}

```

```{r lists-1-hint, eval = FALSE}
Use the c() function to create the individual vectors for a, b, and c. 
Use the assignment operator, <- , to save your values to an object.
```

### Exercise 2

Now, call `str()` on `mylist`. 

```{r lists-2-setup}
mylist <- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))
```

```{r lists-2, exercise = TRUE}

```

### Exercise 3

Let's now extract a single component `a` from `mylist` using `[ ]`.

```{r lists-4-setup}
mylist <- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))
```

```{r lists-4, exercise = TRUE}

```

```{r lists-4-hint-1, eval = FALSE}
You need to use " " because a is a character.
str(...[" "])
```

### Exercise 4

Now, extract the number 5 from `mylist` using `[ ]`.

```{r lists-5-setup}
mylist <- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))
```

```{r lists-5, exercise = TRUE}

```

```{r lists-5-hint-1, eval = FALSE}
str(...[ ])
```



## Combining Data
###

Bringing together data from different sources is one of the most common data science tasks. 


### Exercise 1

Inspect the dataset `band_instruments` by typing its name below and hitting Run Code.

```{r exercise-combining-1, exercise = TRUE}

```

```{r exercise-combining-1-hint, eval = FALSE}
band_instruments
```

### Exercise 2

Run the code to look at the following data frames.

```{r question-combining-3, exercise = TRUE}
band_instruments
band_instruments2
band_members
```

Consider the discrepancy between the columns of `band_instruments2` and the columns of both `band_members` and `band_instruments`. Predict, in your head, what will happen when binding the rows of the two tibbles.


### Exercise 3

Use `bind_rows()` to combine the two data frames `band_instruments2` and `band_members`.

```{r question-combining-5, exercise = TRUE}


```

```{r question-combining-5-hint, eval = FALSE}
bind_rows(band_instruments2, ...)
```

This is, probably, not what we want.

### Exercise 4

Use the extraction operator `$` on the `plays` column of `band_instruments`.

```{r question-combining-11, exercise = TRUE}

```

```{r question-combining-11-hint, eval = FALSE}
band_instruments$...
```

### Exercise 5

Now use `inner_join()` with the `band_instruments` and `band_instruments2` tibbles with the `by` argument set to "plays". 

```{r question-combining-13, exercise = TRUE}

```

```{r question-combining-13-hint, eval = FALSE}
inner_join(..., ..., by = ...)
```

The fact that one tibble uses the word "name" and the other "artist" for the same thing causes trouble when we try to bring the data together.

### Exercise 6

Let's focus on the `band_members` and `band_instruments` tibbles for the remaining questions in this session. Always try to predict, in your head, what result a given join function will produce before you run in.

Use `left_join()` with `band_members` as the first argument and `band_instruments` as the second.

```{r, cd-ex-6, exercise = TRUE}

```

```{r, cd-ex-6-hint, eval = FALSE}
left_join(band_members, ...)
```

Your results should look like this:

```{r}
left_join(band_members, band_instruments)
```

Note how Keith disappears because he does not appear in `band_members`. Note how what Mick plays is NA because there is no corresponding row in band_instruments.

### Exercise 7

Use `left_join()` with `band_instruments` as the first argument and `band_members` as the second.

```{r, cd-ex-7, exercise = TRUE}

```

```{r, cd-ex-7-hint, eval = FALSE}
left_join(band_instruments, ...)
```

Your results should look like this:

```{r}
left_join(band_instruments, band_members)
```

Keith is back but John has disappeared. Whenever we use `left_join()`, the rows kept are determined by the first tibble.

<!-- DK: Could do some more. -->

## Date-Times 
###

Let's practice using some functions that work with date and time.

### Exercise 1

Run the `today()` and `now()` functions below.

```{r dttm-1, exercise = TRUE}

```

### Exercise 2

Now use the function `ymd()` to convert the string below into the proper date-time format. 

```{r dttm-2, exercise = TRUE}
date_1 <- "2020-2-29"
```

### Exercise 3

Now create a date-time by adding an underscore then “h,” “m,” and “s” to the name of the `ymd()` parsing function.

```{r dt-3, exercise = TRUE}
date_2 <- "2017-01-31 20:11:59"

```

```{r dt-3-hint, eval = FALSE}
Use the function ymd_hms() with the argument date_2.
```


### Exercise 4

The following code below selects time-related data from the `flights` dataset. Use `mutate()` to create a new variable `arrival`. `arrival` should be set to the function `make_datetime()` with all selected variables as its argument.

```{r dttm-3, exercise = TRUE}
flights %>% 
  select(year, month, day, hour, minute)
```

```{r dttm-3-hint, eval = FALSE}
flights %>% 
  select(year, month, day, hour, minute) %>% 
  mutate(... = make_datetime(year, ...,...,..., ...))
```


## Tidying Data
###

For a dataset to be tidy, each variable must have its own column, each observation must have its own row, and each value must have its own cell.

### Exercise 1

Run `relig_income` in the code chunk below. Notice how wide it is.

```{r tidy-5, exercise = TRUE}

```

### Exercise 3

You can use the `pivot_longer()` to convert wide data to long data. Let's use the `pivot_longer` to tidy the `relig_income` data. Pivot all columns except for the `cols` to everything but the `religion` column. Set `names_to` to "income" and`values_to` to "count". 

```{r tidy-7, exercise = TRUE}

```

```{r tidy-7-hint-1, eval = FALSE}
Consider using - to select the columns you want to pivot
```

```{r tidy-7-hint-2, eval = FALSE}
relig_income %>% 
  pivot_longer(cols = -religion,
               names_to = ...,
               values_to = ...)
```

### Exercise 4

Let's now look at the `us_rent_income` data set. Call the data set below. 

```{r tidy-ee, exercise = TRUE}

```

```{r tidy-ee-hint, eval = FALSE}

```

### Exercise 5

You can "spread" the keys in a key column across their own set of columns with the `pivot_wider()`. Use `pivot_wider()` to tidy the `us_rent_income` data. Set `names_from` to `variable` and set `values_from`  to `c(estimate, moe))`.


```{r tidy-12, exercise = TRUE}

```

```{r tidy-12-hint, eval = FALSE}
... %>% 
  pivot_wider(names_from = ..., 
              values_from = ...)
```

## Submit

```{r context="setup"}
submission_ui
```

```{r context="server"}
submission_server()
```

