---
title: "Visualization-A"
tutorial:
  id: "01-visualization-a"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: "Chapter 1 Tutorial Part A"
---


```{r setup, include = FALSE}
library(tidyverse)
library(primer.tutorials)
library(primer.data)
library(learnr)



knitr::opts_chunk$set(echo = FALSE, message = FALSE)
options(tutorial.exercise.timelimit = 60, tutorial.storage="local")  
```


## Name

``` {r name}
question_text(
  "Student Name:",
  answer(NULL, correct = TRUE),
  allow_retry = TRUE,
  try_again_button = "Modify your answer",
  incorrect = "Ok"
)
```


## Email

``` {r email}
question_text(
  "Email:",
  answer(NULL, correct = TRUE),
  allow_retry = TRUE,
  try_again_button = "Modify your answer",
  incorrect = "Ok"
)
```


## How do I code in R?
###


### Exercise 1

Let's get started by loading the packages we need to code. In the code chunk below, use the function `library()` to load the `tidyverse` package. Recall that whenever you load a package R will also load all of the packages that the first package depends on.

```{r packages, exercise = TRUE}

```

```{r packages-hint, eval = FALSE}
library(...)
```

### Exercise 2

If you are ever stuck while coding, R has **help pages**  which give us access to the documentation pages for R functions, data sets, and other objects. 

Let's say we want to know what the function `sqrt()` does. Open the help page for `sqrt()` by typing `?sqrt()` below.

```{r functions-2, exercise = TRUE}
?sqrt()
```

### Exercise 3

**Code comments** are text placed after a `#` symbol. Nothing will be run after a `#` symbol, which is useful if you want to write human readable comments in your code..

Press Run Code. Afterwards, delete the `#` and re-run the chunk. You should see a result.

```{r functions-5, exercise = TRUE}
# sqrt(144)
```

###

**Objects*** are where values are saved in R. This way, the same code does not need to be written out each time. Instead, we can simply type the name of the object. You can choose almost any name you like for an object, as long as the name does not begin with a number or a special character like `+`, `*`, `-`, `/`, `^`, `!`, `@`, or `&`. 

### Exercise 4

Let's save the values of `sqrt(144)` to an object named `results`. Remember to use the assignment operator `<-`. 

```{r objects-2, exercise=TRUE}

```

```{r objects-2-hint, eval = FALSE}
results <- sqrt(144)
```

### Exercise 5

What do you think would happen if you assigned `results` to a new object named `results2`, like this? Run the code and then inspect both `results` and `results2` by typing their names, one at a time. 

```{r objects-3, exercise=TRUE}
results <- sqrt(144)
results2 <- results

```


### Exercise 6

A **vector** is a series of values that are created using the `c()` function. Create a vector that contains the integers from one to ten.

```{r vectors-1, exercise = TRUE}

```

```{r vectors-1-hint, eval=FALSE}
Type the values 1-10 inside the function c().
```

### Exercise 7

If your vector contains a sequence of contiguous integers, you can create it with the `:` shortcut. Run `1:10` in the chunk below.

```{r vectors-2, exercise = TRUE}

```

### Exercise 8

You can extract any element of a vector by placing a pair of brackets `[ ]` behind the vector. Inside the brackets, place the number of the element that you'd like to extract. For example, `vec[3]` would return the third element of the vector named `vec`.

The code below assigns a vector to an object named `vec`. Use the chunk below to extract the fourth element of `vec`.

```{r vectors-3, exercise = TRUE}
vec <- c(1, 2, 4, 8, 16)
```

```{r vectors-3-hint, eval = FALSE}
vec[...]
```

### Exercise 10

You can also use `[ ]` to extract multiple elements of a vector. Place the vector `c(1,2,5)` between the brackets below. What does R return?

```{r vectors-4, exercise = TRUE}
vec <- c(1, 2, 4, 8, 16)
vec[]
```

### Exercise 11

If the elements inside your vector have names, you can extract them by name. To do so, place a name or vector of names in the brackets behind a vector. Surround each name with quotation marks, e.g. `vec2[c("alpha", "beta")]`.

Below the given code, extract the element named "gamma" from the vector below.

```{r vectors-5, exercise = TRUE}
vec2 <- c(alpha = 1, beta = 2, gamma = 3)
```

```{r vectors-5-hint, eval = FALSE}
Make sure to use quotation marks inside the brackets such as vec2["..."]
```



## Exploring Data Frames

Data frames, also referred to as "tibbles", are spreadsheet-type data sets. It's always a good idea to explore the data before you use it.  

### Exercise 1

R comes with many toy **data sets** to explore. Let's examine the contents of `iris` data set. Type `trains` in the line below.

```{r objects-4, exercise = TRUE}

```

### Exercise 2

Now use `glimpse()` to look at the `trains` data set.

```{r exercise-4, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-4-hint, eval = FALSE}
Type trains inside the glimpse() function.
```

### Exercise 3

Data frames can be created using `tibble()`. Below the given code, assemble the vectors below into a data frame using `tibble()`with the column names `numbers`, `logicals`, `strings`.

```{r lists4, exercise = TRUE}
nums <- c(1, 2, 3, 4)
logs <- c(TRUE, TRUE, FALSE, TRUE)
strs <- c("apple", "banana", "carrot", "duck")
```

```{r lists4-hint-2, eval = FALSE}
tibble(nums ="...", logs = "...", strs = "...")
```

### Exercise 4

As you can see, when we use the `tibble()` function, we can see the tibble. However, when we assign the tibble to an object, we do not see the actual tibble. That is because we are just running the code to assign the values. 

Run the code below. Notice nothing prints out for us to see.

```{r diff-tibble, exercise = TRUE}
data_f <- tibble(nums, logs, strs)
```

### Exercise 5

After you assign values to an object, you must type the name of the object to actually see results. Now run the code below. Notice that we can now see results.

```{r diff-2, exercise = TRUE}
data_f <- tibble(nums, logs, strs)
data_f
```

### Exercise 6

Let's now extract the `strings` column of the `data_f` data frame using the `$` operator.

```{r lists5, exercise = TRUE}
nums <- c(1, 2, 3, 4)
logs <- c(TRUE, TRUE, FALSE, TRUE)
strs <- c("apple", "banana", "carrot", "duck")
data_f <- tibble(numbers = nums, logicals = logs, strings = strs)
```



## `geom_point` 

Scatterplots allow you to visualize the relationship between two numerical variables. 

Let's create the following scatterplot. 

```{r scat-p}
scat_p <- ggplot(data = qscores, 
                 mapping = aes(x = rating, 
                               y = hours, 
                              size = enrollment)) +
                 geom_point()

scat_p
```


### Exercise 1

Let's first `view()` the data set used above called `qscores`.

```{r exercise-6, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-6-hint, eval=FALSE}
view(...)

```

### Exercise 2

Within `ggplot()`, set `data` to `qscores`. Also, map `rating` to the x-axis and `hours` to the y-axis. Add the layer `geom_point()`.

```{r exercise-7, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-7-hint-1, eval = FALSE}
Remember when you add a layer you use +. 
```

```{r exercise-7-hint-2, eval=FALSE}
ggplot(data = qscores, 
       mapping = aes(x = ..., 
                     y = ...)) + 
    geom_point()
```

### Exercise 3

Awesome! Now we want to add a `size` aesthetic based on the number of students enrolled in each course. Set the argument `size` to `enrollment` inside the `aes()` function.

```{r exercise-8, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-8-hint, eval=FALSE}
ggplot(data = qscores, 
       mapping = aes(x = rating, 
                     y = hours, 
                     size = ...)) 
```

Reminder: This is what our graph should look like.

```{r}
scat_p
```

### Exercise 4

Sometimes graphs have overplotting. The following code uses the `mpg` tibble to create a scatterplot that displays 126 points. However, it visualizes a data set that contains 234 points. The missing points are hidden behind other points.

Run the code below to see the scatterplot. 

```{r indiv, exercise = TRUE, out.width = "80%"}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point()
```

### Exercise 5

One method to fight overplotting is to make each point **semi-transparent**. The code chunk below provides the code used to create the graph above. Change the transparency of the points by setting `alpha = 0.2` within `geom_point()`.

```{r exercise-9, exercise = TRUE, exercise.lines = 5}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point()
```

```{r exercise-9-hint, eval=FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point(alpha = ...)
```



##`geom_jitter()` 

We can also use `geom_jitter()` to fight overplotting. It plots a scatterplot and then adds a small amount of random noise to each point in the plot. 


### Exercise 1

Run the code below that creates a scatterplot with overplotting. 

```{r indiv2, exercise= TRUE}
ggplot(data = trains, mapping = aes(x = att_start, y = att_end)) +
  geom_point()
```

### Exercise 2

Let's now replace `geom_point()` with `geom_jitter()`. 

```{r jit-I-1, exercise = TRUE}
ggplot(data = trains, mapping = aes(x = att_start, y = att_end)) + geom_point()
```

```{r jit-I-1-hint, eval = FALSE}
ggplot(data = trains, mapping = aes(x = att_start, y = att_end)) +
  geom_jitter()

```

### Exercise 3

Set the `width` to `.2` within `geom_jitter()` to adjust the amount the points are jittered.

```{r jit-I-3, exercise= TRUE}

```

```{r jit-I-3-hint, eval = FALSE}
ggplot(data = trains, mapping = aes(x = att_start, y = att_end)) +
  geom_jitter(width = ...)

```

### Exercise 4

Within `aes()`, set the `color` aesthetic to the `party` variable. 

```{r jit-I-4, exercise=TRUE, exercise.lines=6}

```


```{r jit-I-4-hint, eval=FALSE}
ggplot(data = trains, mapping = aes(x = att_start, y = att_end, color = ...)) +
  geom_jitter(width = .2)
```

### Exercise 5

As a final exercise, use what you've learned to recreate the plot below. The graph was created using the data set `diamonds`. The `alpha` of the plot is 0.2, and the `width` of the jitter distribution is 5. Use the `labs()` function to add the titles.

```{r}
ggplot(data = diamonds, mapping = aes(x = depth, y = price)) +
  geom_jitter(width = 5, alpha = 0.2) +
  labs(title = "Depth and Price in Diamonds",
       x = "Depth",
       y = "Price")
```

```{r gj-1-5, exercise=TRUE, exercise.lines = 5}

```

```{r gj-1-5-hint, eval=FALSE}
ggplot(data = diamonds, mapping = aes(x = ..., y = ...)) +
  geom_jitter(width = ..., alpha = ...) +
  labs(title = "...",
       x = "...",
       y = "...")
```

## ` geom_histogram()` 

A histogram is a plot that visualizes the distribution of a numerical variable. 

Let's create the following histogram.

```{r}
hist_p <- ggplot(data = qscores, 
                 mapping = aes(x = rating)) +
        geom_histogram(binwidth = 1, 
                       color = "white", 
                       fill = "red4", 
                       bins = 10)

hist_p
```

### Exercise 1

Within `ggplot()`, set `data` to `qscores`. Map `rating` to the x-axis to see the distribution of Harvard course ratings.

```{r exercise-12, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-12-hint, eval=FALSE}
ggplot(data = ..., 
       mapping = aes(x = ...)) + 
  ...
```

### Exercise 2

Add white vertical borders demarcating the bins by adding `color = "white"` and `fill = "red4"` arguments to `geom_histogram()`.

```{r exercise-13, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-13-hint, eval=FALSE}
ggplot(data = qscores, 
       mapping = aes(x = rating)) +
  geom_histogram(color = ..., 
                 fill = ...)
```

### Exercise 3

Specify the number of bins to be 10 using the `bins` argument in `geom_histogram()`.

```{r exercise-14, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-14-hint, eval=FALSE}
ggplot(data = qscores, 
       mapping = aes(x = rating)) +
  geom_histogram(color = "white", 
                 fill = "red4", 
                 bins = 10)
```

### Exercise 4

Set the width of the bins to be 1 using the `binwidth` argument.

```{r exercise-15, exercise = TRUE, exercise.lines = 5}

```

Reminder: This is what our graph should look like.

```{r}
hist_p
```


```{r exercise-15-hint, eval=FALSE}
ggplot(data = qscores, 
       mapping = aes(x = rating)) +
  geom_histogram(color = "white", 
                 fill = "red4", 
                 bins = 10, 
                 binwidth = 1)
```



## `geom_bar()`

A barplot is a plot that visualizes the distribution of a categorical variable. 

Let's create the following barplot. 

```{r}
ggplot(data = trains, 
       mapping = aes(x = treatment, 
                     fill = party)) +
  geom_bar(position = "dodge")
```

### Exercise 1

Let's go back to the `trains` data set in the `primer.data` package. Use `ggplot()` and `geom_bar()` to plot `treatment` on the x-axis.

```{r exercise-19, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-19-hint, eval=FALSE}
ggplot(data = ..., 
       mapping = aes(x = ...)) + 
  ...
```

### Exercise 2

Let's now map the additional variable `party` to the `fill` argument inside `aes()`.

```{r exercise-20, exercise = TRUE}

```

```{r exercise-20-hint, eval = FALSE}
ggplot(data = trains, 
       mapping = aes(x = treatment, 
                     fill = ...)) + 
  geom_bar()
```

### Exercise 3

Let's make our graph a side-by-side barplot. Set `position` to "dodge" in `geom_bar()`.

```{r exercise-22, exercise = TRUE}

```

```{r exercise-22-hint, eval = FALSE}
ggplot(data = trains, 
       mapping = aes(x = treatment, 
                     fill = party)) +
  geom_bar(position = ...)
```



## `geom_smooth()` 

` geom_smooth()` adds a regression line on a scatterplot. 


### Exercise 1

Run the code below to see a scatterplot using the `nhanes` dataset.

```{r smooth-I-1, exercise = TRUE}
ggplot(data = nhanes, 
       mapping = aes(x = weight, 
                     y = height)) +
  geom_point()

```

### Exercise 2

Now add `geom_smooth()` to the graph. Remember you are adding a layer so you need to include `+`. 

```{r smooth-I-2, exercise = TRUE}
ggplot(data = nhanes, 
       mapping = aes(x = weight, 
                     y = height)) +
  geom_point()

```

### Exercise 3

Awesome! The line you just graphed represents the trend that we see in the scatterplot. See the message that R gave us? Because we didn't set the method that R uses to calculate the line, R defaulted to using "gam". Let's try setting the method to "lm" inside `geom_smooth()`.

```{r smooth-I-3, exercise = TRUE}

```

```{r smooth-I-3-hint, eval=FALSE}
Remember to put "lm" in quotes.
```

### Exercise 4

Great! Now get rid of the scatterplot by deleting `geom_point()` and only using `geom_smooth()`. Then, set the `color` aesthetic to the `gender` variable.

```{r smooth-I-4, exercise = TRUE}


```

```{r smooth-I-4-hint, eval = FALSE}
ggplot(data = nhanes, 
       mapping = aes(x = weight, 
                     y = height,
                     color = ...)) +
  geom_smooth()
```

### Exercise 5

As a final exercise, use what you've learned about `geom_smooth()` to recreate the plot below. The data set used for this scatterplot is `mpg`.

```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
  geom_smooth() +
  labs(title = "City vs. Highway Fuel Economy",
       x = "City Miles Per Gallon",
       y = "Highway Miles Per Gallon")
```

```{r gs-1-5, exercise = TRUE}

```

## `geom_density()`
###

`geom_density()` is used to make a density plot, a smoothed version of a histogram. It is a useful alternative to the histogram that displays continuous data in a smooth distribution.

Let's create the following density plot. 

```{r}
dens_p <- ggplot(data = cces, 
                 mapping = aes(x = age, 
                               color = ideology, 
                               fill = ideology)) +
  geom_density(alpha = .3, 
               position = "fill") + 
  xlim(20, 90)

dens_p
```

### Exercise 1

Use the dataset `cces` to make a density plot with `age` on the x axis and `ideology` set to the aesthetics `color` and `fill`.

```{r den1D-II-1, exercise = TRUE}

```


```{rden1D-II-1-hint, eval = FALSE}
ggplot(data = cces, 
       mapping = aes(x = ..., 
                     color = ..., 
                     fill = ...))
```

### Exercise 2

Great! As you can see, we have a lot of overlapping going on. Try setting the `alpha` parameter in `geom_density()` to 0.3.

```{r den1D-II-2, exercise = TRUE}


```

### Exercise 3

Nice! Now try setting the `position` parameter in `geom_density()` to "fill". Then, try setting it to "stack".

```{r den1D-II-3, exercise = TRUE}


```

### Exercise 4

Great! Now use `xlim()` to add a limit to the x axis with an upper bound of 90 and a lower bound of 20.

```{r den1D-II-4, exercise = TRUE}


```

Reminder: Your graph should look something like this. 

```{r}
dens_p
```

```{r den1D-II-4-hint, eval = FALSE}
Remember to place a comma bewtween 20 and 90 within xlim().
```


## The `tidyverse`
###

Now it's time to learn more about data wrangling using the `tidyverse` package.


### Exercise 1

Let's take a `glimpse()` at the data set `cces`. Press "Run Code".

```{r data-I-2, exercise = TRUE}
glimpse(cces)
```

### Exercise 2

We use `select()` to look at specific data columns. Start your code with `cces`. Use the pipe operator `%>% `to add the function `select()`. Within `select()`, use the arguments `gender` and `education`.

```{r select-I, exercise = TRUE}

```

```{r select-I-hint, eval = FALSE}
cces %>% 
  select(gender, education)
```

### Exercise 3

We use `filter()` to look at specific data rows. Use the pipe operator `%>%` to add the function `filter()`. Within `filter()` use the argument `state == "Massachusetts"` and `gender == "Female"`.

```{r data-I-4, exercise = TRUE}


```

```{r data-I-4-hint, eval = FALSE}
cces %>% 
  filter(state == "...", 
         gender == "...")
```

### Exercise 4

Let's organize our code by descending order of age. Copy and paste your code from above. Place `%>% `at the end of the code to add `arrange()`. Within `arrange()`, use the argument `desc(age)`.

```{r data-I-5, exercise = TRUE }

```

```{r data-I-5-hint, eval = FALSE}
cces %>% 
  filter(state == "Massachusetts", 
         gender == "Female") %>% 
  arrange(desc(age))
```

### Exercise 5

Great! Now let's get summary statistics from our data. Copy and paste the code from above. Extend the code using `%>%` again to add `summarize()`.

```{r data-I-6, exercise = TRUE}

```

### Exercise 6

Let's look at the data set called `nhanes`. Let's say we wanted to make a graph using data from the 200 youngest black males. We first would `select()` the variables we want to focus on, in this case `height`, `weight`, `age`, `race`, and `gender`. Try doing this below.

```{r data-II-1, exercise = TRUE}


```

```{r data-II-1-hint, eval = FALSE}
nhanes %>% 
  select (...)
```

### Exercise 7

Now we want to narrow down our data to only black males, so let's use `filter()` to create a tibble made up of rows from `nhanes` where `race == "Black"` and `gender == "Male"`.

```{r data-II-2, exercise = TRUE}


```

```{r data-II-2-hint, eval = FALSE}
nhanes %>% 
  ... %>% 
  filter(race == "Black", gender == "Male")
```

### Exercise 8

Great! So what now? Well, we narrowed our data to black males. How can we narrow it to the youngest black males? To do so, use `arrange()` with the argument `age`. Do this below:

```{r data-II-3, exercise = TRUE}


```

```{r data-II-3-hint, eval = FALSE}
nhanes %>% 
  ... %>% 
  ... %>% 
  arrange(...)
```

### Exercise 9

Nice! Now use `slice()` to isolate the 200 rows with the lowest age value.

```{r data-II-4, exercise = TRUE}


```

```{r data-II-4-hint-1, eval = FALSE}
Because of the way we arranged the data, the 200 rows with the lowest age value would be the first 200
```

```{r data-II-4-hint-2, eval = FALSE}
slice(1:200)
```

### Exercise 10

Let's look at the data set `mpg`. Say we wanted to know the mean city miles per gallon for each fuel type rather than an average for all fuel types. `group_by()` takes a tibble and converts it into a grouped tibble where operations are performed "by group" rather than all together. 

Start your code with `mpg`. Use ` %>% ` to add `group_by()` with the argument `fl`. 

```{r group-by, exercise = TRUE}

```

### Exercise 11

Copy and paste your code from above. Use `%>%` to add `summarize()`. Within `summarize()`, set `mean` to the `mean()`. The first argument to `mean()` should be `cty`. The second argument should be `na.rm = TRUE`. 
  
```{r summ, exercise = TRUE}

```

```{r summ-hint, eval = FALSE}
mpg %>% 
  group_by(...) %>% 
  summarize(mean = mean(cty, 
                        na.rm = ...))
```

## Submit

Congrats on finishing your first Gov 50 tutorial! You're on your way to being a master in data visualization and wrangling! :)

```{r context="setup"}
submission_ui
```

```{r context="server"}
submission_server()
```
