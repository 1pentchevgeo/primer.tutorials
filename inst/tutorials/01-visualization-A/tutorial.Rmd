---
title: "Visualization-A"
tutorial:
  id: "01-visualization-a"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: "Chapter 1 Tutorial Part A"
---


```{r setup, include=FALSE}
library(tidyverse)
library(primer.tutorials)
library(primer.data)
library(learnr)
library(ggthemes)
library(viridis)
library(nycflights13)

knitr::opts_chunk$set(echo = FALSE, message = FALSE)
options(tutorial.exercise.timelimit = 60, tutorial.storage="local")  
```


## Name

``` {r name}
question_text(
  "Student Name:",
  answer(NULL, correct = TRUE),
  allow_retry = TRUE,
  try_again_button = "Modify your answer",
  incorrect = "Ok"
)
```


## Email

``` {r email}
question_text(
  "Email:",
  answer(NULL, correct = TRUE),
  allow_retry = TRUE,
  try_again_button = "Modify your answer",
  incorrect = "Ok"
)
```


## How do I code in R?
###


**Functions** are commands that perform tasks in R for us. Functions take in inputs called arguments. In this tutorial, we will use functions to do a variety of different things. 

### Exercise 1

In the code chunk below, use the function `library()` to load the `tidyverse` package. Recall that whenever you load a package R will also load all of the packages that the first package depends on. For example, whenever you load `tidyverse`, `tidyverse` also loads `ggplot2`, `dplyr`, `tibble`, `tidyr`, `readr`, and `purrr`.

```{r packages, exercise = TRUE}

```

```{r packages-hint, eval = FALSE}
library(...)
```

### Exercise 2

If you are ever stuck, R has **help pages**  which give us access to the documentation pages for R functions, data sets, and other objects. 

Let's say we want to know what the function `lm()` does. Open the help page for `lm()` by typing `?lm()` below.

```{r functions-2, exercise = TRUE}

```

### Exercise 3

**Code comments** are text placed after a `#` symbol. Nothing will be run after a `#` symbol, which is useful if you want to write human readable comments in your code..

Run the code chunk below. Afterwards, delete the `#` and re-run the chunk. You should see a result. (Note: `sqrt()` is a function that takes the square root of its argument).

```{r functions-5, exercise = TRUE}
# sqrt(144)
```

###

**Objects*** are where values are saved in R. This way, the same code does not need to be written out each time. Instead, we can simply type the name of the object. You can choose almost any name you like for an object, as long as the name does not begin with a number or a special character like `+`, `*`, `-`, `/`, `^`, `!`, `@`, or `&`. 

### Exercise 4

Let's save the values of `rnorm(100, mean = 100, sd = 15)` to an object named `results`. Remember to use the assignment operator `<-`. 

```{r objects-2, exercise=TRUE}

```

```{r objects-2-hint, eval = FALSE}
results <- rnorm(100, mean = 100, sd = 15)
```

### Exercise 5

What do you think would happen if you assigned `results` to a new object named `copy`, like this? Run the code and then inspect both `results` and `copy` by typing their names. 

```{r objects-3, exercise=TRUE}
results<- rnorm(100, mean = 100, sd = 15)
copy <- data
```

### Exercise 6

R comes with many toy **data sets** pre-loaded. Let's examine the contents of `iris` data set. Type `iris` in the line below.

```{r objects-4, exercise = TRUE}

```

### Exercise 7

A **vector** is a series of values that are created using the `c()` function. Create a vector that contains the integers from one to ten.

```{r vectors-1, exercise = TRUE}

```

```{r vectors-1-hint, eval=FALSE}
Type the values 1-10 inside the function c().
```

### Exercise 8

If your vector contains a sequence of contiguous integers, you can create it with the `:` shortcut. Run `1:10` in the chunk below.

```{r vectors-2, exercise = TRUE}

```

### Exercise 9

You can extract any element of a vector by placing a pair of brackets `[ ]` behind the vector. Inside the brackets, place the number of the element that you'd like to extract. For example, `vec[3]` would return the third element of the vector named `vec`.

The code below assigns a vector to an object named `vec`. Use the chunk below to extract the fourth element of `vec`.

```{r vectors-3, exercise = TRUE}
vec <- c(1, 2, 4, 8, 16)
```

```{r vectors-3-hint, eval = FALSE}
vec[...]
```

### Exercise 10

You can also use `[ ]` to extract multiple elements of a vector. Place the vector `c(1,2,5)` between the brackets below. What does R return?

```{r vectors-4, exercise = TRUE}
vec <- c(1, 2, 4, 8, 16)
vec[]
```

### Exercise 11

If the elements inside your vector have names, you can extract them by name. To do so, place a name or vector of names in the brackets behind a vector. Surround each name with quotation marks, e.g. `vec2[c("alpha", "beta")]`.

Below the given code, extract the element named "gamma" from the vector below.

```{r vectors-5, exercise = TRUE}
vec2 <- c(alpha = 1, beta = 2, gamma = 3)
```

```{r vectors-5-hint, eval = FALSE}
Make sure to use quotation marks inside the brackets such as vec2["..."]
```



## Data Frames

Data frames, also referred to as "tibbles", are spreadsheet-type data sets. It's always a good idea to explore the data before you use it.  


### Exercise 1

Use `glimpse()` to look at the `trains` data set.

```{r exercise-4, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-4-hint, eval = FALSE}
Type trains inside the glimpse() function.
```

### Exercise 2

Data frames can be created using `tibble()`. Below the given code, assemble the vectors below into a data frame using `tibble()`with the column names `numbers`, `logicals`, `strings`.

```{r lists4, exercise = TRUE}
nums <- c(1, 2, 3, 4)
logs <- c(TRUE, TRUE, FALSE, TRUE)
strs <- c("apple", "banana", "carrot", "duck")
```

```{r lists4-hint-2, eval = FALSE}
tibble(nums ="...", logs = "...", strs = "...")
```

### Exercise 3

As you can see, when we use the `tibble()` function, we can see the tibble. However, when we assign the tibble to an object, we do not see the actual tibble. That is because we are just running the code to assign the values. 

Run the code below. Notice there is nothing that prints out for us to see.

```{r diff-tibble, exercise = TRUE}
data_f <- tibble(nums, logs, strs)
```

### Exercise 4

After you assign values to an object, you must type the name of the object to actually see results. Now run the code below. Notice that we can now see results.

```{r diff-2, exercise = TRUE}
data_f <- tibble(nums, logs, strs)
data_f
```

### Exercise 5

Let's now extract the `strings` column of the `data_f` data frame using the `$` operator.

```{r lists5, exercise = TRUE}
nums <- c(1, 2, 3, 4)
logs <- c(TRUE, TRUE, FALSE, TRUE)
strs <- c("apple", "banana", "carrot", "duck")
data_f <- tibble(numbers = nums, logicals = logs, strings = strs)
```



## `geom_point` 

Scatterplots allow you to visualize the relationship between two numerical variables. 

Let's create the following scatterplot. 

```{r scat-p}
scat_p <- ggplot(data = qscores, 
                 mapping = aes(x = rating, 
                               y = hours, 
                              size = enrollment)) +
                 geom_point()

scat_p
```


### Exercise 1

Let's now use `view()` to look at another data set called `qscores`.

```{r exercise-6, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-6-hint, eval=FALSE}
view(...)

```

### Exercise 2

Let's now use the `ggplot()` function to create the scatterplot. Within `ggplot()`, set `data` to `qscores`. Also, map `rating` to the x-axis and `hours` to the y-axis. See **The Primer** for guidance. Add the layer `geom_point()`.

```{r exercise-7, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-7-hint-1, eval = FALSE}
Remember when you add a layer you use +. 
```

```{r exercise-7-hint-2, eval=FALSE}
ggplot(data = qscores, 
       mapping = aes(x = ..., 
                     y = ...)) + 
    geom_point()
```

### Exercise 3

Awesome! Now we want to add a `size` aesthetic based on the number of students enrolled in each course. Set the argument `size` to `enrollment` inside the `aes()` function.

```{r exercise-8, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-8-hint, eval=FALSE}
ggplot(data = qscores, 
       mapping = aes(x = rating, 
                     y = hours, 
                     size = ...)) 
```

Reminder: This is what our graph should look like.

```{r}
scat_p
```

### Exercise 4

The following code uses the `mpg` tibble to create a scatterplot that displays 126 points. However, it visualizes a data set that contains 234 points. The missing points are hidden behind other points, a phenomenon known as _overplotting_.

Run the code below to see the scatterplot. 

```{r indiv, exercise = TRUE, out.width = "80%"}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point()
```

### Exercise 5

One method to fight overplotting is to make each point **semi-transparent**. The code chunk below provides the code used to create the graph above. Change the transparency of the points by setting `alpha = 0.2` within `geom_point()`.

```{r exercise-9, exercise = TRUE, exercise.lines = 5}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point()
```

```{r exercise-9-hint, eval=FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point(alpha = ...)
```



##`geom_jitter()` 

A second method to deal with overplotting is to use `geom_jitter()`. It plots a scatterplot and then adds a small amount of random noise to each point in the plot. 

Run the code below that creates a scatterplot that has overplotting. 

```{r indiv2, exercise= TRUE}
ggplot(data = trains, mapping = aes(x = att_start, y = att_end)) +
  geom_point()
```

### Exercise 1

Let's fix the overplotting issue. Replace `geom_point()` with `geom_jitter()`. 

```{r jit-I-1, exercise = TRUE}
ggplot(data = trains, mapping = aes(x = att_start, y = att_end)) + geom_point()
```

```{r jit-I-1-hint, eval = FALSE}
ggplot(data = trains, mapping = aes(x = att_start, y = att_end)) +
  geom_jitter()

```

### Exercise 2

As you can see, jittering the points shifted them slightly from under each other. We can adjust the amount that the points are jittered by setting the width. Set the `width` to `.2` within `geom_jitter()`.

```{r jit-I-3, exercise= TRUE, exercise.lines=6}

```

```{r jit-I-3-hint, eval = FALSE}
ggplot(data = trains, mapping = aes(x = att_start, y = att_end)) +
  geom_jitter(width = .2)

```

### Exercise 3

Now set the `color` aesthetic to the `party` variable. 

```{r jit-I-4, exercise=TRUE, exercise.lines=6}

```


```{r jit-I-4-hint, eval=FALSE}
Because color is an aesthetic, add the argument within aes().
```

### Exercise 4

As a final exercise, use what you've learned to recreate the plot below. The graph was created using the data set `diamonds`. The `alpha` of the plot is 0.2, and the `width` of the jitter distribution is 5. Use the `labs()` function to add titles.

```{r}
ggplot(data = diamonds, mapping = aes(x = depth, y = price)) +
  geom_jitter(width = 5, alpha = 0.2) +
  labs(title = "Depth and Price in Diamonds",
       x = "Depth",
       y = "Price")
```

```{r gj-1-5, exercise=TRUE, exercise.lines = 5}

```

```{r gj-1-5-hint, eval=FALSE}
ggplot(data = diamonds, mapping = aes(x = ..., y = ...)) +
  geom_jitter(width = ..., alpha = ...) +
  labs(title = "...",
       x = "...",
       y = "...")
```

## ` geom_histogram()` 

A histogram is a plot that visualizes the distribution of a numerical variable. 

Let's create the following histogram.

```{r}
hist_p <- ggplot(data = qscores, mapping = aes(x = rating)) +
        geom_histogram(binwidth = 1, color = "white", fill = "red4", bins = 10)

hist_p
```

### Exercise 1

Using the `qscores` data set and `ggplot()`, make a histogram where `rating` is on the x-axis to see the distribution of Harvard course ratings.

```{r exercise-12, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-12-hint, eval=FALSE}
ggplot(data = ..., mapping = aes(x = ...)) + ...
```

### Exercise 2

Add white vertical borders demarcating the bins by adding `color = "white"` and `fill = "red4"` arguments to `geom_histogram()`.

```{r exercise-13, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-13-hint, eval=FALSE}
ggplot(data = qscores, mapping = aes(x = rating)) +
  geom_histogram(color = ..., fill = ...)
```

### Exercise 3

Specify the number of bins to be 10 using the `bins` argument in `geom_histogram()`.

```{r exercise-14, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-14-hint, eval=FALSE}
ggplot(data = qscores, mapping = aes(x = rating)) +
  geom_histogram(color = "white", fill = "red4", bins = 10)
```

### Exercise 4

Specify the width of the bins to be 1 using the `binwidth` argument.

```{r exercise-15, exercise = TRUE, exercise.lines = 5}

```

Reminder: This is what our graph should look like.

```{r}
hist_p
```


```{r exercise-15-hint, eval=FALSE}
ggplot(data = qscores, mapping = aes(x = rating)) +
  geom_histogram(color = "white", fill = "red4", bins = 10, binwidth = 1)
```


## `geom_boxplot()` 
###

A boxplot displays the five-number summary of a set of data. The five-number summary includes the minimum, first quartile, median, third quartile, and maximum.

Let's create the following boxplot. 

```{r}
box_p <- ggplot(data = mpg, mapping = aes(x = class, y = hwy )) +
          geom_boxplot() + 
          labs( title = "Highway Fuel Efficiency in Different Types of Cars")

box_p
```

### Exercise 1

Using the `mpg` tibble, which shows the fuel efficiency for different types of cars, set x = `class` and y = `hwy`.

```{r gb-1-2, exercise=TRUE, exercise.lines = 5}

```

```{r gb-1-2-hint, eval=FALSE}
ggplot(data = mpg, mapping = aes(x = ... , y = ... )) +
  geom_boxplot()
```

### Exercise 2

Nice! Use `labs()` to title the plot "Highway Fuel Efficiency in Different Types of Cars".

```{r gb-1-4, exercise=TRUE, exercise.lines = 5}

```


```{r gb-1-4-hint, eval=FALSE}
labs(title = ...)
```


## `geom_bar()`

A barplot is a plot that visualizes the distribution of a categorical variable. 

Let's create the following barplot. 

```{r}
ggplot(data = trains, mapping = aes(x = treatment, fill = party)) +
  geom_bar(position = "dodge")
```

### Exercise 1

Let's go back to the `trains` data set in the `primer.data` package. Use `ggplot()` and `geom_bar()` to plot `treatment` on the x-axis.

```{r exercise-19, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-19-hint, eval=FALSE}
ggplot(data = ..., mapping = aes(x = ...)) + ...
```

### Exercise 2

We can now map the additional variable `party` by using the argument `fill = party` inside `aes()`.

```{r exercise-20, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-20-hint, eval=FALSE}
ggplot(data = trains, mapping = aes(x = treatment, fill = ...)) + 
  geom_bar()
```

### Exercise 3

Let's make our graph a side-by-side barplot. Set `position` to "dodge" in `geom_bar()`.

```{r exercise-22, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-22-hint, eval=FALSE}
ggplot(data = trains, mapping = aes(x = treatment, fill = party)) +
  geom_bar(position = ...)
```



## `geom_smooth()` 

` geom_smooth()` adds a regression line on a scatterplot. 


### Exercise 1

Let's start by creating a scatterplot using the `nhanes` data set. Run the code below.

```{r smooth-I-1, exercise=TRUE, exercise.lines=7}
ggplot(data = nhanes, mapping = aes(x = weight, y = height)) +
  geom_point()

```

### Exercise 2

Now add `geom_smooth()` to the graph. Remember you are adding a layer so you need to include `+`. 

```{r smooth-I-2, exercise=TRUE, exercise.lines=7, eval=FALSE}
ggplot(data = nhanes, mapping = aes(x = weight, y = height)) +
  geom_point()

```

### Exercise 3

Nice! As you can see, the line you just graphed represents the trend that we see in the scatterplot. See the message that R gave us? Because we didn't set the method that R uses to calculate the line, R defaulted to using "gam". Let's try setting the method to "lm" inside `geom_smooth()`.

```{r smooth-I-3, exercise=TRUE, exercise.lines=7}


```

```{r smooth-I-3-hint, eval=FALSE}
Remember to put "lm" in quotes.
```

### Exercise 4

Great! Now get rid of the scatterplot by deleting `geom_point()` and only using `geom_smooth()`. Then, set the `color` aesthetic to the `gender` variable.

```{r smooth-I-4, exercise=TRUE, exercise.lines=7}


```

```{r smooth-I-4-hint, eval=FALSE}
Because color is an aesthetic, set it inside of aes().
```

### Exercise 5

As a final exercise, use what you've learned about `geom_smooth()` to recreate the plot below.
(Note: The blue color is default).

```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
  geom_smooth() +
  labs(title = "City vs. Highway Fuel Economy",
       x = "City Miles Per Gallon",
       y = "Highway Miles Per Gallon")
```

```{r gs-1-5, exercise=TRUE, exercise.lines = 5}

```

## `geom_density()`
###

`geom_density()` is used to make a density plot, a smoothed version of a histogram. It is a useful alternative to the histogram that displays continuous data in a smooth distribution.

Let's create the following density plot. 

```{r}
dens_p <- ggplot(data = cces, mapping = aes(x = age, color = ideology, fill = ideology)) +
  geom_density(alpha = .3, position = "fill") + xlim(20, 90)

dens_p
```


### Exercise 1

Use the dataset `cces` to make a density plot with `age` on the x axis and `ideology` set to the aesthetics `color` and `fill`.

```{r den1D-II-1, exercise=TRUE, exercise.lines=6}

```


```{rden1D-II-1-hint, eval = FALSE}
ggplot(data = cces, mapping = aes(x = ..., color = ..., fill = ...))
```


### Exercise 2

Great! As you can see, we have a lot of overlapping going on. Try setting the `alpha` parameter in `geom_density()` to 0.3.

```{r den1D-II-2, exercise=TRUE, exercise.lines=6}


```

### Exercise 3

Nice! Now try setting the `position` parameter in `geom_density()` to "fill". Then, try setting it to "stack".

```{r den1D-II-3, exercise=TRUE, exercise.lines=7}


```

### Exercise 4

Great! Now use `xlim()` to add a limit to the x axis with an upper bound of 90 and a lower bound of 20.

```{r den1D-II-4, exercise=TRUE, exercise.lines=8}


```

Reminder: Your graph should look something like this. 

```{r}
dens_p
```

```{r den1D-II-4-hint, eval=FALSE}
Remember to place a comma bewtween 20 and 90 within xlim().
```


## The `tidyverse`
###

Now it's time to learn more about data wrangling using the `tidyverse`.


### Exercise 1

Let's take a `glimpse()` at the data set `cces`. Press "Run Code".

```{r data-I-2, exercise=TRUE, exercise.lines=3}
glimpse(cces)
```

### Exercise 2

We use `select()` to look at specific data columns. Start your code with `cces`. Use the pipe operator `%>% `to add in the function `select()`. Within `select()`, use the arguments `gender` and `education`.

```{r select-I, exercise = TRUE}

```

### Exercise 3

Recall from the chapter that we use `filter()` to look at specific data rows. Using the pipe operator `%>%`, add `filter()`. Within `filter()` use the argument `state == "Massachusetts"` and `gender == "Female"`.

```{r data-I-4, exercise=TRUE, exercise.lines=10}
cces %>% 
  filter(state == "Massachusetts", gender == "Female")

```

```{r data-I-4-hint, eval=FALSE}
cces %>% 
  filter(state == "...", gender == "...")
```

### Exercise 4

Let's organize our code by descending order of age. Copy and paste your code from above. Use `%>% `to add `arrange()`. Within `arrange()`, use the argument `desc(age)`.

```{r data-I-5, exercise=TRUE, exercise.lines=10}

```

```{r data-I-5-hint, eval=FALSE}
cces %>% 
  filter(state == "Massachusetts", gender == "Female") %>% 
  arrange(desc(age))
```

### Exercise 5

Great! Now let's get summary statistics from our data. Copy and paste the code from above. Extend  the code using `%>%` again to add `summarize()`. We want to find the mean and median ages from our filtered data.

```{r data-I-6, exercise=TRUE, exercise.lines=10}

```

### Exercise 6

Let's now use a different data set called `nhanes`. Let's say we wanted to make a graph using data on `height` and `weight` from the 200 youngest black males. We first would `select()` the variables we want to focus on, in this case `height`, `weight`, `age`, `race`, and `gender`. Try doing this below:

```{r data-II-1, exercise=TRUE, exercise.lines=10}


```

### Exercise 7

Now we want to narrow down our data to only black males, so let's use `filter()` to create a tibble made up of rows from `nhanes` where `race == "Black"` and `gender == "Male"`.

```{r data-II-2, exercise=TRUE, exercise.lines=10}


```

### Exercise 8

Great! So what now? Well, we want to look at the youngest black males. To do this, we would have to organize our data using `arrange()` with the argument `age`. Do this below:

```{r data-II-3, exercise=TRUE, exercise.lines=10}


```

### Exercise 9

Nice! Now use `slice()` to isolate the 200 rows with the lowest age value.

```{r data-II-4, exercise=TRUE, exercise.lines=10}


```

```{r data-II-4-hint-1, eval=FALSE}

Because of the way we arranged the data, the 200 rows with the lowest age value would be the first 200

```

```{r data-II-4-hint-2, eval=FALSE}

slice(1:200)

```

### Exercise 10

Let's look at the data set `weather`. Say we wanted monthly mean temperatures rather than an average temperature for all months. `group_by()` takes a tibble and converts it into a grouped tibble where operations are performed "by group" rather than all together. 

Start your code with `weather`. Use ` %>% ` to add `group_by()` with the argument `month`. 

```{r group-by, exercise = TRUE}
weather
```

### Exercise 11

Copy and paste your code from above. Use `%>%` to add `summarize()`. Within `summarize()`, set `mean` to the `mean()`. The first argument to `mean()` should be `temp`. The second argument should be `na.rm = TRUE`. 
  
```{r summ, exercise = TRUE}

```

```{r summ-hint, eval = FALSE}
weather %>% 
  group_by(...) %>% 
  summarize(mean = mean(temp, na.rm = ...)
```

## Submit

Congrats on finishing your first Gov 50 tutorial! You're on your way to being a master in data visualization and wrangling! :)

```{r context="setup"}
submission_ui
```

```{r context="server"}
submission_server()
```
