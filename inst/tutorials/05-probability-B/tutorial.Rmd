---
title: "Probability B"
tutorial:
  id: "probability-b"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: "Chapter 5 tutorial Part B"
---

```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(primer.data)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

```

```{r copy-code-chunk, child = "../../child_documents/copy_button.Rmd"}
```

```{r info-section, child = "../../child_documents/info_section.Rmd"}
```

<!-- Start Probability B. Basic structure is the same. Show a plot. And then go through the 15 steps for making the plot, but teach stuff along the way. Note that these examples will not be from the chapter. -->

<!-- First examples show how as sample size increases, you get a distribution which is more and more similar to the mathematical. Do this with rolling two dice. Final plot is 3 x 2 matrix of plots, each an empirical distribution, but with increase N.  Use map functions and list-columns, maybe. -->

<!-- Do tutorial for chapter 6 first! -->

<!-- tibble with one column N which is number of samples, one column result,  -->

<!-- N   result -->
<!-- 10    3 -->
<!-- 10    7 -->
<!-- 10    7 -->
<!-- 10    4 -->
<!-- .. -->
<!-- 20 -->
<!-- 20 -->
<!-- 20 -->
<!-- twenty rows -->
<!-- ... -->
<!-- 100 -->
<!-- 100 -->
<!-- one hundred rows -->

<!-- geom_histogram(aes(x = result)) and facet_wrap(~ N) -->

## Rolling two dice with different sample size
###

The larger the sample size, the more closely your empirical distribution will match the mathematical distribution **if** your mathematical assumptions are correct.

###

This is the plot we will replicate.

```{r}
# Turn your N column into a factor and then give it the levels in the order you
# want it to be. forcats


set.seed(2)
dice_p <- tibble(N = c(rep("10", 10), 
                          rep("20", 20),
                          rep("50", 50),
                          rep("100", 100),
                          rep("1000", 1000),
                          rep("10000", 10000)))%>%
  mutate(die_1 = map_dbl(N, ~ sample(c(1:6), size = 1))) %>% 
  mutate(die_2 = map_dbl(N, ~ sample(c(1:6), size = 1))) %>% 
  mutate(result = die_1 + die_2) %>%
  summarise(N, result) %>%
ggplot(aes(x=result))+
  geom_histogram(aes(y = stat(density)),
                 binwidth = 1, 
                 color = "white") +
    labs(title = "Empirical Probability Distribution",
         subtitle = "Sum from rolling two dice, Sample size changes",
         x = "Outcome\nSum of Two Die",
         y = "Probability") +
    facet_wrap(~ N, scales = "free") +
    scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
    scale_y_continuous(labels= scales::percent_format(accuracy = 1))

dice_p

```

### Exercise 1


Before we begin, write two sentences explaining what is *Empirical Probability Distribution*.

```{r sz-1}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    options = list(nrows = 3))
```

### Exercise 2

<!-- DK: Split this into 3 or 4 separate questions. And then, ask this question. Firts, question has answer of rep(10, 3). Second question has answer of tibble(N = rep(10, 3)). Third question has answer of tibble(N = c(rep(10, 3), rep(500, 2))). Fourth question has answer  tibble(N = c(rep(10, 3), rep(500, 2))) %>%  mutate(result = ...) -->

Create a `tibble()` with variable `N`, and set N to a list of value representing our sample size, then use `rep()` to repeat the function same numbers of times as the sample size. We want 6 different sample size: 10, 20, 50, 100, 1000, 100000.

```{r sz-2, exercise = TRUE}

```


```{r sz-2-hint-1, eval = FALSE}
tibble(N = c(rep("...", ...), 
             rep("...", ...),
             rep("...", ...),
             rep("...", ... ),
             rep("...", ... ),
             rep("...", ...)))
```

```{r sz-2-hint-2, eval = FALSE}
tibble(N = c(rep("10", 10), 
             rep("20", 20),
             rep("...", ...),
             rep("...", ... ),
             rep("...", ... ),
             rep("...", ...)))
```

<!-- Your results should looks like the following tibble. -->

<!-- ```{r} -->
<!-- size_dice -->
<!-- ``` -->

### Exercise 3

let's pipe down the tibble we create in the last exercise, let's use th `map_dbl` function to create the results for an random dice rolling experiment. recalled the` map() and map_*()` functions, within it it will includes two argument one is the data source, which in this case is `ID`. and the formula we want to use to create the dice result is the `sample()` function, and use the argument `size` within the `sample()` function to only pick one out of the six faces of a standard dice.(Should looks familiar)


```{r sz-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r sz-3-hint-1, eval = FALSE}
...%>%
map_dbl(..., ~...)
```


```{r sz-3-hint-2, eval = FALSE}
...%>%
map_dbl(N, ~sample(c(...:...), size = 1))
```

### Exercise 4
Now let's pipe down the above and use the `mutate()` function to assign the `map_dbl` functions we above to an value called "die_1".

```{r sz-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r sz-4-hint-1, eval = FALSE}
...%>%
mutate(... =map_dbl(N, ~sample(c(...:...), size = 1)))
```

### Exercise 5
Copy and paste the results from above, and do the exact same thing again but instead now named to value to `die_2`, because we need the results for two dices.

```{r sz-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r sz-5-hint, eval = FALSE}
...%>%
mutate(... =map_dbl(N, ~sample(c(...:...), size = 1)))
```

### Exercise 6
Copy and paste the results from above, use the `mutate()` function once again, name the value of the sum of `die_1` and `die_2` to "result"

```{r sz-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r sz-6-hint, eval = FALSE}
...%>%
mutate(result = die_1 + die_2)
```

### Exercise 7

Copy and paste the above, then use `summarise()` to include the column "N" and "result" only

```{r sz-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r sz-7-hint, eval = FALSE}
summarise(N,...)
```

### Exercise 8

Copy and paste the above, assign everything we have above include an new pipe called "dice-tibble", then run it.

```{r sz-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r sz-8-hint, eval = FALSE}
dice-tibble <- tibble(N = c(rep("10", 10), 
                        rep("20", 20),
                        rep("...", ...),
                        rep("...", ... ),
                        rep("...", ... ),
                        rep("...", ...))) %>%
  mutate(...) %>%
  mutate(...) %>%
  mutate(...) %>%
  summarise(...) %>%
  
dice-tibble
```

Your tibble should looks similar to the following

```{r}
size_dice
```

### Exercise 9

Now start a new pipe with "dice_tibble" , use `ggplot()` to graph the Empirical Distribution, set `x = result` within `aes()`, and then add a layer of `geom_histogram()`
```{r sz-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{sz-9-hint, eval = FALSE}
...%>%
ggplot(aes(x=...))+
  geom_histogram()
```

### Exercise 10

Copy and paste your code from above, recalled `facet_wrap()`, use `facet_wrap()` to seperate the graph into six small distribution, don't forget the `~` within `facet_wrap()`.

```{r sz-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r sz-10-hint-1, eval = FALSE}
...+
  facet_wrap(...)
```


```{r sz-10-hint-2, eval = FALSE}
...+
  facet_wrap(~ N)
```

Your graph should looks similar to this.
```{r}
size_dice%>%
  ggplot(aes(x=result))+
  geom_histogram()+
  facet_wrap(~ N)
```

### Exercise 11

Now we have a graph, but it's not looking very good, it seems like we only have the 10000 strip fills up with bars. This is because the 10000 scales is so big, that the bars in other strip is blocked. In order for them to shows, within `facet_wrap()`, add another argument `scales`, and set it equal to "free". 
```{r sz-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r sz-11-hint, eval = FALSE}
...+
facet_wrap(~ ..., scales = "...")
```
This allows the graph to use it's own scale, instead an universal scales that covered all plots.

Your graph should looks like this
```{r}
size_dice%>%
  ggplot(aes(x=result))+
  geom_histogram()+
  facet_wrap(~ N,scales = "free")
```

### Exercise 12

Copy and paste your results from above. Note that you see the red `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Let's get rid of this by adjusting binwidth for our plots, within `geom_histogram()` set "binwidth" equal to 1, and "color" between bins equal to "white".
```{r sz-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r sz-12-hint, eval = FALSE}
...+
geom_histogram(binwidth = ..., color = "...")+
  ...
```


```{r include = FALSE}
size_dice%>%
  ggplot(aes(x = result))+
  geom_histogram(binwidth = 1, color = "white")+
  facet_wrap(~ N,scales = "free")
```

### Exercise 13

Copy and paste your code from above. Now look at the values on the y-axis, for each one of the sixth plot the value is different, this is because we have different sample size, and it makes sense for each to have different *count*. In order to create an *Empirical Probability distribution*. In order to *normalized* the plot, Within `geom_histogram()`, use `aes()` . Inside `aes()`, we use the argument `y = stat(density)` to set it to put percent on y-axis.
```{r sz-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r sz-13-hint, eval = FALSE}
... +
    geom_histogram(aes(y = stat(...)))+
  ...
```

```{r include = FALSE}
size_dice%>%
  ggplot(aes(x=result))+
  geom_histogram(aes(y = stat(density)),binwidth=1, color="white")+
  facet_wrap(~ N,scales = "free")
```

### Exercise 14
Now use `scale_x_continuous()` so the x-axis has `breaks` to the sequence between 2 and 12 common difference is 1 using `seq()`. Set the `labels` for the breaks as from 2 to 12.

```{r sz-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r sz-14-hint-1, eval = FALSE}
...+
scale_x_continuous(breaks = seq(...,..., ...), labels = ...:...) 
```


```{r sz-14-hint-2, eval = FALSE}
... + 
  scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) 
```


### Exercise 15

Now use `scale_y_continuous()` to put the x-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.

```{r sz-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r sz-15-hint, eval = FALSE}
... + 
  scale_y_continuous(labels = scales::percent_format(...))
```

### Exercise 16

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels.

```{r sz-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>


```{r sz-16-hint, eval = FALSE}
... + 
  labs(title = "",subtitle = "",...)
```


Reminder: Your plot should look similar to the the one below. 

```{r}
dice_emp
```




























```{r download-answers, child = "../../child_documents/download_answers.Rmd"}
```



