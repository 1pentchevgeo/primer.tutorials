---
title: "Functions A"
tutorial:
  id: "functions-a"
output:
  learnr::tutorial:
      progressive: true
      allow_skip: true
runtime: shiny_prerendered
description: "Chapter 3 Tutorial Part A"
---
<!-- TO DO -->

<!-- Maybe get rid of all the multiple choice questions? Do they really add anything? -->

<!-- Once we rewrite the chapter, there should be lots of good questions. The more that questions can match the chapter, the better. Recall that soon (?), I want to embed the tutorial inside of the chapter itself. This should be relatively easy to do for good questions. -->

<!-- Get rid of crooked casino, like we did from the chapter. -->

<!-- We should have at least two, if not three, tutorials for chapter 3, each 1 to 2 hours long. First does all the list-columns, map_ functions, write your own function preliminaries. The second explores measures of center and variability. The third does some version of the prediction game. -->

<!-- BG: r chunk for bar plot needs to be inserted at the top of the Crooked Casino section -->

```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(gapminder)
library(skimr)

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

```

## Information
###

```{r information}
quiz(caption = "",
  question_text(
    "Name:",
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL),
  question_text(
    "Email:",
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL))


```


## List-columns and map functions
###


### Exercise 1

Let's create a list column. First, let's begin by using `rnorm()` with the argument `12`. Assign your work to an object named `x`. One the line below, take the `range()` of `x`.

```{r lm-1, exercise = TRUE}

```

```{r lm-1-hint, eval = FALSE}

```

### Exercise 2

Great! Now use `tibble()` to create a column named `col_1`, which is set to `list()`. Within `list()`, take the `range()` of `x`.

```{r lm-2, exercise = TRUE}

```

```{r lm-2-hint, eval = FALSE}

```

### Exercise 3

Let's view our column in an easier way. Copy and paste your code from above. Use ` %>% ` to pipe in the function `str()`.

```{r lm-3, exercise = TRUE}

```

```{r lm-3-hint, eval = FALSE}

```

### Exercise 4

Let's now try using `map()` to make a list column. Let's first `select()` `gender` and `height`.

```{r lm-4, exercise = TRUE}

```

```{r lm-4-hint, eval = FALSE}
nhanes %>%
  select(..., ...)
```

### Exercise 5

Continue your code with ` %>% ` to `drop_na()` and `group_by()` `gender`.

```{r lm-5, exercise = TRUE}

```

```{r lm-5-hint, eval = FALSE}
... %>%
  drop_na() %>% 
  group_by(...)
```

### Exercise 6

Lastly, use `mutate()` to create `height_quant` set to `map()`. The first argument to `map()` should be `height`. The second argument should be  `quantile()` with the argument `.` inside it.

```{r lm-6, exercise = TRUE}

```

```{r lm-6-hint-1, eval = FALSE}
... %>% 
  mutate(... = map(..., ...)))
````

### Exercise 7

Good work. Let's now work with list columns. Begin by using `tibble()` with a column `score` set to values 5 to 10.

```{r lm-7, exercise = TRUE}

```

```{r lm-7-hint-1, eval = FALSE}
Use the : operator as a shortcut instead of typing values out 
````

```{r lm-7-hint-2, eval = FALSE}
tibble(... = ...:...)
```

### Exercise 8

Now use `mutate()` to create a new column named `draws`, which is set to `map()`. The first argument to `map()` should be `scores`. The second argument should be  `rnorm()` with the argument 10.

```{r lm-8, exercise = TRUE}

```

```{r lm-8-hint-1, eval = FALSE}
Put a tilde before rnorm(10), i.e. map(scores, ~rnorm(10)
```

```{r lm-8-hint-2, eval = FALSE}
... %>% 
  mutate(... = map(..., ~ rnorm(...)))
```

### Exercise 9

Create another variable named `max` using `mutate()`. `max`should be set to `map_dbl()`. The first argument to `map_dbl()` should be `scores`. The second argument should be  `max()` with the argument `.` inside it.

```{r lm-9, exercise = TRUE}

```

```{r lm-9-hint-1, eval = FALSE}
Put a tilde before max(.), i.e. map(scores, ~ max(.))
```

```{r lm-9-hint-2, eval = FALSE}
... %>% 
  ... %>% 
  mutate(... = map_dbl(..., ~ max(...)))
```

### Exercise 10

Use `mutate()` a final time to create the variable `range` set to `map()`. The first argument to `map_dbl()` should be `scores`. The second argument should be  `range()` with the argument `.` inside it.

```{r lm-10, exercise = TRUE}

```

```{r lm-10-hint, eval = FALSE}
Put a tilde before range(.), i.e. map(scores, ~ range(.))
```


## Anonymous functions
###

We can create functions that do operations “on the fly” without bothering to give them a name. 

### Exercise 1

Let's conduct a mathematical operation. Use `tibble()` to create a column named `before`, which is set to `c()` that contains values 4, 6, and 8. 

```{r af-1, exercise = TRUE}

```

```{r af-1-hint, eval = FALSE}
tibble(... = c(...))
```

### Exercise 2

Use `mutate()` to create a new column `after`, which is set to `map_dbl()`. The first argument to `map_dbl()` should be `before`. The second argument should be  `~ (. - 1)`, which subtracts the value 1 from each value in `before`.

```{r af-2, exercise = TRUE}

```

```{r af-2-hint, eval = FALSE}
... %>% 
  mutate(... = map_dbl(..., ~ (. + 1)))
```

## Creating your own functions
###


### Exercise 1

Use `function()` and `{ }` to create a function that multiply 2 by 3. Name this function `mult_two_three`. Then, call your function to see it in action!

```{r cf-1, exercise = TRUE}

```

```{r cf-1-hint-1, eval = FALSE}
mult_two_three <- function(){
  ...
}

mult_two_three()
```

```{r cf-1-hint-2, eval = FALSE}
mult_two_three <- function(){
  2 * 3
}
mult_two_three()
```

### Exercise 2

Adjust your function by adding an `x` inside `function()`. Then, replace the 3 within `{ }` with `x`. This way, any value we put inside our function will be multiplied by 3. 


```{r cf-2, exercise = TRUE}

```

```{r cf-2-hint-1, eval = FALSE}
mult_two_three <- function(...){
  ...
}

mult_two_three()
```

```{r cf-2-hint-2, eval = FALSE}
mult_two_three <- function(x){
  x * 3
}
mult_two_three()
```

### Exercise 3

Put your function `mult_two_three()` to the test! Use `mult_two_three()` and set `x` to 4.  

```{r cf-3-setup}
mult_two_three <- function(x){
  x * 3
}
mult_two_three()
```


```{r cf-3, exercise = TRUE}

```


```{r cf-3-hint-1, eval = FALSE}
mult_two_three(...)
```

```{r cf-3-hint-2, eval = FALSE}
mult_two_three(x = ...)
```


## no_NA_sampler()
###



## Prediction Game 
###



### Exercise 2

Rewrite the below function using `case_when()`.

```{r foo-6, echo=TRUE}
foo <- function(x){
  if(x > 2) "a"
  else if(x < 2) "b"
  else if(x == 1) "c"
  else "d"
}
```

```{r foo_rewrite, exercise=TRUE}
foo2 <- function(x){
  case_when(
    
    # Insert code here!
    
  )
}
```

```{r foo_rewrite-hint-1, eval=FALSE}
foo2 <- function(x){
  case_when(
    x > 2  ~ "a",
    x < 2  ~ "b",
    ...
  )
}
```

```{r foo_rewrite-hint-2, eval=FALSE}
foo2 <- function(x){
  case_when(
    x > 2  ~ "a",
    x < 2  ~ "b",
    x == 1 ~ "c",
    TRUE ~ ...
  )
}
```




### Exercise 3

```{r foo-10, eval=FALSE, echo=TRUE}
foo <- function(x){
  if(x > 2) "a"
  else if(x < 2) "b"
  else if(x == 1) "c"
  else "d"
}
foo(1)
```

```{r else-if-quiz}
quiz(
  question("What will this code return?",
         answer('"a"', message = "R will not return a because the condition 1 > 2 is false."),
         answer('"b"', correct = TRUE, message = 'The condition 1 < 2 is true, so R will evaluate the code that follows it (i.e. "b") and then skip the remainder of the multi-part if statement.'),
         answer('"a" "b"', message = "The conditions 1 < 2 and 1 == 1 are both TRUE, but R will stop after the _first_ true condition."),
         allow_retry = TRUE))
```

### Exercise 4

```{r missing_code_chunk_name, eval=FALSE, echo=TRUE}
clean <- function(x){
  if(x == -99) NA 
  if(x == ".") NA
  if(x == "NaN") NA
  x
}
clean(-99)
```

```{r clean3-quiz}
quiz(
  question("What will this code return?",
         answer("NA", message = "Did you notice that the `if` statements are not linked by `else`? What difference does this make?"),
         answer("-99", correct = TRUE, message = "Since the `if` clauses are not linked by `else`, R treats them as separate statements. R checks each if statement. After the first statement it runs NA, but does not return this as the result of the function (because this is not the final statement in the function). R does not run NA for the next two if statements because their conditions are false. Then R reaches `x`, which is the last line and last statement in the function. R evaluates `x`, which equals -99, and returns -99 as the result of the function."),
         allow_retry = TRUE))
```





## Practice: Monthly Temperatures 
###



#### Exercise 1


Using the data set `airquality`, create a list-column of monthly temperatures called `monthly_temp`, grouping by `Month`.

```{r exercise-2a, exercise=TRUE}

```

```{r exercise-2a-hint, eval=FALSE}
airquality %>%
   group_by(Month) %>%
   mutate(monthly_temp = list(...))
```



#### Exercise 2

<!-- DK: What an absurd question! -->

```{r quiz-4}
quiz(question("Which of the following possibilities for filling in the blank is syntactically correct and converts from Fahrenheit to Celsius?",
           answer("(. - 32) * 5/9)"),
           answer("(- 32 * 5/9)"),
           answer("~ (. - 32) * 5/9)", correct = TRUE),
           answer("~ (fahrenheit - 32) * 5/9)"))
)
```


#### Exercise 3


Use a `map_*` function to convert all of the temperatures in `monthly_temp` from Fahrenheit to Celsius, creating a new variable `temp_celsius`. Hint: Use the formula from the quiz above!

```{r exercise-3a, exercise=TRUE, eval=FALSE}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(...)
```

```{r exercise-3a-hint, eval=FALSE}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(temp_celsius = map(monthly_temp, ...))
```


#### Exercise 4


Oops! The scientists made a mistake in which all of the temperatures were mis-recorded. For temperatures recorded at or below 20 degrees Celsius, the true temperature is actually 1 degree Celsius lower. For temperatures recorded as higher than 20 degrees Celsius, the true temperature is actually 3 degrees Celsius higher.

Write an anonymous function that rectifies the scientists' mistake by using `case_when()`.

```{r exercise-4a, exercise=TRUE, eval=FALSE}
function(x) 
  case_when(...)
```

```{r exercise-4a-solution}
function(x) 
  case_when(x <= 20 ~ x - 1,
            x > 20 ~ x + 3)
```


#### Exercise 5

Now use this function along with `map()`, swapping out the function code after the `~` in the `map()` argument.

```{r exercise-5a, exercise=TRUE, eval=FALSE}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(temp_celsius = map(monthly_temp, ~ (. - 32)* 5/9)) %>%
  mutate(temp_celsius = map(temp_celsius, ~ ...))
```

```{r exercise-5a-hint, eval=FALSE}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(temp_celsius = map(monthly_temp, ~ (. - 32)* 5/9)) %>%
  mutate(temp_celsius = map(temp_celsius, ~ case_when(...)))
```




## Coin Flipping exercise

###

Let's create a function, `coin_flip()`, that takes an input `n` of the number of times to flip a coin and adds up the number of Tails.

### Exercise 1

Let's start by creating a minimally viable function called `starter_coin()` that flips one coin once and prints out `H` or `T`. Remember: You can paste vectors as an argument into `sample()`!

```{r coin1, exercise=TRUE, eval=FALSE}

```

```{r coin1-hint, eval=FALSE}
starter_coin <- function() sample(c("H", "T"), ...)
```

### Exercise 2

Now let's take it up a notch and add in a formal argument `n` that specifies the number of times to flip the coin.

```{r coin2, exercise=TRUE, eval=FALSE}

```

```{r coin2-hint, eval=FALSE}
starter_coin <- function(n) sample(c("H", "T"), n, replace = ...)
```

### Exercise 3

Add in a sensible `stopifnot()` to your function that checks whether the input `n` is numeric.

```{r coin3, exercise=TRUE}

```

```{r coin3-hint, eval=FALSE}
starter_coin <- function(n){
  stopifnot(is.numeric(...))
  sample(c("H", "T"), n, replace = TRUE)
}
```

### Exercise 4

Great! Now we should be able to create `coin_flip()`, which counts the number of Tails for `n` flips. Set the default value of `n` to 1.

```{r coin4, exercise=TRUE, eval=FALSE}
coin_flip <- function(n = 1){
  ...
}
```

```{r coin4-hint-1, eval=FALSE}
Use the code from starter_coin() and sum().
```

```{r coin4-hint-2, eval=FALSE}
coin_flip <- function(n = 1){
  stopifnot(is.numeric(n))
  sum(sample(c("H", "T"), n, replace = TRUE) == ...)
}
```

### Exercise 5

Now let's create a function called `five_flips` that counts how many Tails occur in five coin flips, or the equivalent of `coin_flip(5)`, but calls it `n` times.
* Set the default value of `n` separate flips to 1.
* Use a `map_*` function to apply the `rep()` function to `coin_flip()` `n` times.

```{r coin5, exercise=TRUE}
five_flips <- function(n = 1){
}
```

```{r coin5-hint-1, eval=FALSE}
The map function you are looking for is map_int().
```

```{r coin5-hint-2, eval=FALSE}
rep(x,n) means that you are flipping x coins n times.
```

```{r coin5-hint-3, eval=FALSE}
five_flips <- function(n = 1){
  stopifnot(is.numeric(n))
  map_int(rep(5, n), ...)
}
```


### Exercise 6

Create a tibble named `x` with one variable: `flips`. `flips` is a list column of 10 observations, each element of which is result of flipping 5 coins 10 times.  Make sure to use the correct `map_*` function.

```{r coin7, exercise=TRUE, eval=FALSE}
x <- tibble(flips = ...)
```

```{r coin7-hint, eval=FALSE}
x <- tibble(flips = map(rep(10, 10), ...))
```




## Random variables
###

### Exercise 1


Let's create a function `biggest()`, which takes the larger of two random variables. Use `n = 1` for both random variables.

```{r biggest1, exercise=TRUE, eval=FALSE}
biggest <- function(){
  ...
}

```

```{r biggest1-hint, eval=FALSE}
biggest <- function(){
  max(runif(...), rnorm(...))
}

```

### Exercise 2

Modify `biggest()` so that it prints out "Uniform" if the larger variable is the uniformally distributed random variable, and "Normal" if otherwise.
* Use `case_when()` with `TRUE ~ "Tie"`.
* Remember that `runif()` and `rnorm()` generate *random* values every time they are called...

```{r biggest2, exercise=TRUE, eval=FALSE}
biggest <- function(){
  ...
}

```

```{r biggest2-hint-1, eval=FALSE}
biggest <- function(){
  x <- runif(1)
  y <- rnorm(1)
  case_when(...)
}
```

```{r biggest2-hint-2, eval=FALSE}
biggest <- function(){
  x <- runif(1)
  y <- rnorm(1)
  case_when(x > y ~ "Uniform",
           y > x ~ "Normal",
           ...)
}
```

### Exercise 3

We'd like for `biggest()` to return a vector of two elements: The name of the distribution of the larger random variable and its value. If the two values are identical, we'd like for the function to return "Tie" and the value of one of the variables (since they are identical).

```{r biggest3, exercise=TRUE, eval=FALSE}
biggest <- function(){
  x <- runif(1)
  y <- rnorm(1)
  case_when(x > y ~ ...,
            y > x ~ ...,
            TRUE ~ ...)
}
```

```{r biggest3-hint, eval=FALSE}
biggest <- function(){
  x <- runif(1)
  y <- rnorm(1)
  case_when(x > y ~ c("Uniform", x),
           y > x ~ c("Normal", y),
           TRUE ~ c("Tie", ...))
}
```

### Exercise 4

Let's create a new function named `repeat_biggest()` that does so by calling `biggest()` `n` number of times.
* Use `replicate()` to call the function multiple times.

```{r newfunc, exercise=TRUE, eval=FALSE}
repeat_biggest <- function(n){
  replicate(...)
}
```

```{r newfunc-solution}
repeat_biggest <- function(n = 1){
  replicate(n, biggest())
}
```


## The Crooked Casino
###


<!-- Show the plot at the start. Discuss its meaning. Hint at what we will discuss in chapter 5. Then, walk through the step-by-step creation of it. -->

Recall the function we wrote in the chapter to model a crooked game of craps. `crooked_craps()` is expected to return a winning 7 or 11 only *half* of the time the sum is actually 7 or 11. It returns a 2 much more often than it should. Code:

```{r crooks, echo=TRUE}
crooked_dice <- function(n = 1){
  stopifnot(is.numeric(n))
  stopifnot(n >= 0)
  roll <- sum(sample(1:6, n, replace = TRUE))
  ifelse((roll == 7 | roll == 11) && runif(1) >= 0.5, 2, roll)
}

crooked_craps <- function(n = 1){
  stopifnot(is.numeric(n))
  map_dbl(rep(2, n), crooked_dice)
}
```

Let's put our visualization skills to the test.

### Exercise 1

Create a tibble with column "games" and run `crooked_craps()` 100 times.


```{r crooked-1, exercise=TRUE}

```

```{r crooked-1-hint, eval=FALSE}
tibble(games = crooked_craps(...))
```

### Exercise 2

Create a barplot with `games` on the `x` axis.


```{r crooked-2, exercise=TRUE, eval=FALSE}
tibble(games = crooked_craps(100))
```

### Exercise 3

Now, change the `x` axis scale to increment by integers from 2 to 12.

```{r crooked-3, exercise=TRUE, eval=FALSE}
tibble(games = crooked_craps(100)) %>%
  ggplot(aes(x = games)) +
  geom_bar()
```

```{r crooked-3-hint, eval=FALSE}
tibble(games = crooked_craps(100)) %>%
  ggplot(aes(x = games)) +
  geom_bar() %>%
  scale_x_continuous(breaks = seq(...))
```

### Exercise 4

Use an appropriate `map_*` function and `rep()` to call `crooked_craps(100)` 10 times. Create a tibble named `x` with a column named `games`.

```{r crooked-4, exercise=TRUE, eval=FALSE}

```

```{r crooked-4-hint, eval=FALSE}
x <- tibble(games = map(rep(100, 10), ...))
```

### Exercise 5

Inside each of these iterations of 100 rolls, we want to count the number of 3's and 11's. Technically, with a fair die one would expect as many 11's to appear as 3's. 11's can be obtained in two different ways: by adding 5 + 6 and 6 + 5. The same goes for 3's: by adding 1 + 2 and 2 + 1.

First, count the number of 3's. You can do so by using a the appropriate `map_*` function and an anonymous function defined as `sum(. == 3)`.


```{r crooked-5, exercise=TRUE, eval=FALSE}
x <- tibble(games = map(rep(100, 10), crooked_craps)) %>%
  mutate(counts = ...)
```

```{r crooked-5-hint, eval=FALSE}
x <- tibble(games = map(rep(100, 10), crooked_craps)) %>%
  mutate(counts = map_int(games, ~(...)))
```

### Exercise 6

Now, modify `counts` so that it is a list-column of 2 elements per list: The number of 3's, then the number of 11's.


```{r crooked-6, exercise = TRUE}
x <- tibble(games = map(rep(100, 10), crooked_craps)) %>%
  mutate(counts = map_int(games, ~sum(. == 3)))
```

```{r crooked-6-hint}
x <- tibble(games = map(rep(100, 10), crooked_craps)) %>%
  mutate(counts = map(games, ~list(sum(. == 3), ...)))
```


## Submit

Some of these exercises were taken from the collection of [RStudio Primers](https://rstudio.cloud/learn/primers), a great resource for practicing your skills.

```{r context="setup"}
submission_ui
```

```{r context="server"}
submission_server()
```
